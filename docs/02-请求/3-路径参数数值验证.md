# 路径参数和数值验证 - FastAPI 教程

## 1. 导入 Path

与使用 Query 为查询参数声明更多验证和元数据的方式相同, 你可以使用 Path 为路径参数声明相同类型的验证和元数据。

首先, 从 fastapi 导入 Path, 并导入 Annotated:

```python
# Python 3.10+
from typing import Annotated
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],  # 路径参数
    q: Annotated[str | None, Query(alias="item-query")] = None,  # 查询参数
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

**提示**: 尽可能使用 `Annotated` 版本。

### 1.1 旧版本语法（不推荐）

```python
# Python 3.9+
from typing import Union
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: int = Path(title="The ID of the item to get"),
    q: Union[str, None] = Query(default=None, alias="item-query"),
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

## 2. 声明元数据

你可以声明与 Query 相同的所有参数。例如, 要为路径参数 item_id 声明标题元数据值, 你可以这样写:

```python
# Python 3.10+
from typing import Annotated
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[str | None, Query(alias="item-query")] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

**注意**: 路径参数总是必需的, 因为它必须是路径的一部分。即使你用 None 声明它或设置默认值, 也不会影响任何东西, 它仍然总是必需的。

## 3. 按需排序参数

**提示**: 如果你使用 Annotated, 这可能不太重要或不需要。

假设你想将查询参数 q 声明为必需的 str。而且你不需要为该参数声明任何其他内容, 所以你实际上不需要使用 Query。但你仍然需要为 item_id 路径参数使用 Path。

如果你不使用 Annotated, Python 会在你将带有"默认"的值放在没有"默认"的值之前时抱怨。

但你可以重新排序它们, 将没有默认值的值(查询参数 q) 放在前面。这对 FastAPI 来说无关紧要。它将通过名称、类型和默认声明(Query、Path 等)检测参数, 不关心顺序。

所以, 你可以这样声明你的函数:

```python
# Python 3.9+ - 不使用 Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    q: str,  # 没有默认值的参数在前
    item_id: int = Path(title="The ID of the item to get")  # 有默认值的参数在后
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+ - 使用 Annotated
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    q: str,
    item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

### 3.1 参数排序技巧

**提示**: 如果你使用 Annotated, 这可能不太重要或不需要。

这里有一个有用的小技巧, 但你不经常需要它。

如果你想:
- 声明查询参数 q, 不使用 Query 也没有默认值
- 使用 Path 声明路径参数 item_id
- 以不同的顺序放置它们
- 不使用 Annotated

Python 对此有一个特殊的小语法。将 `*` 作为函数的第一个参数传递。Python 不会对 `*` 做任何事情, 但它会知道所有后面的参数都应该作为关键字参数(键值对)调用, 也称为 kwargs。即使它们没有默认值。

```python
# Python 3.9+ - 不使用 Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    *,  # 强制后续参数为关键字参数
    item_id: int = Path(title="The ID of the item to get"),
    q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

### 3.2 Annotated 的优势

请记住, 如果你使用 Annotated, 你就不会有这个问题, 因为你不是使用函数参数默认值来声明 Query() 或 Path()。

```python
# Python 3.9+ - 使用 Annotated
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

## 4. 数值验证: 大于等于

使用 Query 和 Path(以及你稍后将看到的其他的), 你可以声明数字约束。

这里, 使用 `ge=1`, item_id 需要是一个整数数字, "大于等于" 1。

```python
# Python 3.9+
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=1)],  # ge: greater than or equal
    q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+ - 不使用 Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: int = Path(title="The ID of the item to get", ge=1),
    q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

## 5. 数值验证: 大于和小于等于

同样适用于:

- `gt`: 大于 (greater than)
- `le`: 小于等于 (less than or equal)

```python
# Python 3.9+
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", gt=0, le=1000)],  # 0 < item_id <= 1000
    q: str,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+ - 不使用 Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: int = Path(title="The ID of the item to get", gt=0, le=1000),
    q: str,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

## 6. 数值验证: 浮点数, 大于和小于

数值验证也适用于浮点值。在这里, 能够声明 `gt` 而不仅仅是 `ge` 变得很重要。

有了它, 你可以要求值必须大于 0, 即使它小于 1。所以, 0.5 将是有效值。但 0.0 或 0 不会。对于 `lt` 也是如此。

```python
# Python 3.9+
from typing import Annotated
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str,
    size: Annotated[float, Query(gt=0, lt=10.5)],  # 浮点数验证: 0 < size < 10.5
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if size:
        results.update({"size": size})
    return results
```

```python
# Python 3.9+ - 不使用 Annotated
from fastapi import FastAPI, Path, Query

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
    q: str,
    size: float = Query(gt=0, lt=10.5),
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if size:
        results.update({"size": size})
    return results
```

## 7. 总结

使用 Query、Path(以及你尚未看到的其他类), 你可以按照与查询参数和字符串验证相同的方式声明元数据和字符串验证。

你还可以声明数值验证:

- **gt**: 大于 (greater than)
- **ge**: 大于等于 (greater than or equal)
- **lt**: 小于 (less than)
- **le**: 小于等于 (less than or equal)

### 7.1 参数类的关系

**信息**: Query、Path 和你稍后将看到的其他类是一个公共 Param 类的子类。它们都共享相同的参数用于额外的验证和元数据。

### 7.2 技术细节

当你从 fastapi 导入 Query、Path 等时, 它们实际上是函数。当被调用时, 它们返回同名的类的实例。

所以, 你导入 Query, 它是一个函数。当你调用它时, 它返回一个同样名为 Query 的类的实例。

这些函数的存在(而不是直接使用类)是为了让你的编辑器不会标记关于它们的类型的错误。这样你可以使用普通的编辑器和编码工具, 而无需添加自定义配置来忽略这些错误。

## 8. 验证规则总结

### 8.1 路径参数验证
- 总是必需的
- 可以使用 Path 进行元数据声明
- 支持数值验证

### 8.2 数值验证约束
| 约束 | 说明 | 示例 |
|------|------|------|
| gt | 大于 | gt=0 (大于 0) |
| ge | 大于等于 | ge=1 (大于等于 1) |
| lt | 小于 | lt=10.5 (小于 10.5) |
| le | 小于等于 | le=1000 (小于等于 1000) |

### 8.3 最佳实践
1. 优先使用 Annotated 语法
2. 使用有意义的标题和描述
3. 根据业务需求选择合适的数值约束
4. 在文档中清楚地说明数值范围

这些功能使得 FastAPI 能够构建类型安全、数据验证完善的 API。