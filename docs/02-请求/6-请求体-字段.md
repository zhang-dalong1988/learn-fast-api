# 请求体字段 - FastAPI 教程

## 1. 导入 Field

与使用 Query、Path 和 Body 在路径操作函数参数中声明额外验证和元数据的方式相同, 你可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明验证和元数据。

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field  # 注意: Field 从 pydantic 导入

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = Field(
        default=None,
        title="The description of the item",
        max_length=300
    )
    price: float = Field(
        gt=0,
        description="The price must be greater than zero"
    )
    tax: float | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]
):
    results = {"item_id": item_id, "item": item}
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = Field(
        default=None,
        title="The description of the item",
        max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: Union[float, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]
):
    results = {"item_id": item_id, "item": item}
    return results
```

**提示**: 尽可能使用 `Annotated` 版本。

**警告**: 请注意, Field 是直接从 pydantic 导入的, 而不是像其他所有 (Query、Path、Body 等) 那样从 fastapi 导入。

## 2. 声明模型属性

然后你可以将 Field 与模型属性一起使用:

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = Field(
        default=None,
        title="The description of the item",
        max_length=300
    )
    price: float = Field(
        gt=0,
        description="The price must be greater than zero"
    )
    tax: float | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]
):
    results = {"item_id": item_id, "item": item}
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = Field(
        default=None,
        title="The description of the item",
        max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: Union[float, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]
):
    results = {"item_id": item_id, "item": item}
    return results
```

### 2.1 旧版本语法（不推荐）

```python
# Python 3.9+
from typing import Union
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = Field(
        default=None,
        title="The description of the item",
        max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: Union[float, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item = Body(embed=True)  # 旧方法: Body 作为默认值
):
    results = {"item_id": item_id, "item": item}
    return results
```

Field 的工作方式与 Query、Path 和 Body 相同, 它具有相同的参数, 等等。

## 3. Field 的参数

Field 支持以下常用参数:

### 3.1 验证参数

- `default`: 默认值
- `default_factory`: 默认值工厂函数
- `alias`: 字段别名
- `title`: 字段标题
- `description`: 字段描述
- `gt`: 大于 (greater than)
- `ge`: 大于等于 (greater than or equal)
- `lt`: 小于 (less than)
- `le`: 小于等于 (less than or equal)
- `multiple_of`: 必须是某数的倍数
- `min_length`: 最小长度
- `max_length`: 最大长度
- `regex`: 正则表达式模式

### 3.2 示例

```python
# Python 3.10+
from typing import Annotated
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: Annotated[str, Field(min_length=1, max_length=100)]
    price: Annotated[float, Field(gt=0, le=10000, description="价格必须在 0-10000 之间")]
    discount: Annotated[float | None, Field(ge=0, le=1, description="折扣率，0-1 之间")] = None
    tags: Annotated[list[str], Field(max_items=10)] = []
    is_available: bool = True
```

## 4. 添加额外信息

你可以在 Field、Query、Body 等中声明额外信息。它将包含在生成的 JSON Schema 中。

你将在后面的文档中学习更多关于添加额外信息的内容, 当学习声明示例时。

**警告**: 传递给 Field 的额外键也将存在于生成的应用程序的 OpenAPI schema 中。由于这些键不一定是 OpenAPI 规范的一部分, 一些 OpenAPI 工具(例如 OpenAPI 验证器)可能无法使用你生成的 schema。

## 5. 完整示例

```python
# Python 3.10+
from typing import Annotated, List
from fastapi import FastAPI, Body, HTTPException
from pydantic import BaseModel, Field, validator
from datetime import datetime

app = FastAPI()

class Product(BaseModel):
    """商品模型"""

    id: Annotated[int, Field(ge=1, description="商品ID")]
    name: Annotated[str, Field(
        min_length=1,
        max_length=100,
        description="商品名称",
        example="智能手机"
    )]
    description: Annotated[str | None, Field(
        max_length=500,
        description="商品描述",
        default=None
    )]
    price: Annotated[float, Field(
        gt=0,
        le=999999,
        description="商品价格",
        example=4999.99
    )]
    discount: Annotated[float | None, Field(
        ge=0,
        le=1,
        description="折扣率 (0-1)",
        default=None
    )]
    stock: Annotated[int, Field(
        ge=0,
        description="库存数量"
    )]
    tags: Annotated[List[str], Field(
        max_items=10,
        description="商品标签",
        default=[]
    )]
    is_active: bool = Field(default=True, description="是否上架")
    created_at: datetime = Field(default_factory=datetime.now, description="创建时间")

    @validator('discount')
    def validate_discount(cls, v, values):
        """验证折扣率不能使价格低于原价的10%"""
        if v is not None and 'price' in values:
            min_price = values['price'] * 0.1
            if values['price'] * (1 - v) < min_price:
                raise ValueError('折扣后的价格不能低于原价的10%')
        return v

    model_config = {
        "json_schema_extra": {
            "example": {
                "id": 1,
                "name": "智能手机",
                "description": "最新款智能手机",
                "price": 4999.99,
                "discount": 0.9,
                "stock": 100,
                "tags": ["电子产品", "智能手机"],
                "is_active": True,
                "created_at": "2023-12-19T10:00:00Z"
            }
        }
    }

class UpdateProduct(BaseModel):
    """更新商品模型 - 所有字段都是可选的"""

    name: Annotated[str | None, Field(min_length=1, max_length=100)] = None
    description: Annotated[str | None, Field(max_length=500)] = None
    price: Annotated[float | None, Field(gt=0, le=999999)] = None
    discount: Annotated[float | None, Field(ge=0, le=1)] = None
    stock: Annotated[int | None, Field(ge=0)] = None
    tags: Annotated[List[str] | None, Field(max_items=10)] = None
    is_active: bool | None = None

@app.post("/products/")
async def create_product(product: Annotated[Product, Body(description="要创建的商品信息")]):
    """创建新商品"""
    # 在实际应用中，这里会将数据保存到数据库
    return {
        "message": "商品创建成功",
        "product": product.model_dump()
    }

@app.patch("/products/{product_id}")
async def update_product(
    product_id: Annotated[int, Field(ge=1, description="商品ID")],
    product_update: Annotated[UpdateProduct, Body(description="要更新的商品信息")]
):
    """更新商品信息"""
    # 在实际应用中，这里会从数据库获取商品并更新
    return {
        "message": f"商品 {product_id} 更新成功",
        "product_id": product_id,
        "updates": {k: v for k, v in product_update.model_dump().items() if v is not None}
    }

@app.get("/products/{product_id}")
async def get_product(
    product_id: Annotated[int, Field(ge=1, description="商品ID")]
):
    """获取商品信息"""
    # 在实际应用中，这里会从数据库获取商品
    return {
        "product_id": product_id,
        "message": "商品信息获取成功"
    }
```

## 6. 技术细节

实际上, Query、Path 和你稍后将看到的其他函数创建的是一个公共 Param 类的子类的对象, 该类本身就是 Pydantic 的 FieldInfo 类的子类。

而 Pydantic 的 Field 也返回 FieldInfo 的实例。

Body 也直接返回 FieldInfo 的子类的对象。

还有其他你稍后将看到的类是 Body 类的子类。

**请记住**, 当你从 fastapi 导入 Query、Path 等时, 那些实际上是返回特殊类的函数。

**提示**: 请注意每个带有类型、默认值和 Field 的模型属性都具有与路径操作函数参数相同的结构, 只是使用 Field 而不是 Path、Query 和 Body。

## 7. 总结

- 你可以使用 Pydantic 的 Field 为模型属性声明额外的验证和元数据
- Field 提供了丰富的验证选项 (gt、ge、lt、le、min_length、max_length 等)
- Field 可以添加描述、标题等元数据, 用于自动生成的文档
- Field 与 Query、Path、Body 具有相似的参数和工作方式
- Field 从 pydantic 导入, 而不是从 fastapi

这些特性使得 FastAPI 能够构建强类型、自动验证和文档完善的 API。
