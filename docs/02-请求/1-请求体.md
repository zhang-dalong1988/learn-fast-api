# 请求体## 1. 请求体基础当你需要从客户端(比如浏览器)向 API 发送数据时, 你会将其作为**请求体**发送。- **请求体**: 客户端发送到 API 的数据- **响应体**: API 发送给客户端的数据你的 API 几乎总是需要发送响应体。但客户端不总是需要发送请求体, 有时它们只请求一个路径, 可能带有一些查询参数, 但不发送请求体。要声明请求体, 你需要使用 Pydantic 模型, 利用其所有功能和优势。**信息**: 要发送数据, 你应该使用以下方法之一:- POST(更常见)- PUT- DELETE 或 PATCH使用 GET 请求发送请求体在规范中未定义行为, 尽管如此, FastAPI 支持它, 仅用于非常复杂/极端的用例。由于不推荐使用, 当使用 GET 时, Swagger UI 的交互式文档不会显示请求体的文档, 中间代理可能不支持它。## 2. 导入 Pydantic 的 BaseModel首先, 你需要从 pydantic 导入 BaseModel:```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):  # 继承 BaseModel 创建数据模型    name: str    description: str | None = None    price: float    tax: float | None = Noneapp = FastAPI()@app.post("/items/")  # 使用 POST 方法async def create_item(item: Item):  # item 参数是请求体    return item``````python# Python 3.9+from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):    return item```## 3. 创建数据模型然后你将数据模型声明为继承自 BaseModel 的类。对所有属性使用标准 Python 类型:```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str                    # 必需字段    description: str | None = None  # 可选字段, 默认为 None    price: float                 # 必需字段    tax: float | None = None     # 可选字段, 默认为 Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):    return item``````python# Python 3.9+from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):    return item```与声明查询参数相同, 当模型属性有默认值时, 它不是必需的。否则, 它是必需的。使用 `None` 使其可选。例如, 上面的模型声明了这样的 JSON "对象"(或 Python dict):```json{  "name": "Foo",  "description": "An optional description",  "price": 45.2,  "tax": 3.5}```由于 description 和 tax 是可选的(默认值为 None), 这个 JSON "对象" 也是有效的:```json{  "name": "Foo",  "price": 45.2}```## 4. 声明为参数要将其添加到路径操作, 使用与声明路径和查询参数相同的方式声明:```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: str | None = None    price: float    tax: float | None = Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):  # 声明类型为 Item 模型    return item```...并将其类型声明为你创建的模型 Item。## 5. 自动处理仅通过这个 Python 类型声明, FastAPI 将:1. **读取请求体**为 JSON2. **转换相应的类型**(如果需要)3. **验证数据**   - 如果数据无效, 将返回一个清晰明了的错误, 指出错误的确切位置和内容4. **在参数 item 中提供接收到的数据**5. 由于你在函数中声明它为 Item 类型, 你还将获得所有属性的编辑器支持(自动补全等)6. **为模型生成 JSON Schema 定义**, 如果对你的项目有意义, 你可以在任何其他地方使用它们7. 这些模式将成为生成的 OpenAPI 模式的一部分, 并被自动文档 UI 使用## 6. 自动文档模型的 JSON 模式将成为你生成的 OpenAPI 模式的一部分, 并将在交互式 API 文档中显示:![API 文档截图显示请求体模型](https://fastapi.tiangolo.com/img/tutorial/body/image01.png)也会在需要它们的每个路径操作的 API 文档中使用:![每个路径操作的请求体文档](https://fastapi.tiangolo.com/img/tutorial/body/image02.png)## 7. 编辑器支持在你的编辑器中, 在函数内部你将随处获得类型提示和自动补全(如果你接收的是 dict 而不是 Pydantic 模型, 这不会发生):![编辑器中的自动补全](https://fastapi.tiangolo.com/img/tutorial/body/image03.png)你也可以获得不正确类型操作的错误检查:![编辑器中的类型检查](https://fastapi.tiangolo.com/img/tutorial/body/image04.png)这不是偶然的, 整个框架围绕这个设计构建。它在实现之前在设计阶段经过彻底测试, 以确保它能与所有编辑器一起工作。甚至对 Pydantic 本身进行了一些更改以支持这一点。前面的截图使用 Visual Studio Code 拍摄。但你在 PyCharm 和大多数其他 Python 编辑器中也会获得相同的编辑器支持:**提示**: 如果你使用 PyCharm 作为编辑器, 你可以使用 Pydantic PyCharm 插件。它改善了对 Pydantic 模型的编辑器支持, 包括:- 自动补全- 类型检查- 重构- 搜索- 检查## 8. 使用模型在函数内部, 你可以直接访问模型对象的所有属性:```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: str | None = None    price: float    tax: float | None = Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):    item_dict = item.model_dump()  # 将模型转换为字典    if item.tax is not None:  # 检查可选字段        price_with_tax = item.price + item.tax        item_dict.update({"price_with_tax": price_with_tax})    return item_dict``````python# Python 3.9+from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = Noneapp = FastAPI()@app.post("/items/")async def create_item(item: Item):    item_dict = item.model_dump()    if item.tax is not None:        price_with_tax = item.price + item.tax        item_dict.update({"price_with_tax": price_with_tax})    return item_dict```**信息**: 在 Pydantic v1 中方法名为 `.model_dump()`, 在 Pydantic v2 中已弃用(但仍支持), 并重命名为 `.model_dump()`。这里的示例使用 `.model_dump()` 以兼容 Pydantic v1, 但如果你可以使用 Pydantic v2, 应改用 `.model_dump()`。## 9. 请求体 + 路径参数你可以同时声明路径参数和请求体。FastAPI 将认识到与路径参数匹配的函数参数应该从路径中获取, 而声明为 Pydantic 模型的函数参数应该从请求体中获取。```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: str | None = None    price: float    tax: float | None = Noneapp = FastAPI()@app.put("/items/{item_id}")  # PUT 方法用于更新async def update_item(    item_id: int,  # 路径参数    item: Item     # 请求体):    return {"item_id": item_id, **item.model_dump()}``````python# Python 3.9+from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = Noneapp = FastAPI()@app.put("/items/{item_id}")async def update_item(item_id: int, item: Item):    return {"item_id": item_id, **item.model_dump()}```## 10. 请求体 + 路径 + 查询参数你也可以同时声明请求体、路径和查询参数。FastAPI 将识别每一个并从正确的位置获取数据。```python# Python 3.10+from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: str | None = None    price: float    tax: float | None = Noneapp = FastAPI()@app.put("/items/{item_id}")async def update_item(    item_id: int,        # 路径参数    item: Item,          # 请求体    q: str | None = None # 查询参数):    result = {"item_id": item_id, **item.model_dump()}    if q:  # 如果查询参数存在        result.update({"q": q})    return result``````python# Python 3.9+from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel):    name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = Noneapp = FastAPI()@app.put("/items/{item_id}")async def update_item(    item_id: int,    item: Item,    q: Union[str, None] = None):    result = {"item_id": item_id, **item.model_dump()}    if q:        result.update({"q": q})    return result```函数参数将被识别如下:- 如果参数也在路径中声明, 它将被用作路径参数- 如果参数是单一类型(如 int、float、str、bool 等), 它将被解释为查询参数- 如果参数被声明为 Pydantic 模型的类型, 它将被解释为请求体**注意**: FastAPI 将知道 `q` 的值不是必需的, 因为有默认值 `= None`。`str | None`(Python 3.10+) 或 `Union[str, None]`(Python 3.9+) 不被 FastAPI 用来确定值不是必需的, 它知道它不是必需的是因为它有默认值 `= None`。但添加类型注解将使你的编辑器给你更好的支持并检测错误。## 11. 不使用 Pydantic如果你不想使用 Pydantic 模型, 你也可以使用 Body 参数。参见文档"请求体 - 多个参数: 请求体中的单一值"。## 总结请求体处理的关键点:1. **使用 Pydantic 模型**定义请求体结构2. **自动类型转换和验证**确保数据正确性3. **编辑器支持**提供完整的类型提示和自动补全4. **自动文档生成**包含请求体的 JSON Schema5. **灵活组合**可以与路径参数、查询参数混合使用这些特性使得 FastAPI 能够构建类型安全、易于使用的 API。