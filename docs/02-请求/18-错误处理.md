# 处理错误

当客户端向您的 API 发送格式错误的请求时,您需要一种方式来通知他们发生了什么错误.

同样,您的代码中也可能出现错误,您需要一种方式来记录这些错误并返回错误响应.

## 使用 `HTTPException`

要返回带有错误的 HTTP 响应,您可以使用 `HTTPException`.

### 导入 `HTTPException`

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items[item_id]}
```

### 触发 `HTTPException`

当您触发(`raise`)一个 `HTTPException` 时,**FastAPI** 将返回一个 JSON 响应,其中包含以下内容:

- `status_code`:HTTP 状态码.
- `detail`:错误详细信息字符串.
- `headers`:响应头(可选).

在上面的示例中,如果客户端请求 `http://example.com/items/bar`(`item_id` 为 "bar"),他们将收到一个 404 错误:

```json
{
  "detail": "Item not found"
}
```

### 添加自定义头

您还可以向 `HTTPException` 添加自定义头:

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}

@app.get("/items-header/{item_id}")
async def read_item_header(item_id: str):
    if item_id not in items:
        raise HTTPException(
            status_code=404,
            detail="Item not found",
            headers={"X-Error": "There goes my error"},
        )
    return {"item": items[item_id]}
```

如果客户端请求 `http://example.com/items-header/bar`,他们将收到一个 404 错误,其中包含响应头 `X-Error`:

```http
HTTP/1.1 404 Not Found
content-type: application/json
x-error: There goes my error

{
  "detail": "Item not found"
}
```

## 自定义异常处理器

您可以添加自定义异常处理器来处理特定异常并返回自定义响应.

### 安装异常处理器

使用 `@app.exception_handler()` 装饰器安装异常处理器:

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={"detail": exc.errors(), "body": exc.body},
    )

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}
```

### 覆盖默认异常处理器

**FastAPI** 有一些默认的异常处理器.

您可以覆盖这些异常处理器来自定义错误响应.

#### 覆盖请求验证异常

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={"message": "Uh oh, something went wrong!"},
    )

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}
```

现在,如果您请求 `/items/foo`(其中 `foo` 不是整数),您将收到自定义错误响应:

```json
{
  "message": "Uh oh, something went wrong!"
}
```

#### 覆盖 HTTPException 处理器

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import HTTPException

app = FastAPI()

class UnicornException(Exception):
    def __init__(self, name: str):
        self.name = name

@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    return JSONResponse(
        status_code=418,
        content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
    )

@app.get("/unicorns/{name}")
async def read_unicorn(name: str):
    if name == "yolo":
        raise UnicornException(name=name)
    return {"unicorn_name": name}
```

现在,如果您请求 `/unicorns/yolo`,您将收到自定义错误响应:

```json
{
  "message": "Oops! yolo did something. There goes a rainbow..."
}
```

## 重用 FastAPI 异常处理器

您可以导入并重用 **FastAPI** 的默认异常处理器.

```python
from fastapi import FastAPI, HTTPException
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()

@app.exception_handler(StarletteHTTPException)
async def custom_http_exception_handler(request: Request, exc: StarletteHTTPException):
    """
    这是一个显示如何重用 FastAPI 的异常处理器的示例.
    """
    return await http_exception_handler(request, exc)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    这是一个显示如何重用 FastAPI 的异常处理器的示例.
    """
    return await request_validation_exception_handler(request, exc)

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}
```

## 请求验证异常

当请求数据验证失败时,**FastAPI** 会引发 `RequestValidationError`.

默认情况下,**FastAPI** 使用 `JSONResponse` 返回错误,其中包含验证错误详情.

### 自定义请求验证异常

您可以自定义 `RequestValidationError` 的响应格式:

```python
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={
            "error": "Validation Error",
            "details": exc.errors(),
        },
    )

@app.post("/items/")
async def create_item(item: dict):
    return {"item": item}
```

现在,如果您发送无效数据,您将收到自定义错误响应.

## 使用 `try-except` 块

您也可以使用常规的 `try-except` 块来处理代码中的错误:

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    try:
        # 这里可能会引发错误
        result = 1 / 0
    except ZeroDivisionError:
        raise HTTPException(status_code=400, detail="Division by zero")
    return {"result": result}
```

## 记录错误

您可以使用 Python 的标准 `logging` 模块记录错误:

```python
import logging
from fastapi import FastAPI, HTTPException

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    try:
        # 这里可能会引发错误
        result = 1 / 0
    except Exception as e:
        logger.error(f"Error processing request: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
    return {"result": result}
```

## 总结

您可以使用以下方法处理 **FastAPI** 中的错误:

- 使用 `HTTPException` 返回 HTTP 错误响应.
- 使用 `@app.exception_handler()` 装饰器创建自定义异常处理器.
- 覆盖默认异常处理器来自定义错误响应.
- 使用常规的 `try-except` 块处理代码错误.
- 使用 `logging` 模块记录错误.