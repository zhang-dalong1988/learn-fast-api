# 表单数据

当你需要接收表单字段而不是 JSON 时，可以使用 `Form`。

## 导入 `Form`

首先，从 `fastapi` 导入 `Form`：

```python
from typing import Annotated

from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}
```

### Python 3.8+

```python
from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login/")
async def login(username: str = Form(), password: str = Form()):
    return {"username": username}
```

## 使用表单数据

`Form` 与 `Body`、`Query`、`Path`、`Cookie` 类似，它们都是特殊的类。

当你声明表单参数时，FastAPI 会从请求体中获取数据，而不是从 JSON。

## 表单数据 vs JSON

表单数据通常来自 HTML 表单，发送的数据格式通常是：

```
Content-Type: application/x-www-form-urlencoded
```

而不是：

```
Content-Type: application/json
```

## 表单字段

你可以像定义路径参数或查询参数一样定义表单字段：

```python
from typing import Annotated

from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login/")
async def login(
    username: Annotated[str, Form()],
    password: Annotated[str, Form()],
    remember_me: Annotated[bool, Form()] = False,
):
    return {
        "username": username,
        "password": password,
        "remember_me": remember_me,
    }
```

### Python 3.8+

```python
from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login/")
async def login(
    username: str = Form(),
    password: str = Form(),
    remember_me: bool = Form(False),
):
    return {
        "username": username,
        "password": password,
        "remember_me": remember_me,
    }
```

## 表单验证

你也可以添加验证：

```python
from typing import Annotated

from fastapi import FastAPI, Form, HTTPException
from pydantic import EmailStr

app = FastAPI()

@app.post("/login/")
async def login(
    username: Annotated[str, Form(min_length=3, max_length=20)],
    email: Annotated[EmailStr, Form()],
    password: Annotated[str, Form(min_length=8)],
):
    return {
        "username": username,
        "email": email,
        "password": password,
    }
```

### Python 3.8+

```python
from fastapi import FastAPI, Form, HTTPException
from pydantic import EmailStr

app = FastAPI()

@app.post("/login/")
async def login(
    username: str = Form(..., min_length=3, max_length=20),
    email: EmailStr = Form(...),
    password: str = Form(..., min_length=8),
):
    return {
        "username": username,
        "email": email,
        "password": password,
    }
```

## 处理文件和表单

如果你需要同时接收文件和表单字段，可以使用 `File` 和 `Form`：

```python
from typing import Annotated

from fastapi import FastAPI, File, Form, UploadFile

app = FastAPI()

@app.post("/files/")
async def create_file(
    file: Annotated[UploadFile, File()],
    fileb: Annotated[UploadFile, File()],
    token: Annotated[str, Form()],
):
    return {
        "file_size": file.size,
        "token": token,
        "fileb_content_type": fileb.content_type,
    }
```

### Python 3.8+

```python
from fastapi import FastAPI, File, Form, UploadFile

app = FastAPI()

@app.post("/files/")
async def create_file(
    file: UploadFile = File(...),
    fileb: UploadFile = File(...),
    token: str = Form(...),
):
    return {
        "file_size": file.size,
        "token": token,
        "fileb_content_type": fileb.content_type,
    }
```

## 警告

在一个路径操作中可以声明多个 `Form` 参数，但不能声明期望接收 JSON 的 `Body` 字段，因为此时请求将使用 `application/x-www-form-urlencoded` 而不是 `application/json`。

## 测试表单

你可以使用 HTML 表单测试：

```html
<form action="/login/" method="post">
    <label for="username">Username:</label>
    <input type="text" id="username" name="username" required>
    
    <label for="password">Password:</label>
    <input type="password" id="password" name="password" required>
    
    <label for="remember_me">
        <input type="checkbox" id="remember_me" name="remember_me" value="true">
        Remember me
    </label>
    
    <button type="submit">Login</button>
</form>
```

或者使用 `httpie`：

```bash
http --form POST http://127.0.0.1:8000/login/ username=john password=secret
```

## 总结

- 使用 `Form` 来声明表单字段参数
- 表单数据使用 `application/x-www-form-urlencoded` 内容类型
- 可以添加验证规则
- 不能在同一路径操作中混合使用 `Form` 和 `Body` JSON
- 可以与 `File` 一起使用来处理文件上传
