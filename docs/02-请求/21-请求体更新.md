# 请求体 - 更新数据

您可以使用 Pydantic 模型来声明请求体，并使用它们来更新数据。

## 使用 `PUT` 更新数据

使用 HTTP PUT 方法来替换整个资源。

### 基本示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
}

@app.put("/items/{item_id}")
async def update_item(item_id: str, item: Item):
    items[item_id] = item.dict()
    return {"item_id": item_id, **item.dict()}
```

### 完整更新示例

```python
from typing import Dict, Any
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

items: Dict[str, Dict[str, Any]] = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
}

@app.put("/items/{item_id}")
async def update_item(item_id: str, item: Item):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    update_data = item.dict(exclude_unset=True)
    items[item_id].update(update_data)
    return items[item_id]
```

## 使用 `PATCH` 部分更新

使用 HTTP PATCH 方法来部分更新资源。

### 部分更新示例

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class ItemUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float | None = None

items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
}

@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item_update: ItemUpdate):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")

    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)

    update_data = item_update.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)

    items[item_id] = updated_item.dict()
    return updated_item
```

### 使用 `exclude_unset`

`exclude_unset=True` 参数告诉 Pydantic 只包含那些在请求中显式设置的字段。

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.patch("/items/{item_id}")
async def update_item(item_id: str, item: Item):
    update_data = item.dict(exclude_unset=True)
    # update_data 只包含客户端提供的字段
    return update_data
```

## 混合使用 `PUT` 和 `PATCH`

```python
from typing import Optional
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None

class ItemBase(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    tax: Optional[float] = None

items = {}

@app.post("/items/{item_id}")
async def create_item(item_id: str, item: Item):
    items[item_id] = item.dict()
    return items[item_id]

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return items[item_id]

@app.put("/items/{item_id}")
async def update_item(item_id: str, item: Item):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    items[item_id] = item.dict()
    return items[item_id]

@app.patch("/items/{item_id}")
async def patch_item(item_id: str, item: ItemBase):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    update_data = item.dict(exclude_unset=True)
    items[item_id].update(update_data)
    return items[item_id]
```

## 响应模型

为更新操作指定响应模型。

```python
from typing import List
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class ItemUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float | None = None

items: List[dict] = []

@app.post("/items/", response_model=Item)
async def create_item(item: Item):
    items.append(item.dict())
    return item

@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: int, item_update: ItemUpdate):
    if item_id >= len(items):
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail="Item not found")

    stored_item = items[item_id]
    update_data = item_update.dict(exclude_unset=True)

    for field, value in update_data.items():
        stored_item[field] = value

    return stored_item
```

## 嵌套模型的更新

```python
from typing import List, Dict, Any
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: List[str] = []
    image: Image | None = None

class ItemUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float | None = None
    tags: List[str] | None = None
    image: Image | None = None

items: Dict[str, Dict[str, Any]] = {
    "item1": {
        "name": "T-Shirt",
        "description": "A nice t-shirt",
        "price": 15.99,
        "tax": 1.5,
        "tags": ["clothing", "shirt"],
        "image": {"url": "http://example.com/tshirt.jpg", "name": "tshirt"},
    }
}

@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: ItemUpdate):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")

    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)

    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)

    items[item_id] = updated_item.dict()
    return updated_item
```

## 注意事项

### 1. 数据验证

Pydantic 会自动验证传入的数据。

```python
from pydantic import validator

class ItemUpdate(BaseModel):
    name: str | None = None
    price: float | None = None

    @validator('price')
    def price_must_be_positive(cls, v):
        if v is not None and v <= 0:
            raise ValueError('Price must be positive')
        return v
```

### 2. 默认值处理

使用 `exclude_unset=True` 可以确保不更新未提供的字段。

```python
# 客户端发送: {"price": 20.0}
update_data = item.dict(exclude_unset=True)
# 结果: {"price": 20.0}
# 其他字段保持不变
```

### 3. 删除字段

如果您支持删除字段，可以使用特殊的标记值。

```python
from typing import Any
from pydantic import BaseModel

class ItemUpdate(BaseModel):
    name: str | None = None
    description: Any = None  # 可以接收特殊标记来删除字段

@app.patch("/items/{item_id}")
async def update_item(item_id: str, item_update: ItemUpdate):
    stored_item = items[item_id]
    update_data = item_update.dict(exclude_unset=True)

    for field, value in update_data.items():
        if value is None and field in ["description"]:
            # 删除字段
            stored_item.pop(field, None)
        else:
            # 更新字段
            stored_item[field] = value

    return stored_item
```

## 总结

- 使用 `PUT` 进行完整的资源替换
- 使用 `PATCH` 进行部分更新
- `exclude_unset=True` 只更新提供的字段
- 响应模型确保返回正确的数据格式
- 嵌套模型也可以进行更新
- 始终验证输入数据