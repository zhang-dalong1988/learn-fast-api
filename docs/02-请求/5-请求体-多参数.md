# 请求体多参数 - FastAPI 教程

## 1. 混合路径、查询和请求体参数

首先, 当然, 你可以自由地混合路径、查询和请求体参数声明, FastAPI 会知道该做什么.

你也可以通过设置默认为 None 来将请求体参数声明为可选的:

```python
# Python 3.10+
from typing import Annotated
from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],  # 路径参数
    q: str | None = None,  # 查询参数
    item: Item | None = None,  # 可选的请求体参数
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: Union[str, None] = None,
    item: Union[Item, None] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results
```

**提示**: 尽可能使用 `Annotated` 版本.

**注意**: 在这种情况下, 从请求体中获取的 item 是可选的, 因为它有 None 默认值.

## 2. 多个请求体参数

在前面的例子中, 路径操作将期望一个具有 Item 属性的 JSON 请求体, 如:

```json
{
  "name": "Foo",
  "description": "The pretender",
  "price": 42.0,
  "tax": 3.2
}
```

但你也可以声明多个请求体参数, 例如 item 和 user:

```python
# Python 3.10+
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class User(BaseModel):
    username: str
    full_name: str | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,  # 第一个请求体参数
    user: User   # 第二个请求体参数
):
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```

```python
# Python 3.9+
from typing import Union
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

class User(BaseModel):
    username: str
    full_name: Union[str, None] = None

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```

在这种情况下, FastAPI 会注意到函数中有多个请求体参数(有两个参数是 Pydantic 模型).

所以, 它将使用参数名称作为请求体中的键(字段名), 并期望这样的请求体:

```json
{
  "item": {
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
  },
  "user": {
    "username": "dave",
    "full_name": "Dave Grohl"
  }
}
```

**注意**: 请注意, 即使 item 的声明与之前相同, 它现在被期望在请求体内带有键 item.

FastAPI 将执行从请求的自动转换, 以便参数 item 接收其特定内容, user 也是如此.

它将执行复合数据的验证, 并将在 OpenAPI 模式和自动文档中进行相应的文档化.

## 3. 请求体中的单一值

与 Query 和 Path 定义查询和路径参数的额外数据的方式相同, FastAPI 提供了等效的 Body.

例如, 扩展前面的模型, 你可以决定在同一个请求体中, 除了 item 和 user 之外, 还要有另一个键 importance.

如果你按原样声明它, 因为它是一个单一值, FastAPI 会假定它是一个查询参数.但你可以指示 FastAPI 使用 Body 将其视为另一个请求体键:

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class User(BaseModel):
    username: str
    full_name: str | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    importance: Annotated[int, Body()]  # 单一值作为请求体的一部分
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

class User(BaseModel):
    username: str
    full_name: Union[str, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    importance: Annotated[int, Body()]
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

**提示**: 尽可能使用 `Annotated` 版本.

### 3.1 旧版本语法(不推荐)

```python
# Python 3.9+
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class User(BaseModel):
    username: str
    full_name: str | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    importance: int = Body()  # 旧方法: Body 作为默认值
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

在这种情况下, FastAPI 将期望这样的请求体:

```json
{
  "item": {
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
  },
  "user": {
    "username": "dave",
    "full_name": "Dave Grohl"
  },
  "importance": 5
}
```

同样, 它将转换数据类型, 进行验证, 文档化等.

## 4. 多个请求体参数和查询参数

当然, 你也可以在任何需要时声明额外的查询参数, 除了任何请求体参数.

由于默认情况下, 单一值被解释为查询参数, 你不需要显式添加 Query, 你可以这样做:

```python
# Python 3.10+
q: str | None = None

# Python 3.9+
from typing import Union
q: Union[str, None] = None
```

例如:

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

class User(BaseModel):
    username: str
    full_name: str | None = None

@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Item,
    user: User,
    importance: Annotated[int, Body(gt=0)],  # 带验证的请求体单一值
    q: str | None = None,  # 查询参数
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    if q:
        results.update({"q": q})
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

class User(BaseModel):
    username: str
    full_name: Union[str, None] = None

@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Item,
    user: User,
    importance: Annotated[int, Body(gt=0)],
    q: Union[str, None] = None,
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    if q:
        results.update({"q": q})
    return results
```

**信息**: Body 也具有与 Query、Path 和你稍后将看到的其他参数相同的额外验证和元数据参数.

## 5. 嵌入单个请求体参数

假设你只有一个来自 Pydantic 模型 Item 的单个请求体参数.默认情况下, FastAPI 将期望其请求体直接.

但是, 如果你希望它期望一个带有键 item 的 JSON, 并在其中包含模型内容, 就像声明额外请求体参数时那样, 你可以使用特殊的 Body 参数 embed:

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]  # 嵌入单个请求体参数
):
    results = {"item_id": item_id, "item": item}
    return results
```

```python
# Python 3.9+
from typing import Annotated, Union
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[Item, Body(embed=True)]
):
    results = {"item_id": item_id, "item": item}
    return results
```

**提示**: 尽可能使用 `Annotated` 版本.

### 5.1 旧版本语法(不推荐)

```python
# Python 3.9+
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item = Body(embed=True)  # 旧方法: Body 作为默认值
):
    results = {"item_id": item_id, "item": item}
    return results
```

在这种情况下, FastAPI 将期望这样的请求体:

```json
{
  "item": {
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
  }
}
```

而不是:

```json
{
  "name": "Foo",
  "description": "The pretender",
  "price": 42.0,
  "tax": 3.2
}
```

## 6. 总结

你可以向路径操作函数添加多个请求体参数, 即使一个请求只能有一个请求体.但 FastAPI 会处理它, 在函数中为你提供正确的数据, 并在路径操作中验证和记录正确的模式.

你还可以声明要作为请求体的一部分接收的单一值.

并且, 即使只声明了单个参数, 你也可以指示 FastAPI 将请求体嵌入到一个键中.

## 7. 完整示例

```python
# Python 3.10+
from typing import Annotated
from fastapi import Body, FastAPI, Path, Query
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    """商品模型"""
    name: str = Field(..., min_length=1, description="商品名称")
    description: str | None = Field(None, max_length=500, description="商品描述")
    price: float = Field(..., gt=0, description="商品价格")
    tax: float | None = Field(None, ge=0, description="税率")

    model_config = {
        "json_schema_extra": {
            "example": {
                "name": "智能手机",
                "description": "最新款智能手机",
                "price": 4999.99,
                "tax": 500.0
            }
        }
    }

class User(BaseModel):
    """用户模型"""
    username: str = Field(..., min_length=3, description="用户名")
    full_name: str | None = Field(None, description="全名")

    model_config = {
        "json_schema_extra": {
            "example": {
                "username": "john_doe",
                "full_name": "John Doe"
            }
        }
    }

class UpdateData(BaseModel):
    """更新数据模型"""
    timestamp: str = Field(..., description="更新时间戳")
    reason: str = Field(..., description="更新原因")
    priority: int = Field(default=1, ge=1, le=5, description="优先级 (1-5)")

@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(title="商品ID", ge=1, description="要更新的商品ID")],
    item: Annotated[Item, Body(description="要更新的商品信息")],
    user: Annotated[User, Body(description="执行更新的用户信息")],
    update_data: Annotated[UpdateData, Body(description="更新的额外数据")],
    q: Annotated[str | None, Query(min_length=3, description="查询字符串")] = None,
    force: Annotated[bool, Query(description="是否强制更新")] = False
):
    """
    更新商品信息

    这个端点展示了如何处理多个请求体参数:
    - 商品信息 (Item)
    - 用户信息 (User)
    - 更新数据 (UpdateData)
    - 路径参数 (item_id)
    - 查询参数 (q, force)

    所有请求体参数都会被验证并根据其模型进行处理.
    """
    result = {
        "item_id": item_id,
        "item": item.model_dump(),
        "user": user.model_dump(),
        "update_data": update_data.model_dump(),
        "updated_at": update_data.timestamp,
        "force_update": force
    }

    if q:
        result["query"] = q

    return result
```

这个完整的示例展示了如何在一个端点中处理:
- 路径参数 (item_id)
- 查询参数 (q, force)
- 多个请求体参数 (item, user, update_data)
- 完整的验证和文档