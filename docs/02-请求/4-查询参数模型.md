# 查询参数模型 - FastAPI 教程

## 1. 使用 Pydantic 模型声明查询参数

如果你有一组相关的查询参数, 你可以创建一个 Pydantic 模型来声明它们。这将允许你在多个地方重用该模型, 并且同时为所有参数声明验证和元数据。

**注意**: 此功能自 FastAPI 版本 0.115.0 开始支持。

## 2. 查询参数与 Pydantic 模型

在 Pydantic 模型中声明你需要的查询参数, 然后将参数声明为 Query:

```python
# Python 3.10+
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)  # 限制数量, 0 < limit <= 100
    offset: int = Field(0, ge=0)  # 偏移量, offset >= 0
    order_by: Literal["created_at", "updated_at"] = "created_at"  # 排序字段
    tags: list[str] = []  # 标签列表

@app.get("/items/")
async def read_items(
    filter_query: Annotated[FilterParams, Query()]  # 使用 Query 包装模型
):
    return filter_query
```

```python
# Python 3.9+
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(
    filter_query: Annotated[FilterParams, Query()]
):
    return filter_query
```

**提示**: 尽可能使用 `Annotated` 版本。

### 2.1 旧版本语法（不推荐）

```python
# Python 3.9+
from typing import Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(
    filter_query: FilterParams = Query()  # 旧方法: Query 作为默认值
):
    return filter_query
```

FastAPI 将从请求的查询参数中提取每个字段的数据, 并向你提供你定义的 Pydantic 模型。

## 3. 查看文档

你可以在 `/docs` 的文档 UI 中看到查询参数:

![查询参数模型在文档中的显示](https://fastapi.tiangolo.com/img/tutorial/query-param-models/image01.png)

## 4. 禁止额外的查询参数

在某些特殊用例中(可能不太常见), 你可能想要限制你想要接收的查询参数。你可以使用 Pydantic 的模型配置来禁止任何额外的字段:

```python
# Python 3.10+
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    model_config = {"extra": "forbid"}  # 禁止额外字段

    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(
    filter_query: Annotated[FilterParams, Query()]
):
    return filter_query
```

```python
# Python 3.9+
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    model_config = {"extra": "forbid"}

    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(
    filter_query: Annotated[FilterParams, Query()]
):
    return filter_query
```

如果客户端尝试在查询参数中发送一些额外的数据, 他们将收到错误响应。

例如, 如果客户端尝试发送值为 `plumbus` 的 `tool` 查询参数, 像这样:
```
https://example.com/items/?limit=10&tool=plumbus
```

他们将收到错误响应, 告诉他们不允许查询参数 `tool`:

```json
{
  "detail": [
    {
      "type": "extra_forbidden",
      "loc": ["query", "tool"],
      "msg": "Extra inputs are not permitted",
      "input": "plumbus"
    }
  ]
}
```

## 5. 模型字段详解

### 5.1 Field 参数

`Field` 函数用于为模型字段添加约束和元数据:

- `gt=0`: 大于 0 (greater than)
- `ge=0`: 大于等于 0 (greater than or equal)
- `le=100`: 小于等于 100 (less than or equal)
- `default=100`: 默认值

### 5.2 字段类型

- `int`: 整数类型
- `list[str]`: 字符串列表
- `Literal[...]`: 枚举值, 只能是列出的值之一

### 5.3 model_config

Pydantic 的模型配置选项:

- `{"extra": "forbid"}`: 禁止额外的字段
- `{"extra": "allow"}`: 允许额外的字段(默认)
- `{"extra": "ignore"}`: 忽略额外的字段

## 6. 优势

使用查询参数模型的优势:

1. **代码重用**: 可以在多个端点使用相同的参数模型
2. **组织性**: 相关的参数组织在一起
3. **验证集中**: 所有验证规则在一个地方定义
4. **类型安全**: 完整的类型提示和验证
5. **文档生成**: 自动生成结构化的 API 文档
6. **默认值管理**: 在模型中统一管理默认值

## 7. 使用场景

查询参数模型特别适用于:

1. **分页参数**: limit, offset, page 等
2. **过滤参数**: 多个过滤条件的组合
3. **排序参数**: order_by, sort_direction 等
4. **搜索参数**: keyword, filters 等
5. **配置参数**: 选项、标志等的组合

## 8. 总结

你可以在 FastAPI 中使用 Pydantic 模型来声明查询参数。

**提示**: 剧透一下: 你也可以使用 Pydantic 模型来声明 cookies 和 headers, 但你将在教程的后面部分读到相关内容。

## 9. 完整示例

```python
# Python 3.10+
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class SearchParams(BaseModel):
    """搜索参数模型"""
    keyword: str = Field(..., min_length=1, description="搜索关键词")
    category: Literal["all", "books", "electronics", "clothing"] = "all"
    min_price: float | None = Field(None, ge=0, description="最低价格")
    max_price: float | None = Field(None, ge=0, description="最高价格")
    in_stock: bool = True
    tags: list[str] = Field(default=[], description="标签列表")

    model_config = {
        "extra": "forbid",
        "json_schema_extra": {
            "example": {
                "keyword": "phone",
                "category": "electronics",
                "min_price": 100,
                "max_price": 1000,
                "in_stock": True,
                "tags": ["wireless", "5g"]
            }
        }
    }

@app.get("/search/")
async def search_items(
    params: Annotated[SearchParams, Query(description="搜索参数")]
):
    """
    搜索商品

    - **keyword**: 必需的搜索关键词
    - **category**: 商品类别
    - **min_price/max_price**: 价格范围
    - **in_stock**: 是否只显示有货商品
    - **tags**: 商品标签列表
    """
    return {
        "message": "搜索成功",
        "params": params.dict(),
        "filters": {
            "keyword": params.keyword,
            "category": params.category,
            "price_range": (params.min_price, params.max_price),
            "in_stock": params.in_stock,
            "tags": params.tags
        }
    }
```

这个完整的示例展示了如何创建一个复杂的查询参数模型, 包含多种字段类型、验证规则和文档。