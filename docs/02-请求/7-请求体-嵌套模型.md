# 请求体 - 嵌套模型

在 FastAPI 中，你可以定义、验证和使用任意深度嵌套的数据模型。这让你能够轻松处理复杂的 JSON 数据结构。

## 1. 简单的列表字段

首先，让我们看一个包含列表的简单模型：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str                # 商品名称（必需）
    description: str | None = None  # 商品描述（可选）
    price: float             # 商品价格（必需）
    tax: float | None = None        # 税率（可选）
    tags: list = []          # 标签列表，默认为空列表

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

**发送的请求示例：**

```json
{
  "name": "笔记本电脑",
  "description": "高性能办公笔记本",
  "price": 5999.99,
  "tax": 480.0,
  "tags": ["电子产品", "办公", "轻薄"]
}
```

## 2. 指定列表元素类型

上面的例子中，`tags` 可以包含任何类型的元素。让我们明确指定它只包含字符串：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []    # 明确指定为字符串列表
    # 如果使用 Python 3.8：tags: List[str] = []

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

### 类型提示说明

- **Python 3.9+**: 使用 `list[str]`
- **Python 3.8**: 使用 `List[str]`（需要从 `typing` 导入 `List`）

## 3. 使用集合 (Set) 自动去重

如果标签不应该重复，可以使用 `set` 类型：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()   # 使用集合，自动去除重复值
    # 如果使用 Python 3.8：tags: Set[str] = set()

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

**Set 的优势:**

- 自动去除重复值
- 即使客户端发送重复数据，也会自动处理
- 输出时保证每个标签都是唯一的

## 4. 嵌套模型

### 4.1 定义子模型

你可以定义一个模型作为另一个模型的属性：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

# 定义图像模型（子模型）
class Image(BaseModel):
    url: str      # 图像 URL
    name: str     # 图像名称

# 定义商品模型（主模型）
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None  # 嵌套 Image 模型

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

**发送的请求示例：**

```json
{
  "name": "智能手机",
  "description": "最新款旗舰手机",
  "price": 4999.0,
  "tax": 399.2,
  "tags": ["电子产品", "通讯"],
  "image": {
    "url": "https://example.com/phone.jpg",
    "name": "手机主图"
  }
}
```

### 4.2 嵌套列表模型

模型属性也可以是其他模型的列表：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] = []  # 图像列表

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, "item": item}
```

**发送的请求示例：**

```json
{
  "name": "商品相册",
  "description": "包含多张图片的商品",
  "price": 199.0,
  "images": [
    {
      "url": "https://example.com/pic1.jpg",
      "name": "正面图"
    },
    {
      "url": "https://example.com/pic2.jpg",
      "name": "侧面图"
    },
    {
      "url": "https://example.com/pic3.jpg",
      "name": "细节图"
    }
  ]
}
```

## 5. 使用特殊验证类型

Pydantic 提供了许多特殊类型，用于数据验证：

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl  # 导入 HttpUrl 类型

app = FastAPI()

class Image(BaseModel):
    url: HttpUrl    # 使用 HttpUrl 类型，会自动验证 URL 格式
    name: str

class Item(BaseModel):
    name: str
    images: list[Image] = []

@app.post("/items/")
async def create_item(item: Item):
    return item
```

**HttpUrl 的好处:**

- 自动验证 URL 格式
- 支持多种 URL scheme（http、https、ftp 等）
- 在 API 文档中显示正确的类型信息

## 6. 深度嵌套的复杂模型

你可以创建任意深度的嵌套模型：

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

# 最底层：图片模型
class Image(BaseModel):
    url: HttpUrl
    name: str

# 中间层：商品模型
class Product(BaseModel):
    name: str
    description: str | None = None
    price: float
    images: list[Image] = []

# 顶层：订单模型
class Order(BaseModel):
    order_id: str
    products: list[Product]  # 订单包含多个商品
    total_amount: float

@app.post("/orders/")
async def create_order(order: Order):
    return {"message": "订单创建成功", "order": order}
```

**复杂的请求示例:**

```json
{
  "order_id": "ORD-2024-001",
  "total_amount": 11997.0,
  "products": [
    {
      "name": "笔记本电脑",
      "price": 5999.0,
      "images": [
        {
          "url": "https://example.com/laptop1.jpg",
          "name": "正面图"
        },
        {
          "url": "https://example.com/laptop2.jpg",
          "name": "键盘图"
        }
      ]
    },
    {
      "name": "无线鼠标",
      "price": 199.0,
      "images": [
        {
          "url": "https://example.com/mouse.jpg",
          "name": "产品图"
        }
      ]
    }
  ]
}
```

## 7. 直接接收列表或字典

### 7.1 接收纯列表

如果请求体直接是一个列表，可以这样定义：

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float

@app.post("/items/batch/")
async def create_items(items: list[Item]):  # 直接接收 Item 列表
    return {"created": len(items), "items": items}
```

**请求示例:**

```json
[
  { "name": "商品1", "price": 100.0 },
  { "name": "商品2", "price": 200.0 },
  { "name": "商品3", "price": 300.0 }
]
```

### 7.2 接收字典

如果需要接收键值对，其中键和值的类型已知：

```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/prices/")
async def update_prices(prices: dict[str, float]):  # 键是商品名，值是价格
    return {"updated": len(prices), "prices": prices}
```

**请求示例:**

```json
{
  "苹果": 5.99,
  "香蕉": 3.99,
  "橙子": 4.99
}
```

## 8. 实用技巧

### 8.1 可选的嵌套字段

使用 `| None` 让嵌套模型变为可选：

```python
class User(BaseModel):
    name: str
    address: Address | None = None  # 地址信息是可选的
```

### 8.2 使用默认值

为复杂类型提供默认值：

```python
class Product(BaseModel):
    tags: list[str] = []      # 默认空列表
    metadata: dict[str, str] = {}  # 默认空字典
```

### 8.3 混合类型

模型中可以混合不同类型的字段：

```python
class Product(BaseModel):
    # 基本类型
    id: int
    name: str

    # 可选类型
    description: str | None = None

    # 列表类型
    tags: list[str] = []

    # 嵌套模型
    image: Image | None = None

    # 模型列表
    reviews: list[Review] = []

    # 字典类型
    attributes: dict[str, str] = {}
```

## 9. 编辑器支持的好处

使用 Pydantic 模型的一个巨大优势是获得完整的编辑器支持：

- **自动补全**：编辑器知道模型的所有字段
- **类型检查**：实时发现类型错误
- **重构支持**：重命名字段时自动更新所有引用
- **文档提示**：鼠标悬停查看字段信息

这种支持在处理深度嵌套的复杂模型时尤其有用。

## 10. 总结

FastAPI 结合 Pydantic 提供了强大而灵活的数据建模能力：

1. **类型安全**：自动类型检查和转换
2. **数据验证**：自动验证输入数据
3. **文档生成**：自动生成 API 文档
4. **编辑器支持**：完整的 IDE 支持
5. **灵活性**：支持任意深度的嵌套结构

这些功能让你能够轻松构建健壮且易于维护的 API。
