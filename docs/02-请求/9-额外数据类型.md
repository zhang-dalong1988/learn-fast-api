# 额外数据类型

到目前为止,你一直在使用常见的数据类型,比如:

- `int`
- `float`
- `str`
- `bool`

但你也可以使用更复杂的数据类型.

并且你仍然会拥有与之前相同的功能:

- 优秀的编辑器支持.
- 来自传入请求的数据转换.
- 响应数据的数据转换.
- 数据验证.
- 自动注释和文档.

## 其他数据类型

以下是一些你可以使用的额外数据类型:

- `UUID`:
  - 标准的"通用唯一标识符",在许多数据库和系统中常用作 ID.
  - 在请求和响应中将表示为 `str`.
- `datetime.datetime`:
  - Python `datetime.datetime`.
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`,如:`2008-09-15T15:53:00+05:00`.
- `datetime.date`:
  - Python `datetime.date`.
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`,如:`2008-09-15`.
- `datetime.time`:
  - Python `datetime.time`.
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`,如:`14:23:55.003`.
- `datetime.timedelta`:
  - Python `datetime.timedelta`.
  - 在请求和响应中将表示为总秒数的 `float`.
  - Pydantic 还允许将其表示为"ISO 8601 时间差编码",详情请参阅文档.
- `frozenset`:
  - 在请求和响应中,与 `set` 处理方式相同:
    - 在请求中,将读取列表,消除重复项并将其转换为 `set`.
    - 在响应中,`set` 将转换为 `list`.
    - 生成的模式将指定 `set` 值是唯一的(使用 JSON Schema 的 `uniqueItems`).
- `bytes`:
  - 标准 Python `bytes`.
  - 在请求和响应中将视为 `str`.
  - 生成的模式将指定它是具有 `binary`"格式"的 `str`.
- `Decimal`:
  - 标准 Python `Decimal`.
  - 在请求和响应中,与 `float` 处理方式相同.
- 你可以在这里查看所有有效的 Pydantic 数据类型:Pydantic data types.

## 示例

这是一个使用上述某些类型的参数的路径操作示例.

### Python 3.10+

```python
from datetime import datetime, time, timedelta
from typing import Annotated
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[time | None, Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

#### 其他版本和变体

**Python 3.9+**

```python
from datetime import datetime, time, timedelta
from typing import Annotated, Union
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

**Python 3.8+**

```python
from datetime import datetime, time, timedelta
from typing import Union
from uuid import UUID

from fastapi import Body, FastAPI
from typing_extensions import Annotated

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

**提示**

如果可能,首选使用 `Annotated` 版本.

**Python 3.10+ - non-Annotated**

```python
from datetime import datetime, time, timedelta
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: datetime = Body(),
    end_datetime: datetime = Body(),
    process_after: timedelta = Body(),
    repeat_at: time | None = Body(default=None),
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

**提示**

如果可能,首选使用 `Annotated` 版本.

**Python 3.8+ - non-Annotated**

```python
from datetime import datetime, time, timedelta
from typing import Union
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: datetime = Body(),
    end_datetime: datetime = Body(),
    process_after: timedelta = Body(),
    repeat_at: Union[time, None] = Body(default=None),
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

注意,函数内部的参数具有它们自然的数据类型,你可以,例如,执行正常的日期操作,比如:

### Python 3.10+

```python
from datetime import datetime, time, timedelta
from typing import Annotated
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()

@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[time | None, Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```
