# 9. 额外数据类型

到目前为止，你主要使用的是一些基础的数据类型，比如：

- `int` - 整数
- `float` - 浮点数
- `str` - 字符串
- `bool` - 布尔值

但在实际项目中，你经常需要处理更复杂的数据类型。好消息是，FastAPI 完全支持这些复杂类型，并且提供同样的强大功能：

- **优秀的编辑器支持** - 自动补全和类型检查
- **自动数据转换** - 请求和响应数据的自动转换
- **数据验证** - 自动验证数据格式和合法性
- **自动文档生成** - 在 API 文档中显示正确的类型信息

## 9.1 支持的额外数据类型

以下是 FastAPI/Pydantic 支持的一些常用额外数据类型：

### 9.1.1 UUID - 通用唯一标识符

```python
from uuid import UUID

# UUID 是一个 128 位的唯一标识符
# 常用于数据库主键、订单号、会话 ID 等
# 在 JSON 中表示为字符串格式，如： "550e8400-e29b-41d4-a716-446655440000"
```

### 9.1.2 日期时间类型

**datetime.datetime** - 日期和时间

```python
from datetime import datetime

# 包含日期和时间的完整时间戳
# JSON 格式：ISO 8601，如："2024-01-15T15:30:00+08:00"
# 包含时区信息
```

**datetime.date** - 仅日期

```python
from datetime import date

# 只有日期，没有时间
# JSON 格式：ISO 8601，如："2024-01-15"
```

**datetime.time** - 仅时间

```python
from datetime import time

# 只有时分秒，没有日期
# JSON 格式：ISO 8601，如："15:30:00.123"
```

**datetime.timedelta** - 时间差

```python
from datetime import timedelta

# 表示两个时间点之间的差值
# JSON 格式：总秒数的浮点数，如：3600.0（表示1小时）
# 也可以是 ISO 8601 时间差格式
```

### 9.1.3 其他有用类型

**frozenset** - 不可变集合

```python
# 与 set 类似，但创建后不能修改
# 在请求中接收列表，自动去重并转换为 frozenset
# 在响应中转换为列表
# JSON Schema 会标记为 uniqueItems: true
```

**bytes** - 字节类型

```python
# 二进制数据
# 在 JSON 中表示为 Base64 编码的字符串
# Schema 标记为格式 "binary"
```

**Decimal** - 高精度小数

```python
from decimal import Decimal

# 适用于需要精确计算的场景（如金融）
# 避免浮点数的精度问题
# 在 JSON 中与 float 类似处理
```

> **提示**：查看所有支持的 Pydantic 数据类型，请访问官方文档：[Pydantic Data Types](https://pydantic-docs.helpmanual.io/usage/types/)

## 9.2 完整示例

下面是一个综合使用多种数据类型的示例，展示一个任务调度系统的 API：

### 9.2.1 使用 Annotated（推荐方式）

```python
from datetime import datetime, time, timedelta
from typing import Annotated
from uuid import UUID

from fastapi import Body, FastAPI

# 创建 FastAPI 应用
app = FastAPI()

@app.put("/tasks/{task_id}")
async def update_task(
    # 路径参数：任务的唯一标识符（UUID格式）
    task_id: UUID,

    # 请求体参数1：任务开始时间（必须）
    start_datetime: Annotated[datetime, Body(
        description="任务开始执行的日期时间",
        examples=["2024-01-15T09:00:00+08:00"]
    )],

    # 请求体参数2：任务结束时间（必须）
    end_datetime: Annotated[datetime, Body(
        description="任务计划结束的日期时间",
        examples=["2024-01-15T17:00:00+08:00"]
    )],

    # 请求体参数3：延迟执行时间（必须）
    process_after: Annotated[timedelta, Body(
        description="任务延迟执行的时间间隔",
        examples=[3600]  # 表示1小时后执行
    )],

    # 请求体参数4：重复执行时间（可选）
    repeat_at: Annotated[time | None, Body(
        description="每日重复执行的具体时间",
        examples=["09:00:00", "14:30:00"]
    )] = None,  # 默认为 None，表示不重复
):
    """
    更新任务调度信息

    这个 API 展示了如何使用多种复杂数据类型：
    - UUID 用于唯一标识任务
    - datetime 用于时间安排
    - timedelta 用于延迟设置
    - time 用于每日重复时间
    """

    # 计算实际开始执行时间 = 计划开始时间 + 延迟时间
    start_process = start_datetime + process_after

    # 计算任务持续时间 = 结束时间 - 实际开始时间
    duration = end_datetime - start_process

    # 返回任务的所有相关信息
    return {
        "task_id": task_id,          # 任务ID
        "planned_start": start_datetime,  # 计划开始时间
        "actual_start": start_process,     # 实际开始时间
        "end_time": end_datetime,          # 结束时间
        "delay": process_after,           # 延迟时间
        "repeat_at": repeat_at,           # 重复时间
        "duration": duration,             # 任务持续时间
        "duration_hours": duration.total_seconds() / 3600,  # 转换为小时
    }
```

### 9.2.2 Python 版本兼容性说明

为了方便不同 Python 版本的使用者，这里提供了几种写法：

**Python 3.9+（推荐）**

```python
from datetime import datetime, time, timedelta
from typing import Annotated, Union
from uuid import UUID

# 使用 Union 代替 | 符号（Python 3.9 支持 Annotated 但不支持 |）
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    pass
```

**Python 3.8+**

```python
from datetime import datetime, time, timedelta
from typing import Union
from uuid import UUID
from typing_extensions import Annotated  # 需要安装 typing_extensions

# Python 3.8 完全兼容的写法
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    pass
```

### 9.2.3 数据类型的自动转换

FastAPI 会自动处理以下转换：

```python
# 请求示例（JSON格式）
{
    "start_datetime": "2024-01-15T09:00:00+08:00",  # 字符串 → datetime对象
    "end_datetime": "2024-01-15T17:00:00+08:00",    # 字符串 → datetime对象
    "process_after": 3600.0,                         # 数字 → timedelta对象
    "repeat_at": "14:30:00"                          # 字符串 → time对象
}
```

在函数内部，你可以直接使用这些对象的原始功能：

```python
# 时间运算（Python 原生 datetime 操作）
start_process = start_datetime + process_after  # datetime + timedelta
duration = end_datetime - start_process        # datetime - datetime = timedelta

# 时间格式化
formatted_time = start_datetime.strftime("%Y-%m-%d %H:%M:%S")

# 时间比较
if end_datetime > datetime.now():
    print("任务还未结束")
```

## 9.3 实际应用场景

### 9.3.1 订单管理系统

```python
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Annotated
from uuid import UUID

class OrderCreate(BaseModel):
    order_id: UUID
    user_id: UUID
    items: list[str]  # 商品列表
    total_amount: Decimal  # 使用Decimal处理金额

    # 下单时间（自动生成）
    created_at: datetime = datetime.now()

    # 支付截止时间（必须）
    payment_due: datetime

    # 预计配送时间（可选）
    estimated_delivery: datetime | None = None

    # 订单备注（可选）
    notes: str | None = None

@app.post("/orders")
async def create_order(order: OrderCreate):
    # 计算剩余支付时间
    remaining = order.payment_due - datetime.now()

    # 检查是否已过期
    if remaining.total_seconds() <= 0:
        return {"error": "订单已过期"}

    # 处理订单逻辑...
    return {
        "order_id": order.order_id,
        "amount": float(order.total_amount),  # 转换为float返回
        "payment_due_in": remaining.total_seconds() / 3600,  # 剩余小时数
    }
```

### 9.3.2 会议预约系统

```python
from datetime import datetime, time, date
from typing import Annotated

class MeetingRequest(BaseModel):
    meeting_id: UUID
    organizer: str
    participants: list[str]  # 参与者列表

    # 会议日期
    meeting_date: date

    # 开始和结束时间
    start_time: time
    end_time: time

    # 时区（字符串）
    timezone: str = "Asia/Shanghai"

    # 会议时长（自动计算）
    @property
    def duration(self) -> timedelta:
        # 将time转换为datetime计算时长
        start_dt = datetime.combine(self.meeting_date, self.start_time)
        end_dt = datetime.combine(self.meeting_date, self.end_time)
        return end_dt - start_dt

@app.post("/meetings")
async def schedule_meeting(meeting: MeetingRequest):
    # 验证会议时长不超过4小时
    if meeting.duration > timedelta(hours=4):
        return {"error": "会议时长不能超过4小时"}

    # 检查时间冲突...

    return {
        "meeting_id": meeting.meeting_id,
        "scheduled_at": f"{meeting.meeting_date} {meeting.start_time}",
        "duration_minutes": meeting.duration.total_seconds() / 60,
    }
```

## 9.4 最佳实践

### 9.4.1 选择合适的时间类型

- **datetime**：需要精确到具体时刻（如订单时间、登录时间）
- **date**：只需要日期（如生日、纪念日）
- **time**：只需要时间（如每日闹钟、营业时间）
- **timedelta**：表示时间间隔或持续时间

### 9.4.2 处理时区

```python
from datetime import datetime, timezone
import pytz  # 需要安装 pytz 包

# 获取带时区的当前时间
now_utc = datetime.now(timezone.utc)
now_shanghai = datetime.now(pytz.timezone('Asia/Shanghai'))

# 在模型中建议始终使用带时区的 datetime
class Event(BaseModel):
    event_time: datetime  # 会自动处理时区
```

### 9.4.3 数据验证技巧

```python
from pydantic import BaseModel, validator, Field

class Booking(BaseModel):
    check_in: datetime
    check_out: datetime

    @validator('check_out')
    def validate_dates(cls, v, values):
        if 'check_in' in values and v <= values['check_in']:
            raise ValueError('退房时间必须晚于入住时间')
        return v

    # 添加示例
    check_in: datetime = Field(
        examples=["2024-01-15T14:00:00+08:00"]
    )
```

## 9.5 总结

FastAPI 的额外数据类型支持让你能够：

1. **处理真实世界的业务数据**：UUID、时间戳、金额等
2. **保持类型安全**：自动类型检查和转换
3. **简化开发**：无需手动解析和验证数据
4. **生成准确的文档**：API 文档自动显示正确的类型

记住，选择正确的数据类型不仅能让你的代码更清晰，还能避免很多潜在的错误！
