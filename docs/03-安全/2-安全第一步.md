# 安全第一步

在本节中,你将学习如何以最简单的方式处理安全,使用已经为你处理好的工具.

让我们从一个简单的示例开始,该示例:

- 使用 `username` 和 `password`.
- 在令牌(JWT)中返回一个令牌.
- 令牌具有特定的过期时间.
- 使用 JWT 令牌验证请求.

如果你对令牌、JWT、OAuth2 等概念已经很了解,可以直接跳转到更高级的部分.

## 获取 `password` 流

OAuth2 开发了几个"流"来处理安全和认证.其中之一叫做"password flow".

让我们在这个非常简单的示例中使用它.

> 注意
>
> 这是一个简单的演示,而不是一个完整的生产就绪的系统.
>
> 关于完整的系统,请阅读后面的章节.
>
> 简单性是这里的重点,以便你可以专注于将要使用的 FastAPI 特定工具.

## 安装依赖

首先,确保你安装了 `python-multipart`.

这是因为在 OAuth2 使用密码流时,需要通过表单数据(而不是 JSON)发送 `username` 和 `password`.

```bash
pip install python-multipart
```

### 更多安全依赖

我们将在这些示例中使用 `passlib` 来处理密码哈希,并使用 `python-jose` 来处理 JWT 令牌.

```bash
pip install "passlib[bcrypt]" python-jose[cryptography]
```

## 完整示例

这是一个完整的工作示例,包括:

- 带有用户名 `johndoe` 和密码 `secret` 的用户
- 哈希密码以存储/验证
- 一个 JWT 令牌生成,在 `/token` 路径中
- 一个受保护的路径 `/users/me`,需要 JWT 令牌

```python
from datetime import datetime, timedelta
from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = get_user(fake_users_db, username=username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@app.get("/users/me", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)]
):
    return current_user
```

## 数据模型

让我们定义一些 Pydantic 模型:

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str
```

## 处理密码

让我们来处理密码哈希:

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)
```

## 处理 JWT 令牌

让我们导入所需的模块并创建 JWT 令牌编码和解码的机制:

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

## OAuth2 密码流

让我们添加 OAuth2 密码流:

```python
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
```

## 依赖项

让我们定义获取当前用户的依赖项:

```python
from typing import Annotated
from fastapi import Depends, HTTPException, status

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = get_user(fake_users_db, username=username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
```

## 路径操作

让我们创建路径操作:

```python
@app.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)]
):
    return current_user
```

## 它是如何工作的

- 用户在前端输入用户名和密码,然后点击"Enter".
- 前端(运行在用户浏览器中)将 `username` 和 `password` 发送到 URL `/token`.
- FastAPI 应用验证 `username` 和 `password`,然后返回一个"令牌".
    - "令牌"只是一个包含一些数据的字符串,我们无法读取它.
    - 令牌将在一段时间后过期.因此,用户不必每次都再次登录.
- 前端存储该令牌(通常在浏览器中的某个临时存储中).
- 当用户访问应用的其他部分时,前端需要认证.
- 为了实现认证,它发送一个 `Authorization` 头部,值为 `Bearer` 加上令牌.
    - 例如:`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJqb2huZG9lIiwiZXhwIjoxNjE2MjM5MDIyfQ.FlxG1Z...`
- 当路径操作接收到请求时,它会从 `Authorization` 头部中提取令牌.
- 它使用 `Depends` 运行依赖项 `get_current_user`.
- 依赖项 `get_current_user` 解码令牌,验证它,并返回当前用户.
- 如果令牌无效,或者令牌中没有用户,或者用户已禁用,它会返回一个错误.
- 如果用户有效,路径操作处理程序接收 `current_user` 作为参数.

## 使用交互式文档测试

你可以在交互式文档(`/docs`)中测试这个工作流程:

1. 打开浏览器,访问 `http://127.0.0.1:8000/docs`.
2. 点击路径操作 `/token`.
3. 点击"Try it out"按钮.
4. 用户名使用 `johndoe`,密码使用 `secret`.
5. 执行它,你会得到一个像这样的令牌:
    ```json
    {
      "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJqb2huZG9lIiwiZXhwIjoxNjE2MjM5MDIyfQ.FlxG1...",
      "token_type": "bearer"
    }
    ```
6. 复制访问令牌的值(不包括 `"access_token":` 部分,只复制长的令牌字符串).
7. 返回到顶部文档.
8. 点击"Authorize"按钮.
9. 在出现的对话框中,粘贴令牌(前面加 `Bearer `,中间有空格).
    - 值应该看起来像:`Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`.
10. 点击"Authorize".
11. 现在你已经登录了.
12. 访问路径操作 `/users/me`.
13. 点击"Try it out"并执行它.
14. 你会得到用户数据:
    ```json
    {
      "username": "johndoe",
      "email": "johndoe@example.com",
      "full_name": "John Doe",
      "disabled": false
    }
    ```

## 技术细节

### `oauth2_scheme`

当你创建 `OAuth2PasswordBearer` 的实例时:

```python
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
```

你正在告诉 FastAPI:

- 这是一个 "OAuth2" 流程
- 令牌通过 HTTP Bearer 令牌发送
- 获取令牌的 URL 是 `/token`(下一章我们将看到如何实际实现)

这不会创建端点/路径操作 `/token`,它只是声明客户端(前端)应该用来获取令牌的 URL.

`OAuth2PasswordBearer` 也是一个"依赖项".

因此,你可以在 `Depends` 中使用它:

```python
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # ...
```

当你需要认证时,FastAPI 会自动在请求中查找 `Authorization` 头部,检查它的值是否为 `Bearer <some-token>`,并将 `<some-token>` 作为参数 `token` 提供给你的函数.

### 令牌内容

我们实际上在令牌中放入的内容是 `{"sub": "johndoe"}`.

`sub` 是一个标准声明,用于令牌主题(我们试图标识的用户).

我们使用 `sub` 是因为它在 JWT 中是标准化的,但如果你愿意,你也可以使用其他键名.

### 为什么我们使用 `OAuth2PasswordBearer`?

使用 `OAuth2PasswordBearer` 意味着我们可以轻松地将我们的系统与第三方提供者(如 Google、Facebook、Twitter 等)集成,因为它们都使用 OAuth2.

### 密码流

OAuth2 开发了几种处理身份验证的方法,称为"流".

"Password flow"是其中之一.

它的工作方式是用户将他们的用户名和密码发送到一个特定的端点(我们称之为 `/token`),应用程序返回一个访问令牌.

这个访问令牌随后可以用于访问受保护的资源.

"Password flow"适用于当:
- 你完全信任应用程序(客户端).
- 你正在构建自己的前端应用.
- 你存储并管理用户凭据(用户名和密码).

对于第三方应用程序,你应该使用其他流程,如"implicit flow"或"authorization code flow".

### 速度和安全性

这些工具(`passlib`、`python-jose` 等)都经过优化并针对安全性进行了设计.

使用它们比你自己实现所有逻辑要好得多.

它们已经过安全专家的审查和测试.

在许多情况下,由于这些工具是用 C 编写的并进行了优化,它们也比纯 Python 实现更快.

### 密码哈希

我们使用 `passlib` 进行密码哈希.

默认情况下,它使用 `bcrypt` 算法.

这是一种经过充分测试和验证的算法,专门设计用于哈希密码.

它还有"盐",这是一种添加到哈希中的随机值,使得即使两个用户有相同的密码,哈希也会不同.

这可以防止"彩虹表攻击".

#### 为什么不使用 MD5 或 SHA

像 MD5 和 SHA 这样的标准加密哈希算法是"快速"算法.

它们的目的是尽可能快地验证数据完整性.

但对于密码哈希,你想要一种"慢"算法,因为:

- 如果有人攻击你的数据库并获取哈希密码
- 他们可以尝试用速度快的算法(如 MD5 或 SHA)快速生成许多哈希
- 然后将它们与数据库中的哈希进行比较
- 因为这些算法很快,他们可以每秒尝试数十亿个组合

使用像 bcrypt 这样的慢算法可以大大减慢这个过程,使得攻击者在密码哈希方面变得非常困难.

#### 为什么我们使用 `passlib` 而不是直接使用 `bcrypt`

虽然我们可以直接使用 `bcrypt` 库,但 `passlib` 提供了一个统一的接口,支持多种算法,包括:

- bcrypt
- argon2
- pbkdf2_sha1
- pbkdf2_sha256
- pbkdf2_sha512
- scrypt
- 以及其他

它还处理所有复杂的细节,如盐、轮数和其他配置.

它还有一个简单的 `verify` 方法,可以检查密码是否与哈希匹配,而不用担心所有这些细节.

#### 为什么我们设置 `deprecated="auto"`

`passlib` 中设置 `deprecated="auto"` 意味着:

- `passlib` 将自动检测是否使用了已弃用的哈希算法
- 如果检测到,它会在日志中显示警告
- 但仍然支持这些哈希,以确保向后兼容性
- 当用户登录时,你可以自动用新的安全哈希更新他们的密码

这使得你可以随着时间的推移逐步升级密码哈希算法,而不会破坏现有用户的登录.

### 令牌过期

我们在令牌中设置了过期时间:

```python
expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
to_encode.update({"exp": expire})
```

这使得令牌在指定时间后失效.

这对于安全性很重要,因为如果令牌泄露,它将在有限的时间内有效.

### 令牌验证

当用户使用令牌进行请求时,我们解码并验证它:

```python
payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
username: str = payload.get("sub")
```

- 我们解码令牌
- 我们从令牌中获取 `sub` 声明(用户名)
- 我们使用该用户名从数据库中获取用户
- 如果用户不存在,我们返回一个错误

这确保了:
- 令牌没有被篡改(如果被篡改,`jwt.decode` 会失败)
- 令牌没有过期(如果过期,`jwt.decode` 会失败)
- 令牌中的用户存在于我们的数据库中

### 禁用用户

我们还有一个额外的检查来验证用户是否被禁用:

```python
if current_user.disabled:
    raise HTTPException(status_code=400, detail="Inactive user")
```

这允许我们暂时或永久地禁用用户,同时仍然保留他们的数据.

## 安全性注意事项

这是一个简单的示例,说明了基本概念.

但在生产环境中,你应该考虑:

- 使用 HTTPS 而不是 HTTP
- 使用安全的密钥管理服务来存储 SECRET_KEY
- 实现令牌刷新机制,而不是让用户登录
- 考虑使用更复杂的密码策略
- 实现账户锁定机制以防止暴力破解
- 考虑使用多因素认证

在接下来的章节中,你将看到如何实现这些增强功能.