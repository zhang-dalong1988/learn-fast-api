# 中间件

中间件是一个函数,它在每个请求被特定的路径操作处理之前,以及在每个响应返回之前工作.

- 它接收你的应用程序的每一个请求.
- 然后它可以对这个请求做一些事情或者执行某些代码.
- 然后它将请求传递给应用程序的其他部分(通过某种路径操作).
- 然后它获取应用程序的其他部分(通过某种路径操作)生成的响应.
- 它可以对该响应做些什么或者执行某些代码.
- 然后它返回该响应.

> 提示
>
> 如果你使用了 `yield` 关键字的依赖项,退出代码会在中间件之后执行.
>
> 如果有后台任务,它们会在所有中间件执行之后运行.

## 创建中间件

要创建中间件,请在函数的顶部使用装饰器 `@app.middleware("http")`.

中间件函数接收:

- `request`:Request 对象
- `call_next`:一个接收 `request` 作为参数并返回 response 的函数
- 然后你可以在返回 `response` 之前修改它.

```python
import time

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

> 提示
>
> 使用 `@app.middleware("http")` 装饰器创建的中间件会与 ASGI 兼容.

在这个例子中,我们:

1. 记录请求处理开始的时间
2. 调用 `call_next` 来接收响应
3. 计算处理时间
4. 将处理时间添加到响应头中
5. 返回响应

## 中间件执行顺序

中间件按照它们定义的顺序执行.

由于在调用 `call_next` 之前和之后的代码是按顺序执行的,所以有一些理解上的技巧:

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    return response
```

在这种情况下:

1. `add_security_headers` 首先执行(因为它先被定义)
2. 然后调用 `call_next`
3. `add_process_time_header` 接着执行
4. 它调用 `call_next`
5. 路径操作函数执行
6. 响应返回到 `add_process_time_header`
7. 然后响应返回到 `add_security_headers`
8. 最后响应返回给客户端

## 其他中间件示例

### CORS 中间件

处理跨域资源共享(CORS):

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### HTTPS 重定向中间件

将 HTTP 请求重定向到 HTTPS:

```python
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse

app = FastAPI()

@app.middleware("http")
async def https_redirect_middleware(request: Request, call_next):
    if request.url.scheme != "https":
        url = request.url.replace(scheme="https")
        return RedirectResponse(url=url)
    response = await call_next(request)
    return response
```

### 请求日志中间件

记录所有请求:

```python
import logging
from fastapi import FastAPI, Request

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

@app.middleware("http")
async def log_requests(request: Request, call_next):
    logger.info(f"Request: {request.method} {request.url}")
    response = await call_next(request)
    logger.info(f"Response status: {response.status_code}")
    return response
```

### 认证中间件

简单的认证中间件:

```python
from fastapi import FastAPI, Request, HTTPException, status
from fastapi.responses import JSONResponse

app = FastAPI()

# 简单的 API 密钥验证
API_KEY = "your-secret-api-key"

@app.middleware("http")
async def api_key_middleware(request: Request, call_next):
    if request.url.path in ["/docs", "/openapi.json"]:
        # 允许访问文档
        response = await call_next(request)
        return response

    api_key = request.headers.get("X-API-Key")
    if api_key != API_KEY:
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={"detail": "Invalid API Key"}
        )

    response = await call_next(request)
    return response
```

### 限制请求大小中间件

限制请求体的大小:

```python
from fastapi import FastAPI, Request, HTTPException, status

app = FastAPI()
MAX_REQUEST_SIZE = 10 * 1024 * 1024  # 10 MB

@app.middleware("http")
async def limit_request_size(request: Request, call_next):
    content_length = request.headers.get("content-length")
    if content_length and int(content_length) > MAX_REQUEST_SIZE:
        raise HTTPException(
            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
            detail=f"Request too large. Max size: {MAX_REQUEST_SIZE} bytes"
        )

    response = await call_next(request)
    return response
```

## 内置中间件

FastAPI 提供了一些内置中间件:

### HTTPSRedirectMiddleware

将所有 HTTP 请求重定向到 HTTPS:

```python
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

app.add_middleware(HTTPSRedirectMiddleware)
```

### TrustedHostMiddleware

限制允许的主机:

```python
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["example.com", "*.example.com"]
)
```

### GZipMiddleware

对响应进行 Gzip 压缩:

```python
from fastapi.middleware.gzip import GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=1000)
```

## 使用 `add_middleware`

除了使用装饰器,你也可以使用 `add_middleware` 方法来添加中间件:

```python
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()

class ProcessTimeMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response

app.add_middleware(ProcessTimeMiddleware)
```

## 中间件的注意事项

1. **性能影响**:中间件会对每个请求执行,所以要注意性能影响.
2. **顺序很重要**:中间件的执行顺序很重要,要仔细考虑.
3. **异常处理**:在中间件中处理异常时要小心,避免掩盖重要错误.
4. **异步支持**:中间件应该是异步的,使用 `async/await`.

## 中间件 vs 依赖

什么时候使用中间件,什么时候使用依赖?

- 使用**中间件**当:
  - 你需要为每个请求执行代码
  - 你需要在请求被处理之前和响应被返回之后执行代码
  - 你需要与请求/响应的原始属性交互

- 使用**依赖**当:
  - 你只需要为特定的路径操作执行代码
  - 你需要访问路径操作函数的参数
  - 你需要返回一个值供路径操作使用

## 总结

中间件是一个强大的工具,允许你在请求-响应周期的不同阶段执行代码.它们对于:

- 添加跨域头
- 认证和授权
- 日志记录
- 错误处理
- 请求/响应转换

等任务非常有用.

通过合理使用中间件,你可以让你的应用程序更加模块化和可维护.