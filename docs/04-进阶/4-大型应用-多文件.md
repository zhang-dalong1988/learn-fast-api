# 4-大型应用-多文件

如果你正在构建一个应用程序或 web API,很少能将所有内容都放在一个文件中.

FastAPI 提供了一个便利工具来组织你的应用程序结构,同时保持所有灵活性.

> 信息
>
> 如果你来自 Flask,这相当于 Flask 的 Blueprints.

## 示例文件结构

假设你有这样的文件结构:

```
.
├── app
│   ├── __init__.py
│   ├── main.py
│   ├── dependencies.py
│   └── routers
│   │   ├── __init__.py
│   │   ├── items.py
│   │   └── users.py
│   └── internal
│       ├── __init__.py
│       └── admin.py
```

> 提示
>
> 有多个 `__init__.py` 文件:每个目录或子目录中都有一个.
>
> 这就是允许从一个文件向另一个文件导入代码的原因.
>
> 例如,在 `app/main.py` 中,你可以有一行这样的代码:
>
> ```python
> from app.routers import items
> ```

- `app` 目录包含所有内容.它有一个空文件 `app/__init__.py`,所以它是一个"Python 包"("Python 模块"的集合):`app`.
- 它包含一个 `app/main.py` 文件.由于它在一个 Python 包内(一个带有文件 `__init__.py` 的目录),所以它是该包的一个"模块":`app.main`.
- 还有一个 `app/dependencies.py` 文件,就像 `app/main.py` 一样,它是一个"模块":`app.dependencies`.
- 有一个子目录 `app/routers/`,里面还有另一个文件 `__init__.py`,所以它是一个"Python 子包":`app.routers`.
- 文件 `app/routers/items.py` 在包 `app/routers/` 内部,所以它是一个子模块:`app.routers.items`.
- 同样地,`app/routers/users.py` 是另一个子模块:`app.routers.users`.
- 还有一个子目录 `app/internal/`,里面还有另一个文件 `__init__.py`,所以它是另一个"Python 子包":`app.internal`.
- 文件 `app/internal/admin.py` 是另一个子模块:`app.internal.admin`.

带有注释的相同文件结构:

```
.
├── app                  # "app" 是一个 Python 包
│   ├── __init__.py      # 这个文件使 "app" 成为一个 "Python 包"
│   ├── main.py          # "main" 模块,例如 import app.main
│   ├── dependencies.py  # "dependencies" 模块,例如 import app.dependencies
│   └── routers          # "routers" 是一个 "Python 子包"
│   │   ├── __init__.py  # 使 "routers" 成为一个 "Python 子包"
│   │   ├── items.py     # "items" 子模块,例如 import app.routers.items
│   │   └── users.py     # "users" 子模块,例如 import app.routers.users
│   └── internal         # "internal" 是一个 "Python 子包"
│       ├── __init__.py  # 使 "internal" 成为一个 "Python 子包"
│       └── admin.py     # "admin" 子模块,例如 import app.internal.admin
```

## APIRouter

假设专门处理用户的文件是位于 `/app/routers/users.py` 的子模块.

你希望将与用户相关的路径操作与其他代码分开,以保持代码的组织性.

但它仍然是同一个 FastAPI 应用程序/web API 的一部分(它是同一个"Python 包"的一部分).

你可以使用 `APIRouter` 为该模块创建路径操作.

### 导入 APIRouter

你可以像使用 `FastAPI` 类一样导入它并创建一个"实例":

app/routers/users.py

```python
from fastapi import APIRouter

router = APIRouter()

@router.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]

@router.get("/users/me", tags=["users"])
async def read_user_me():
    return {"username": "fakecurrentuser"}

@router.get("/users/{username}", tags=["users"])
async def read_user(username: str):
    return {"username": username}
```

### 使用 APIRouter 的路径操作

然后你使用它来声明你的路径操作.

使用它的方式与使用 `FastAPI` 类相同:

app/routers/users.py

```python
from fastapi import APIRouter

router = APIRouter()

@router.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]

@router.get("/users/me", tags=["users"])
async def read_user_me():
    return {"username": "fakecurrentuser"}

@router.get("/users/{username}", tags=["users"])
async def read_user(username: str):
    return {"username": username}
```

你可以将 `APIRouter` 视为一个"迷你 FastAPI"类.

支持所有相同的选项.

所有相同的 `parameters`、`responses`、`dependencies`、`tags` 等.

> 提示
>
> 在此示例中,变量名为 `router`,但你可以随意命名.

我们将把这个 `APIRouter` 包含在主 `FastAPI` 应用程序中,但首先让我们检查依赖项和另一个 `APIRouter`.

## 依赖项

我们看到我们将在应用程序的多个地方需要一些依赖项.

所以我们将它们放在自己的 `dependencies` 模块(`app/dependencies.py`)中.

现在我们将使用一个简单的依赖项来读取自定义的 `X-Token` 头:

app/dependencies.py

```python
from typing import Annotated

from fastapi import Header, HTTPException

async def get_token_header(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def get_query_token(token: str):
    if token != "jessica":
        raise HTTPException(status_code=400, detail="No Jessica token provided")
```

> 提示
>
> 如果可能,尽量使用 `Annotated` 版本.

> 提示
>
> 我们在这里使用了一个虚构的头来简化这个示例.
>
> 但在实际情况下,使用集成的安全工具会获得更好的效果.

## 另一个使用 APIRouter 的模块

假设你还有一个专门处理应用程序中"items"的端点的模块,位于 `app/routers/items.py`.

你有以下路径操作:

- `/items/`
- `/items/{item_id}`

它的结构与 `app/routers/users.py` 完全相同.

但我们希望更聪明一些,简化代码.

我们知道这个模块中的所有路径操作都有相同的:

- 路径前缀:`/items`.
- `tags`(只有一个标签:`items`).
- 额外的 `responses`.
- `dependencies`:它们都需要我们创建的 `X-Token` 依赖项.

所以,与其将所有这些都添加到每个路径操作中,我们可以将其添加到 `APIRouter`.

app/routers/items.py

```python
from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)

fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}

@router.get("/")
async def read_items():
    return fake_items_db

@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}

@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}
```

由于每个路径操作的路径必须以 `/` 开头,例如:

```python
@router.get("/{item_id}")
async def read_item(item_id: str):
    ...
```

...前缀不能包含最后的 `/`.

因此,在这种情况下,前缀是 `/items`.

我们还可以添加一个 `tags` 列表和额外的 `responses`,它们将应用于此路由器中包含的所有路径操作.

我们还可以添加一个 `dependencies` 列表,这些依赖项将添加到路由器中的所有路径操作,并将对向它们发出的每个请求执行/解决.

最终结果是项目路径现在是:

- `/items/`
- `/items/{item_id}`

...正如我们所期望的那样.

- 它们将被标记为包含单个字符串 "items" 的标签列表.
  - 这些"标签"对于自动交互式文档系统(使用 OpenAPI)特别有用.
- 所有这些都将包含预定义的 `responses`.
- 所有这些路径操作都将在它们之前评估/执行 `dependencies` 列表.
  - 如果你还在特定的路径操作中声明了依赖项,__它们也将被执行__.
  - 路由器依赖项首先执行,然后是装饰器中的依赖项,最后是普通的参数依赖项.
  - 你还可以添加带有 `scopes` 的 `Security` 依赖项.

> 提示
>
> 在 `APIRouter` 中使用 `dependencies` 可以用于,例如,为一整组路径操作要求身份验证.即使依赖项没有单独添加到每个操作中.

> 检查
>
> `prefix`、`tags`、`responses` 和 `dependencies` 参数(与许多其他情况一样)只是 FastAPI 的一个功能,帮助你避免代码重复.

### 导入依赖项

这段代码位于模块 `app.routers.items` 中的文件 `app/routers/items.py`.

我们需要从模块 `app.dependencies`(文件 `app/dependencies.py`)中获取依赖函数.

所以我们使用 `..` 进行相对导入依赖项:

app/routers/items.py

```python
from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)

fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}

@router.get("/")
async def read_items():
    return fake_items_db

@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}

@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}
```

#### 相对导入的工作原理

> 提示
>
> 如果你完全了解导入的工作原理,请继续阅读下面的下一节.

一个点 `.`,例如:

```python
from .dependencies import get_token_header
```

意味着:

- 从此模块(文件 `app/routers/items.py`)所在的同一包(目录 `app/routers/`)开始...
- 找到模块 `dependencies`(位于 `app/routers/dependencies.py` 的假想文件)...
- 从中导入函数 `get_token_header`.

但该文件不存在,我们的依赖项位于文件 `app/dependencies.py`.

记住我们的应用/文件结构是什么样的:

两个点 `..`,例如:

```python
from ..dependencies import get_token_header
```

意味着:

- 从此模块(文件 `app/routers/items.py`)所在的同一包(目录 `app/routers/`)开始...
- 转到父包(目录 `app/`)...
- 在那里,找到模块 `dependencies`(位于 `app/dependencies.py` 的文件)...
- 从中导入函数 `get_token_header`.

这样工作正常!🎉

同样地,如果我们使用了三个点 `...`,例如:

```python
from ...dependencies import get_token_header
```

这意味着:

- 从此模块(文件 `app/routers/items.py`)所在的同一包(目录 `app/routers/`)开始...
- 转到父包(目录 `app/`)...
- 然后转到该包的父包(没有父包,`app` 是顶级😱)...
- 在那里,找到模块 `dependencies`(位于 `app/dependencies.py` 的文件)...
- 从中导入函数 `get_token_header`.

这将引用 `app/` 上方的某个包,它有自己的 `__init__.py` 文件等.但我们没有这个.所以在我们的示例中这将抛出错误.🚨

但现在你知道它是如何工作的,所以你可以在自己的应用程序中使用相对导入,无论它们有多复杂.🤓

### 添加一些自定义的 `tags`、`responses` 和 `dependencies`

我们没有将前缀 `/items` 或 `tags=["items"]` 添加到每个路径操作中,因为我们将它们添加到了 `APIRouter`.

但我们仍然可以添加更多的 `tags`,这些标签将应用于特定的路径操作,以及一些特定于该路径操作的额外 `responses`:

app/routers/items.py

```python
from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)

fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}

@router.get("/")
async def read_items():
    return fake_items_db

@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}

@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}
```

> 提示
>
> 最后一个路径操作将具有标签的组合:`["items", "custom"]`.
>
> 它还将在文档中同时包含两个响应,一个用于 `404`,一个用于 `403`.

## 主 FastAPI

现在,让我们看看 `app/main.py` 中的模块.

在这里你导入并使用 `FastAPI` 类.

这将是你的应用程序中的主文件,它将所有内容联系在一起.

由于你的大部分逻辑现在都将存在于其自己的特定模块中,主文件将相当简单.

### 导入 FastAPI

你像平常一样导入并创建一个 `FastAPI` 类.

我们甚至可以声明全局依赖项,这些依赖项将与每个 `APIRouter` 的依赖项结合:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

### 导入 APIRouter

现在我们导入其他包含 `APIRouter` 的子模块:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

由于文件 `app/routers/users.py` 和 `app/routers/items.py` 是属于同一 Python 包 `app` 的子模块,我们可以使用单个点 `.` 通过"相对导入"来导入它们.

### 导入的工作原理

这部分:

```python
from .routers import items, users
```

意味着:

- 从此模块(文件 `app/main.py`)所在的同一包(目录 `app/`)开始...
- 查找子包 `routers`(位于 `app/routers/` 的目录)...
- 从中导入子模块 `items`(位于 `app/routers/items.py` 的文件)和 `users`(位于 `app/routers/users.py` 的文件)...

模块 `items` 将有一个变量 `router`(`items.router`).这与我们在文件 `app/routers/items.py` 中创建的相同,它是一个 `APIRouter` 对象.

然后我们对模块 `users` 做同样的操作.

我们也可以像这样导入它们:

```python
from app.routers import items, users
```

> 信息
>
> 第一个版本是"相对导入":
>
> ```python
> from .routers import items, users
> ```
>
> 第二个版本是"绝对导入":
>
> ```python
> from app.routers import items, users
> ```
>
> 要了解更多关于 Python 包和模块的信息,请阅读关于模块的官方 Python 文档.

### 避免名称冲突

我们直接导入子模块 `items`,而不是只导入其变量 `router`.

这是因为在子模块 `users` 中我们也有另一个名为 `router` 的变量.

如果我们一个接一个地导入,例如:

```python
from .routers.items import router
from .routers.users import router
```

`users` 的 `router` 将覆盖 `items` 的 `router`,我们将无法同时使用它们.

所以,为了能够在同一文件中使用它们,我们直接导入子模块:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

### 包含 `users` 和 `items` 的 APIRouter

现在,让我们包含来自子模块 `users` 和 `items` 的 `router`:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

> 信息
>
> `users.router` 包含文件 `app/routers/users.py` 内部的 `APIRouter`.
>
> `items.router` 包含文件 `app/routers/items.py` 内部的 `APIRouter`.
>
> 使用 `app.include_router()`,我们可以将每个 `APIRouter` 添加到主 `FastAPI` 应用程序.
>
> 它将包含来自该路由器的所有路由作为其一部分.

> 技术细节
>
> 它实际上会在内部为在 `APIRouter` 中声明的每个路径操作创建一个路径操作.
>
> 因此,在幕后,它实际上会像一切都是同一个应用程序一样工作.

> 检查
>
> 在包含路由器时,你不必担心性能问题.
>
> 这将需要微秒级时间,并且只会在启动时发生.
>
> 因此不会影响性能.⚡

### 包含带有自定义 `prefix`、`tags`、`responses` 和 `dependencies` 的 APIRouter

现在,假设你的组织给了你 `app/internal/admin.py` 文件.

它包含一个 `APIRouter`,带有一些管理路径操作,你的组织在几个项目之间共享这些操作.

对于这个示例,它将非常简单.但假设因为它与组织中的其他项目共享,我们无法修改它并直接向 `APIRouter` 添加 `prefix`、`dependencies`、`tags` 等:

app/internal/admin.py

```python
from fastapi import APIRouter

router = APIRouter()

@router.post("/")
async def update_admin():
    return {"message": "Admin getting schwifty"}
```

但我们仍然希望在包含 `APIRouter` 时设置自定义的 `prefix`,以便其所有路径操作都以 `/admin` 开头,我们希望使用我们已经拥有的 `dependencies` 来保护它,并且我们希望包含 `tags` 和 `responses`.

我们可以通过将这些参数传递给 `app.include_router()` 来声明所有这些,而无需修改原始的 `APIRouter`:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

这样,原始的 `APIRouter` 将保持不变,所以我们仍然可以与组织中的其他项目共享相同的 `app/internal/admin.py` 文件.

结果是在我们的应用程序中,来自 `admin` 模块的每个路径操作都将具有:

- 前缀 `/admin`.
- 标签 `admin`.
- 依赖项 `get_token_header`.
- 响应 `418`.🍵

但这只会影响我们应用程序中的该 `APIRouter`,而不会影响使用它的任何其他代码.

因此,例如,其他项目可以使用相同的 `APIRouter` 但使用不同的身份验证方法.

### 包含一个路径操作

我们还可以直接向 `FastAPI` 应用程序添加路径操作.

在这里我们这样做...只是为了展示我们可以 🤷:

app/main.py

```python
from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])

app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)

@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}
```

它会正常工作,与使用 `app.include_router()` 添加的所有其他路径操作一起.

> 非常技术性的细节
>
> 注意:这是一个非常技术性的细节,你可能__完全可以跳过__.
>
> `APIRouter` 不会"挂载",它们与应用程序的其余部分不是隔离的.
>
> 这是因为我们希望在 OpenAPI 模式和用户界面中包含它们的路径操作.
>
> 由于我们不能只是将它们隔离并独立于应用程序其余部分"挂载",路径操作是"克隆"(重新创建)的,而不是直接包含的.

## 检查自动 API 文档

现在,运行你的应用程序:

```bash
$ fastapi dev app/main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

并在 http://127.0.0.1:8000/docs 打开文档.

你将看到自动 API 文档,包括来自所有子模块的路径,使用正确的路径(和前缀)和正确的标签.

## 使用不同的 `prefix` 多次包含相同的路由器

你还可以多次使用 `.include_router()` 与相同的路由器,但使用不同的前缀.

这可能很有用,例如,在不同的前缀下公开相同的 API,例如 `/api/v1` 和 `/api/latest`.

这是一种高级用法,你可能实际上不需要,但如果你需要,它就在那里.

## 在另一个 APIRouter 中包含 APIRouter

就像你可以在 `FastAPI` 应用程序中包含 `APIRouter` 一样,你可以使用以下方式在另一个 `APIRouter` 中包含 `APIRouter`:

```python
router.include_router(other_router)
```

确保在将 `router` 包含在 `FastAPI` 应用程序之前执行此操作,以便 `other_router` 的路径操作也被包含.