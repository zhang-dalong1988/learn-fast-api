# 异步测试 - FastAPI

FastAPI 应用程序是异步的,因此您可以使用异步测试来更有效地测试它们.

## 异步 vs 同步测试

### 同步测试(默认)

`TestClient` 默认是同步的,即使在异步 FastAPI 应用程序中也是如此:

```python
from fastapi import FastAPI
from fastapi.testclient import TestClient

app = FastAPI()


@app.get("/")
async def read_root():
    return {"message": "Hello World"}


def test_read_root():
    with TestClient(app) as client:
        response = client.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Hello World"}
```

### 异步测试

对于更复杂的异步测试,您可以使用 `httpx.AsyncClient`:

```python
import pytest
from fastapi import FastAPI
import httpx

app = FastAPI()


@app.get("/")
async def read_root():
    return {"message": "Hello World"}


@pytest.mark.asyncio
async def test_read_root_async():
    async with httpx.AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/")
        assert response.status_code == 200
        assert response.json() == {"message": "Hello World"}
```

## 使用 pytest-asyncio

要运行异步测试,您需要安装 `pytest-asyncio`:

```bash
pip install pytest-asyncio
```

## 测试异步端点

### 基本异步端点测试

```python
import pytest
import asyncio
from fastapi import FastAPI
from httpx import AsyncClient

app = FastAPI()


@app.get("/slow")
async def slow_endpoint():
    await asyncio.sleep(0.1)  # 模拟异步操作
    return {"message": "Slow response"}


@pytest.mark.asyncio
async def test_slow_endpoint():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/slow")
        assert response.status_code == 200
        assert response.json() == {"message": "Slow response"}
```

### 测试带参数的异步端点

```python
from fastapi import FastAPI
import pytest
from httpx import AsyncClient

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: str, q: str | None = None):
    if q:
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id}


@pytest.mark.asyncio
async def test_read_item():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        # 测试不带查询参数
        response = await ac.get("/items/foo")
        assert response.status_code == 200
        assert response.json() == {"item_id": "foo"}

        # 测试带查询参数
        response = await ac.get("/items/bar?q=search")
        assert response.status_code == 200
        assert response.json() == {"item_id": "bar", "q": "search"}
```

## 测试 POST 请求

```python
from fastapi import FastAPI
from pydantic import BaseModel
import pytest
from httpx import AsyncClient

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


@app.post("/items/")
async def create_item(item: Item):
    return {"item": item.dict()}


@pytest.mark.asyncio
async def test_create_item():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        item_data = {"name": "Test Item", "price": 10.99}
        response = await ac.post("/items/", json=item_data)
        assert response.status_code == 200
        assert response.json() == {"item": item_data}
```

## 测试异常处理

```python
from fastapi import FastAPI, HTTPException
import pytest
from httpx import AsyncClient

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id == "notfound":
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id}


@pytest.mark.asyncio
async def test_read_item_not_found():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/items/notfound")
        assert response.status_code == 404
        assert response.json() == {"detail": "Item not found"}
```

## 测试异步依赖项

```python
from fastapi import FastAPI, Depends
import pytest
from httpx import AsyncClient

app = FastAPI()


async def get_current_user():
    # 模拟异步获取用户
    return {"username": "johndoe", "role": "user"}


async def get_admin_user(current_user: dict = Depends(get_current_user)):
    if current_user["role"] != "admin":
        raise HTTPException(status_code=403, detail="Not enough permissions")
    return current_user


@app.get("/admin")
async def admin_endpoint(admin_user: dict = Depends(get_admin_user)):
    return admin_user


@pytest.mark.asyncio
async def test_admin_endpoint():
    # 覆盖依赖项
    async def override_get_current_user():
        return {"username": "admin", "role": "admin"}

    app.dependency_overrides[get_current_user] = override_get_current_user

    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/admin")
        assert response.status_code == 200
        assert response.json() == {"username": "admin", "role": "admin"}

    app.dependency_overrides.clear()


@pytest.mark.asyncio
async def test_admin_endpoint_forbidden():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/admin")
        assert response.status_code == 403
        assert response.json() == {"detail": "Not enough permissions"}
```

## 测试 WebSocket(异步)

```python
import pytest
from fastapi import FastAPI, WebSocket
from fastapi.testclient import TestClient

app = FastAPI()


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")


def test_websocket():
    with TestClient(app) as client:
        with client.websocket_connect("/ws") as websocket:
            websocket.send_text("Hello")
            data = websocket.receive_text()
            assert data == "Echo: Hello"
```

## 测试后台任务

```python
from fastapi import FastAPI, BackgroundTasks
import pytest
from httpx import AsyncClient

app = FastAPI()


def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)


@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks
):
    background_tasks.add_task(write_log, f"Notification sent to {email}")
    return {"message": "Notification sent in the background"}


@pytest.mark.asyncio
async def test_send_notification(tmp_path):
    import os

    # 设置测试日志文件
    log_file = tmp_path / "test_log.txt"

    def mock_write_log(message: str):
        with open(log_file, mode="a") as log:
            log.write(message + "\n")

    # 覆盖后台任务
    original_write_log = write_log
    import __main__
    __main__.write_log = mock_write_log

    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.post("/send-notification/test@example.com")
        assert response.status_code == 200

        # 检查日志是否写入
        await asyncio.sleep(0.1)  # 等待后台任务完成
        with open(log_file, "r") as f:
            content = f.read()
            assert "Notification sent to test@example.com" in content

    # 恢复原始函数
    __main__.write_log = original_write_log
```

## 测试流式响应

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import pytest
from httpx import AsyncClient
import asyncio

app = FastAPI()


async def generate_numbers():
    for i in range(5):
        yield f"Number: {i}\n"
        await asyncio.sleep(0.01)


@app.get("/stream")
async def stream_numbers():
    return StreamingResponse(generate_numbers(), media_type="text/plain")


@pytest.mark.asyncio
async def test_stream_numbers():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/stream")
        assert response.status_code == 200
        assert response.headers["content-type"] == "text/plain; charset=utf-8"

        # 检查流式内容
        content = response.text
        lines = content.strip().split("\n")
        assert len(lines) == 5
        for i, line in enumerate(lines):
            assert line == f"Number: {i}"
```

## 测试并发

```python
import pytest
from fastapi import FastAPI
from httpx import AsyncClient
import asyncio

app = FastAPI()


@app.get("/counter")
async def get_counter():
    # 模拟异步操作
    await asyncio.sleep(0.01)
    return {"counter": 1}


@pytest.mark.asyncio
async def test_concurrent_requests():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        # 并发发送多个请求
        tasks = [ac.get("/counter") for _ in range(10)]
        responses = await asyncio.gather(*tasks)

        # 检查所有响应
        assert len(responses) == 10
        for response in responses:
            assert response.status_code == 200
            assert response.json() == {"counter": 1}
```

## 测试超时

```python
import pytest
from fastapi import FastAPI
from httpx import AsyncClient
import asyncio

app = FastAPI()


@app.get("/slow")
async def slow_endpoint():
    await asyncio.sleep(2)  # 耗时 2 秒
    return {"message": "Finally done"}


@pytest.mark.asyncio
async def test_timeout():
    async with AsyncClient(app=app, base_url="http://test", timeout=1.0) as ac:
        with pytest.raises(Exception):  # 应该因超时而失败
            await ac.get("/slow")
```

## 使用 fixture 管理异步资源

```python
import pytest
from fastapi import FastAPI
from httpx import AsyncClient

@pytest.fixture
async def async_client():
    app = FastAPI()

    @app.get("/")
    async def root():
        return {"message": "Test App"}

    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac


@pytest.mark.asyncio
async def test_with_fixture(async_client: AsyncClient):
    response = await async_client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Test App"}
```

## 性能考虑

1. **异步测试更快**:对于 I/O 密集型的测试,异步测试可以更快.

2. **并发测试**:使用 `asyncio.gather()` 进行并发测试.

3. **资源清理**:确保在测试结束时正确清理资源.

4. **超时设置**:为异步测试设置合理的超时.

## 最佳实践

1. **使用 pytest-asyncio**:简化异步测试的编写.

2. **隔离测试**:每个测试应该独立,不依赖于其他测试的状态.

3. **模拟异步操作**:使用模拟库来模拟异步依赖项.

4. **错误处理**:测试异步代码的错误处理.

5. **生命周期管理**:正确管理异步资源的生命周期.

## 更多信息

有关更多详细信息,请查看:

- [pytest-asyncio 文档](https://pytest-asyncio.readthedocs.io/)
- [FastAPI 测试文档](https://fastapi.tiangolo.com/tutorial/testing/)
- [asyncio 文档](https://docs.python.org/3/library/asyncio.html)