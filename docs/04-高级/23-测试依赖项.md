# 测试时覆盖依赖项 - FastAPI

在测试中，您可能需要覆盖或替换依赖项，以控制依赖项的行为并隔离代码。

## 使用 `app.dependency_overrides`

FastAPI 提供了 `app.dependency_overrides` 属性，允许您在测试时覆盖依赖项。

### 基本示例

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


async def get_current_user():
    # 在实际应用中，这里会从数据库或其他来源获取用户
    return {"username": "johndoe", "email": "johndoe@example.com"}


@app.get("/users/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    return current_user


def test_read_users_me():
    # 覆盖依赖项
    def override_get_current_user():
        return {"username": "testuser", "email": "test@example.com"}

    app.dependency_overrides[get_current_user] = override_get_current_user

    with TestClient(app) as client:
        response = client.get("/users/me")
        assert response.status_code == 200
        assert response.json() == {"username": "testuser", "email": "test@example.com"}

    # 清理覆盖
    app.dependency_overrides.clear()
```

## 使用 pytest fixtures 进行覆盖

您可以创建 pytest fixtures 来管理依赖项覆盖：

```python
import pytest
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


async def get_current_user():
    return {"username": "johndoe", "email": "johndoe@example.com"}


@app.get("/users/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    return current_user


@pytest.fixture
def client_with_test_user():
    def override_get_current_user():
        return {"username": "testuser", "email": "test@example.com"}

    app.dependency_overrides[get_current_user] = override_get_current_user
    yield TestClient(app)
    app.dependency_overrides.clear()


def test_read_users_me_with_fixture(client_with_test_user):
    response = client_with_test_user.get("/users/me")
    assert response.status_code == 200
    assert response.json() == {"username": "testuser", "email": "test@example.com"}
```

## 覆盖带有参数的依赖项

如果您的依赖项带有参数，您仍然可以覆盖它们：

```python
from typing import Optional
from fastapi import FastAPI, Depends, Query
from fastapi.testclient import TestClient

app = FastAPI()


async def get_items(q: Optional[str] = Query(None)):
    if q:
        return {"items": [{"item_id": f"Item-{q}"}]}
    return {"items": []}


@app.get("/items/")
async def read_items(items: dict = Depends(get_items)):
    return items


def test_read_items():
    def override_get_items():
        return {"items": [{"item_id": "Test-Item"}]}

    app.dependency_overrides[get_items] = override_get_items

    with TestClient(app) as client:
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {"items": [{"item_id": "Test-Item"}]}

    app.dependency_overrides.clear()
```

## 覆盖类依赖项

您也可以覆盖类依赖项：

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    return {"q": commons.q, "skip": commons.skip, "limit": commons.limit}


def test_read_items():
    class MockCommonQueryParams:
        def __init__(self):
            self.q = "mocked"
            self.skip = 10
            self.limit = 50

    app.dependency_overrides[CommonQueryParams] = MockCommonQueryParams

    with TestClient(app) as client:
        response = client.get("/items/")
        assert response.status_code == 200
        assert response.json() == {"q": "mocked", "skip": 10, "limit": 50}

    app.dependency_overrides.clear()
```

## 覆盖数据库依赖项

测试时覆盖数据库依赖项是一个常见用例：

```python
from typing import Dict, List
from fastapi import FastAPI, Depends, HTTPException
from fastapi.testclient import TestClient
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    title: str
    description: str | None = None


# 模拟数据库
items_db: Dict[str, Item] = {
    "foo": Item(title="Foo", description="The foo of the foos"),
    "bar": Item(title="Bar", description="The bar of the bars"),
}


async def get_database():
    return items_db


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str, db: Dict = Depends(get_database)):
    if item_id not in db:
        raise HTTPException(status_code=404, detail="Item not found")
    return db[item_id]


def test_read_item():
    # 创建测试数据库
    test_db = {
        "test": Item(title="Test Item", description="A test item")
    }

    def override_get_database():
        return test_db

    app.dependency_overrides[get_database] = override_get_database

    with TestClient(app) as client:
        # 测试存在的项目
        response = client.get("/items/test")
        assert response.status_code == 200
        assert response.json() == {"title": "Test Item", "description": "A test item"}

        # 测试不存在的项目
        response = client.get("/items/nonexistent")
        assert response.status_code == 404

    app.dependency_overrides.clear()
```

## 覆盖带有 yield 的依赖项

您可以覆盖使用 `yield` 的依赖项：

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


class SuperDep:
    def __init__(self):
        self.counter = 0

    async def increment(self):
        self.counter += 1
        return self.counter


@asynccontextmanager
async def get_super_dep():
    dep = SuperDep()
    try:
        yield dep
    finally:
        # 清理
        pass


@app.get("/counter")
async def get_counter(super_dep: SuperDep = Depends(get_super_dep)):
    count = await super_dep.increment()
    return {"count": count}


def test_counter():
    class MockSuperDep:
        def __init__(self):
            self.counter = 100

        async def increment(self):
            self.counter += 1
            return self.counter

    async def override_get_super_dep():
        yield MockSuperDep()

    app.dependency_overrides[get_super_dep] = override_get_super_dep

    with TestClient(app) as client:
        response = client.get("/counter")
        assert response.status_code == 200
        assert response.json() == {"count": 101}

    app.dependency_overrides.clear()
```

## 覆盖嵌套依赖项

如果您的依赖项依赖于其他依赖项，您可以覆盖根依赖项或任何中间依赖项：

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


async def dependency_a():
    return {"source": "dependency_a"}


async def dependency_b(dep_a: dict = Depends(dependency_a)):
    return {"source": "dependency_b", "parent": dep_a}


@app.get("/nested")
async def get_nested(dep_b: dict = Depends(dependency_b)):
    return dep_b


def test_nested_dependencies():
    # 方法1：覆盖根依赖项
    def override_dependency_a():
        return {"source": "mock_dependency_a"}

    app.dependency_overrides[dependency_a] = override_dependency_a

    with TestClient(app) as client:
        response = client.get("/nested")
        assert response.json() == {
            "source": "dependency_b",
            "parent": {"source": "mock_dependency_a"}
        }

    app.dependency_overrides.clear()

    # 方法2：覆盖中间依赖项
    def override_dependency_b():
        return {"source": "mock_dependency_b", "parent": {"source": "mock_a"}}

    app.dependency_overrides[dependency_b] = override_dependency_b

    with TestClient(app) as client:
        response = client.get("/nested")
        assert response.json() == {
            "source": "mock_dependency_b",
            "parent": {"source": "mock_a"}
        }

    app.dependency_overrides.clear()
```

## 使用模拟库

您可以结合使用模拟库（如 `unittest.mock`）和依赖项覆盖：

```python
from unittest.mock import AsyncMock, patch
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()


async def get_external_data():
    # 模拟调用外部 API
    return {"data": "real data"}


@app.get("/external-data")
async def read_external_data(data: dict = Depends(get_external_data)):
    return data


def test_external_data():
    # 使用 mock 覆盖依赖项
    mock_data = {"data": "mock data"}

    async def mock_get_external_data():
        return mock_data

    app.dependency_overrides[get_external_data] = mock_get_external_data

    with TestClient(app) as client:
        response = client.get("/external-data")
        assert response.status_code == 200
        assert response.json() == {"data": "mock data"}

    app.dependency_overrides.clear()


def test_external_data_with_patch():
    # 使用 patch 模拟依赖项
    with patch("__main__.get_external_data") as mock:
        mock.return_value = {"data": "patched data"}

        with TestClient(app) as client:
            response = client.get("/external-data")
            assert response.json() == {"data": "patched data"}
            mock.assert_called_once()
```

## 注意事项

1. **清理覆盖**：测试后记得使用 `app.dependency_overrides.clear()` 清理覆盖。

2. **pytest fixtures**：使用 pytest fixtures 可以更好地管理覆盖的生命周期。

3. **类型提示**：确保覆盖的函数返回正确的类型。

4. **异步依赖**：对于异步依赖，使用 async def 定义覆盖函数。

5. **测试隔离**：每个测试应该独立，不依赖于其他测试的状态。

## 更多信息

有关更多详细信息，请查看 FastAPI 的测试文档和依赖项文档。