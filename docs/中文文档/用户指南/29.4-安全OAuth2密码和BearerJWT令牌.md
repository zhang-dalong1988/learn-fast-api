# OAuth2 密码（和哈希），Bearer JWT 令牌

现在我们拥有了所有安全流程, 让我们使应用真正安全, 使用 JWT 令牌和安全密码哈希。

这段代码是你可以真正在应用中使用的, 可以将密码哈希保存在数据库中等。

我们将从上一章离开的地方开始并增量添加。

## 1. 关于 JWT

JWT 表示 "JSON Web Tokens"。

这是一个将 JSON 对象编码为长而密集的无空格字符串的标准。它看起来像这样:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

它没有加密, 所以任何人都可以从内容中恢复信息。

但它是签名的。所以, 当你收到一个你发出的令牌时, 你可以验证它实际上是你发出的。

这样, 你可以创建一个过期时间（比如说 1 周）的令牌。然后当用户第二天带着令牌回来时, 你知道该用户仍然登录到你的系统。

一周后, 令牌将过期, 用户将不被授权, 必须再次登录以获取新令牌。如果用户（或第三方）试图修改令牌以更改过期时间, 你将能够发现它, 因为签名将不匹配。

如果你想玩玩 JWT 令牌并看看它们是如何工作的, 请查看 https://jwt.io。

## 2. 安装 `PyJWT`

我们需要安装 `PyJWT` 以在 Python 中生成和验证 JWT 令牌。

确保你创建了虚拟环境, 激活它, 然后安装 `pyjwt`:

```bash
$ pip install pyjwt

---> 100%
```

### 信息

如果你计划使用数字签名算法（如 RSA 或 ECDSA）, 你应该安装 cryptography 库依赖 `pyjwt[crypto]`。

你可以在 PyJWT 安装文档中阅读更多相关信息。

## 3. 密码哈希

"哈希"意味着将某些内容（在这种情况下是密码）转换为看起来像乱码的字节序列（只是一个字符串）。

每当你传递完全相同的内容（完全相同的密码）时, 你会得到完全相同的乱码。

但你不能从乱码转换回密码。

### 3.1 为什么使用密码哈希

如果你的数据库被盗, 小偷将没有你用户的明文密码, 只有哈希值。

因此, 小偷将无法尝试在其他系统中使用该密码（由于许多用户在任何地方都使用相同的密码, 这将是危险的）。

## 4. 安装 `passlib`

PassLib 是一个用于处理密码哈希的很棒的 Python 包。

它支持许多安全哈希算法和用于处理它们的实用程序。

推荐的算法是 "Bcrypt"。

确保你创建了虚拟环境, 激活它, 然后安装带有 Bcrypt 的 PassLib:

```bash
$ pip install "passlib[bcrypt]"

---> 100%
```

### 提示

使用 `passlib`, 你甚至可以配置它来读取由 __Django__、__Flask__ 安全插件或许多其他插件创建的密码。

因此, 你可以, 例如, 在数据库中从 Django 应用共享相同的数据与 FastAPI 应用。或者逐渐迁移使用相同数据库的 Django 应用。

而且你的用户将能够同时从你的 Django 应用或 __FastAPI__ 应用登录。

## 5. 哈希和验证密码

从 `passlib` 导入我们需要的工具。

创建一个 PassLib "context"。这是将用于哈希和验证密码的东西。

### 提示

PassLib context 还具有使用不同哈希算法的功能, 包括仅用于验证已弃用的旧算法等。

例如, 你可以使用它来读取和验证由另一个系统（如 Django）生成的密码, 但使用不同的算法（如 Bcrypt）哈希任何新密码。

并且同时与所有这些算法兼容。

创建一个实用程序函数来哈希来自用户的密码。

创建另一个实用程序来验证接收的密码是否与存储的哈希匹配。

再创建一个来认证并返回用户。

**Python 3.10+**

```python
# 导入日期时间相关模块
from datetime import datetime, timedelta, timezone
from typing import Annotated

# 导入 JWT 相关库
import jwt
# 导入 FastAPI 组件
from fastapi import Depends, FastAPI, HTTPException, status
# 导入安全相关组件
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 导入 JWT 异常
from jwt.exceptions import InvalidTokenError
# 导入密码哈希上下文
from passlib.context import CryptContext
# 导入 Pydantic 基础模型
from pydantic import BaseModel

# 生成类似这样的字符串运行:
# openssl rand -hex 32
# SECRET_KEY 用于签名 JWT 令牌
# 在生产环境中, 应该使用强随机密钥并妥善保管
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
# JWT 使用的算法
ALGORITHM = "HS256"
# 访问令牌的过期时间（分钟）
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# 模拟用户数据库
# 注意: hashed_password 是密码 "secret" 的哈希版本
# 在实际应用中, 你应该使用真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        # 这是使用 bcrypt 哈希后的密码
        # 原始密码是 "secret"
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

# 定义 Token 响应模型
# 用于登录成功后返回访问令牌
class Token(BaseModel):
    access_token: str  # JWT 访问令牌
    token_type: str   # 令牌类型，通常是 "bearer"

# 定义 Token 数据模型
# 用于从 JWT 令牌中解析出的数据
class TokenData(BaseModel):
    username: str | None = None  # 用户名，可能为 None

# 定义用户基础模型
# 用于返回给客户端的用户信息（不包含密码）
class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

# 定义数据库中的用户模型
# 继承自 User，添加了 hashed_password 字段
class UserInDB(User):
    hashed_password: str

# 创建密码哈希上下文
# schemes=["bcrypt"] 指定使用 bcrypt 算法
# deprecated="auto" 表示自动处理已弃用的算法
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# 创建 OAuth2 密码承载方案
# tokenUrl="token" 指向获取令牌的端点 URL
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 创建 FastAPI 应用实例
app = FastAPI()

# 验证明文密码是否与哈希密码匹配
def verify_password(plain_password, hashed_password):
    # 使用 passlib 的 verify 方法验证密码
    return pwd_context.verify(plain_password, hashed_password)

# 对明文密码进行哈希
def get_password_hash(password):
    # 使用 passlib 的 hash 方法生成哈希
    return pwd_context.hash(password)

# 从数据库获取用户
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 模型实例
        return UserInDB(**user_dict)

# 认证用户
def authenticate_user(fake_db, username: str, password: str):
    # 从数据库获取用户
    user = get_user(fake_db, username)
    # 如果用户不存在，返回 False
    if not user:
        return False
    # 验证密码是否正确
    if not verify_password(password, user.hashed_password):
        return False
    # 认证成功，返回用户对象
    return user

# 创建访问令牌
def create_access_token(data: dict, expires_delta: timedelta | None = None):
    # 复制要编码的数据
    to_encode = data.copy()
    # 如果提供了过期时间增量
    if expires_delta:
        # 计算过期时间（当前 UTC 时间 + 增量）
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        # 默认 15 分钟后过期
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    # 将过期时间添加到要编码的数据中
    to_encode.update({"exp": expire})
    # 使用 JWT 编码数据
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# 获取当前用户的依赖函数
# 从 JWT 令牌中解析用户信息
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 定义凭证异常
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # 解码 JWT 令牌
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        # 获取主题（用户名）
        username = payload.get("sub")
        # 如果用户名为 None，抛出异常
        if username is None:
            raise credentials_exception
        # 创建 TokenData 对象
        token_data = TokenData(username=username)
    except InvalidTokenError:
        # 如果令牌无效，抛出异常
        raise credentials_exception
    # 从数据库获取用户
    user = get_user(fake_users_db, username=token_data.username)
    # 如果用户不存在，抛出异常
    if user is None:
        raise credentials_exception
    return user

# 获取当前活跃用户的依赖函数
# 检查用户是否被禁用
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果用户被禁用，抛出异常
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# 登录端点，获取访问令牌
@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    # 认证用户
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    # 如果认证失败，抛出 401 异常
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    # 计算访问令牌过期时间
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    # 创建访问令牌
    # data={"sub": user.username} 中的 "sub" 是 JWT 规范中的 subject（主题）
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    # 返回令牌
    return Token(access_token=access_token, token_type="bearer")

# 获取当前用户信息的端点
@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户（不包含密码）
    return current_user

# 获取当前用户的物品列表端点
@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回属于当前用户的物品列表
    return [{"item_id": "Foo", "owner": current_user.username}]
```

## 6. 处理 JWT 令牌

导入已安装的模块。

创建一个随机密钥，用于签名 JWT 令牌。

要生成安全的随机密钥，使用命令:

```bash
$ openssl rand -hex 32

09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
```

并将输出复制到变量 `SECRET_KEY`（不要使用示例中的那个）。

创建一个变量 `ALGORITHM`，其中包含用于签名 JWT 令牌的算法，并将其设置为 `"HS256"`。

创建一个令牌过期时间的变量。

定义一个 Pydantic 模型，将在令牌端点中用于响应。

创建一个实用程序函数来生成新的访问令牌。

**Python 3.10+**

```python
from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext
from pydantic import BaseModel

# 生成类似这样的字符串运行:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)

def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")

@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]
```

## 7. 更新依赖项

更新 `get_current_user` 以像以前一样接收相同的令牌, 但这次使用 JWT 令牌。

解码接收的令牌, 验证它, 并返回当前用户。

如果令牌无效, 立即返回 HTTP 错误。

**Python 3.10+**

```python
from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext
from pydantic import BaseModel

# 生成类似这样的字符串运行:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)

def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 定义凭证无效时的异常
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # 解码 JWT 令牌
        # SECRET_KEY 是签名时使用的密钥
        # algorithms 指定允许的算法列表
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        # 从令牌中获取用户名
        # "sub" 是 JWT 规范中的 subject（主题）字段
        username = payload.get("sub")
        # 如果用户名为 None，令牌无效
        if username is None:
            raise credentials_exception
        # 创建 TokenData 对象用于类型验证
        token_data = TokenData(username=username)
    except InvalidTokenError:
        # 如果令牌格式错误或签名无效，抛出异常
        raise credentials_exception
    # 从数据库获取用户
    user = get_user(fake_users_db, username=token_data.username)
    # 如果用户不存在，令牌无效
    if user is None:
        raise credentials_exception
    # 返回用户对象
    return user

async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")

@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]
```

## 8. 更新 `/token` 路径操作

创建一个带有令牌过期时间的 `timedelta`。

创建一个真正的 JWT 访问令牌并返回它。

**Python 3.10+**

```python
from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext
from pydantic import BaseModel

# 生成类似这样的字符串运行:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)

def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# 登录端点，返回访问令牌
@app.post("/token")
async def login_for_access_token(
    # OAuth2PasswordRequestForm 是一个表单类
    # 它要求表单数据包含 username 和 password 字段
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    # 认证用户（验证用户名和密码）
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    # 如果认证失败，抛出 401 异常
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    # 创建访问令牌过期时间（30 分钟）
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    # 生成 JWT 访问令牌
    # data={"sub": user.username} 将用户名作为主题嵌入令牌
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    # 返回令牌给客户端
    return Token(access_token=access_token, token_type="bearer")

@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]
```

### 8.1 关于 JWT "subject" `sub` 的技术细节

JWT 规范说有一个键 `sub`，带有令牌的主题。

使用它是可选的，但那是你放置用户标识的地方，所以我们在这里使用它。

JWT 可能用于除识别用户和允许他们直接在你的 API 上执行操作之外的其他事情。

例如, 你可以识别 "汽车" 或 "博客文章"。

然后你可以为该实体添加权限，比如 "drive"（对于汽车）或 "edit"（对于博客）。

然后，你可以将该 JWT 令牌提供给用户（或机器人），他们可以使用它来执行这些操作（驾驶汽车或编辑博客文章），甚至不需要拥有账户，只需使用你的 API 为其生成的 JWT 令牌。

使用这些想法，JWT 可以用于更复杂的场景。

在这些情况下，这些实体中的几个可能具有相同的 ID，比如说 `foo`（一个用户 `foo`，一辆汽车 `foo` 和一个博客文章 `foo`）。

因此，为了避免 ID 冲突，当为用户创建 JWT 令牌时，你可以为 `sub` 键的值添加前缀，例如使用 `username:`。因此，在这个例子中，`sub` 的值可能是: `username:johndoe`。

重要的是要记住，`sub` 键应该在整个应用程序中具有唯一标识符，并且它应该是一个字符串。

## 9. 检查它

运行服务器并转到文档: http://127.0.0.1:8000/docs。

你将看到用户界面如下所示:

![Image 1](https://example.com/img/tutorial/security/image07.png)

以与之前相同的方式授权应用程序。

使用凭据:

Username: `johndoe`
Password: `secret`

### 注意

请注意，代码中没有任何地方是明文密码 "`secret`"，我们只有哈希版本。

![Image 2](https://example.com/img/tutorial/security/image08.png)

调用端点 `/users/me/`，你将获得如下响应:

```json
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false
}
```

![Image 3](https://example.com/img/tutorial/security/image09.png)

如果你打开开发者工具，你可以看到发送的数据仅包括令牌，密码仅在第一个请求中发送以认证用户并获取该访问令牌，但之后不会:

![Image 4](https://example.com/img/tutorial/security/image10.png)

### 注意

注意标头 `Authorization`，其值以 `Bearer` 开头。

## 10. 高级用法 - `scopes`

OAuth2 有 "scopes" 的概念。

你可以使用它们向 JWT 令牌添加一组特定的权限。

然后你可以将此令牌直接提供给用户或第三方，以一组限制与你的 API 交互。

你可以在后面的 __高级用户指南__ 中了解如何使用它们以及它们如何集成到 __FastAPI__ 中。

## 11. 总结

到目前为止，你已经看到的内容，你可以使用 OAuth2 和 JWT 等标准设置安全的 __FastAPI__ 应用程序。

在几乎任何框架中，处理安全很快就变得相当复杂。

许多大大简化它的包必须对数据模型、数据库和可用功能做出许多妥协。而且一些太简化事情的包实际上在下面有安全缺陷。

---

__FastAPI__ 对任何数据库、数据模型或工具不做任何妥协。

它为你提供了所有的灵活性来选择最适合你项目的那些。

并且你可以直接使用许多维护良好和广泛使用的包，如 `passlib` 和 `PyJWT`，因为 __FastAPI__ 不需要任何复杂的机制来集成外部包。

但它为你提供了尽可能简化流程的工具，而不影响灵活性、健壮性或安全性。

你可以使用和实现安全的、标准的协议，比如 OAuth2，以相对简单的方式。

你可以在 __高级用户指南__ 中了解有关如何使用 OAuth2 "scopes" 的更多信息，以获得更细粒度的权限系统，遵循相同的标准。带有 scopes 的 OAuth2 是许多大型身份验证提供者使用的机制，比如 Facebook、Google、GitHub、Microsoft、Twitter 等，用于授权第三方应用程序代表其用户与它们的 API 交互。
