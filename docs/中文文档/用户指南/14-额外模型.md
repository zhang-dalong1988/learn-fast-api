# 额外模型

## 1. 多个模型

你可以为不同情况声明多个模型。

例如, 你可以有用于以下情况的模型:
* 输入: 包含密码
* 输出: 不包含密码
* 数据库: 包含哈希密码

```python
# 导入 FastAPI, BaseModel 和 EmailStr
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建应用实例
app = FastAPI()


# 定义用户基础模型
class UserBase(BaseModel):
    username: str  # 用户名
    email: EmailStr  # 邮箱, 使用 EmailStr 进行验证
    full_name: str | None = None  # 全名, 可选


# 定义用户输入模型, 继承自 UserBase, 添加密码字段
class UserIn(UserBase):
    password: str  # 密码字段, 仅用于输入


# 定义用户输出模型, 继承自 UserBase, 不包含密码
class UserOut(UserBase):
    pass  # 不添加额外字段, 只包含 UserBase 的字段


# 定义数据库中的用户模型, 包含哈希密码
class UserInDB(UserBase):
    hashed_password: str  # 哈希密码字段


# 模拟密码哈希函数
def fake_password_hasher(raw_password: str):
    # 返回模拟的哈希密码
    return "hashed" + raw_password


# 模拟保存用户函数
def fake_save_user(user_in: UserIn):
    # 哈希密码
    hashed_password = fake_password_hasher(user_in.password)
    # 创建数据库用户模型实例
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    # 返回保存的用户
    return user_in_db


# 定义 POST 路径操作, 使用 UserOut 作为响应模型
@app.post("/user/", response_model=UserOut)
async def create_user(user_in: UserIn):
    # 保存用户 (模拟数据库操作)
    user_saved = fake_save_user(user_in)
    # 返回用户数据 (只包含 UserOut 中定义的字段)
    return user_saved
```

## 2. 总结

使用多个模型可以:

* 分离输入和输出数据
* 为特定模型添加验证规则
* 保持代码清晰和有序

以及更多!
