# 请求体 - 多个参数

既然我们已经看到了如何使用 `Path` 和 `Query`, 让我们看看请求体声明的高级用法.

## 1. 混合使用 Path, Query 和请求体参数

首先, 当然你可以自由地混合 `Path`, `Query` 和请求体参数声明, FastAPI 会知道该做什么.

你也可以通过将默认值设置为 `None` 来声明请求体参数为可选的:

### 1.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # item_id: 路径参数, 必须在 0 到 1000 之间
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    # q: 可选的查询参数
    q: str | None = None,
    # item: 可选的请求体参数
    item: Item | None = None,
):
    # 创建结果字典, 包含 item_id
    results = {"item_id": item_id}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 如果存在请求体 item, 添加到结果中
    if item:
        results.update({"item": item})
    # 返回结果
    return results
```

#### 1.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # item_id: 路径参数, 必须在 0 到 1000 之间
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
    # item: 可选的 Item 或 None 请求体参数
    item: Union[Item, None] = None,
):
    # 创建结果字典, 包含 item_id
    results = {"item_id": item_id}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 如果存在请求体 item, 添加到结果中
    if item:
        results.update({"item": item})
    # 返回结果
    return results
```

#### 1.3 Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated (兼容 Python 3.8)
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # item_id: 路径参数, 必须在 0 到 1000 之间
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
    # item: 可选的 Item 或 None 请求体参数
    item: Union[Item, None] = None,
):
    # 创建结果字典, 包含 item_id
    results = {"item_id": item_id}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 如果存在请求体 item, 添加到结果中
    if item:
        results.update({"item": item})
    # 返回结果
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 1.4 Python 3.10+ - non-Annotated

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    # item_id: 路径参数, 必须在 0 到 1000 之间
    item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
    # q: 可选的查询参数
    q: str | None = None,
    # item: 可选的请求体参数
    item: Item | None = None,
):
    # 创建结果字典, 包含 item_id
    results = {"item_id": item_id}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 如果存在请求体 item, 添加到结果中
    if item:
        results.update({"item": item})
    # 返回结果
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 1.5 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    # item_id: 路径参数, 必须在 0 到 1000 之间
    item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
    # item: 可选的 Item 或 None 请求体参数
    item: Union[Item, None] = None,
):
    # 创建结果字典, 包含 item_id
    results = {"item_id": item_id}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 如果存在请求体 item, 添加到结果中
    if item:
        results.update({"item": item})
    # 返回结果
    return results
```

**注意**

请注意, 在这种情况下, 从请求体中获取的 `item` 是可选的, 因为它的默认值是 `None`.

## 2. 多个请求体参数

在前面的例子中, 路径操作期望一个包含 `Item` 属性的 JSON 请求体, 如下所示:

```json
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

但是你也可以声明多个请求体参数, 例如 `item` 和 `user`:

### 2.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串, 默认为 None
    full_name: str | None = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    # 返回包含 item_id, item 和 user 的结果
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```

#### 2.2 Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    # 返回包含 item_id, item 和 user 的结果
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```

在这种情况下, FastAPI 会注意到函数中有多个请求体参数 (有两个 Pydantic 模型参数).

因此, 它将使用参数名称作为请求体中的键 (字段名), 并期望如下的请求体:

```json
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    }
}
```

**注意**

请注意, 尽管 `item` 的声明方式与之前相同, 但现在它被期望在请求体中, 并以 `item` 作为键.

FastAPI 会自动从请求中转换数据, 使参数 `item` 接收其特定的内容, `user` 也是如此.

它将对复合数据执行验证, 并在 OpenAPI 模式和自动文档中记录这些内容.

## 3. 请求体中的单个值

就像有 `Query` 和 `Path` 可以为查询和路径参数定义额外数据一样, FastAPI 提供了一个等效的 `Body`.

例如, 扩展之前的模型, 你可能决定要在同一个请求体中有一个额外的键 `importance`, 除了 `item` 和 `user` 之外.

如果你直接声明它, 由于它是一个单独的值, FastAPI 会假设它是一个查询参数.

但是你可以使用 `Body` 指示 FastAPI 将其视为另一个请求体键:

### 3.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串, 默认为 None
    full_name: str | None = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance: 使用 Body 声明为请求体参数
    importance: Annotated[int, Body()]
):
    # 返回包含所有参数的结果
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

#### 3.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance: 使用 Body 声明为请求体参数
    importance: Annotated[int, Body()]
):
    # 返回包含所有参数的结果
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

#### 3.3 Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated (兼容 Python 3.8)
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance: 使用 Body 声明为请求体参数
    importance: Annotated[int, Body()]
):
    # 返回包含所有参数的结果
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 3.4 Python 3.10+ - non-Annotated

```python
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串, 默认为 None
    full_name: str | None = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance: 使用 Body 声明为请求体参数, 默认为 Body()
    importance: int = Body()
):
    # 返回包含所有参数的结果
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 3.5 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Item,
    user: User,
    # importance: 使用 Body 声明为请求体参数, 默认为 Body()
    importance: int = Body()
):
    # 返回包含所有参数的结果
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results
```

在这种情况下, FastAPI 将期望如下的请求体:

```json
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    },
    "importance": 5
}
```

同样, 它将转换数据类型, 验证, 记录文档等.

## 4. 多个请求体参数和查询参数

当然, 你也可以在任何需要时声明额外的查询参数, 作为请求体参数的补充.

由于默认情况下, 单个值被解释为查询参数, 你不必显式地添加 `Query`, 你可以直接这样做:

```
q: Union[str, None] = None
```

或者在 Python 3.10 及以上版本中:

例如:

### 4.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串, 默认为 None
    full_name: str | None = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    item_id: int,
    item: Item,
    user: User,
    # importance: 必须大于 0 的请求体参数
    importance: Annotated[int, Body(gt=0)],
    # q: 可选的查询参数
    q: str | None = None,
):
    # 创建结果字典, 包含主要参数
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### 4.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    item_id: int,
    item: Item,
    user: User,
    # importance: 必须大于 0 的请求体参数
    importance: Annotated[int, Body(gt=0)],
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
):
    # 创建结果字典, 包含主要参数
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### 4.3 Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated (兼容 Python 3.8)
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    item_id: int,
    item: Item,
    user: User,
    # importance: 必须大于 0 的请求体参数
    importance: Annotated[int, Body(gt=0)],
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
):
    # 创建结果字典, 包含主要参数
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 4.4 Python 3.10+ - non-Annotated

```python
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串, 默认为 None
    full_name: str | None = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    item_id: int,
    item: Item,
    user: User,
    # importance: 必须大于 0 的请求体参数
    importance: int = Body(gt=0),
    # q: 可选的查询参数
    q: str | None = None,
):
    # 创建结果字典, 包含主要参数
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 4.5 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义 User 模型
class User(BaseModel):
    # username 字段: 必需的字符串
    username: str
    # full_name 字段: 可选的字符串或 None, 默认为 None
    full_name: Union[str, None] = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    # * 号使后面的参数必须使用关键字传递
    *,
    item_id: int,
    item: Item,
    user: User,
    # importance: 必须大于 0 的请求体参数
    importance: int = Body(gt=0),
    # q: 可选的字符串或 None 查询参数
    q: Union[str, None] = None,
):
    # 创建结果字典, 包含主要参数
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    # 如果存在查询参数 q, 添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

**信息**

`Body` 也具有与 `Query`, `Path` 以及你稍后将看到的其他参数相同的所有额外验证和元数据参数.

## 5. 嵌入单个请求体参数

假设你只有一个来自 Pydantic 模型 `Item` 的 `item` 请求体参数.

默认情况下, FastAPI 将直接期望请求体.

但是如果你希望它期望一个带有键 `item` 的 JSON, 并在其中包含模型内容, 就像声明额外的请求体参数时那样, 你可以使用特殊的 `Body` 参数 `embed`:

```
item: Item = Body(embed=True)
```

如下所示:

### 5.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # item: 使用 Body(embed=True) 将模型嵌入到请求体中
    item: Annotated[Item, Body(embed=True)]
):
    # 返回包含 item_id 和 item 的结果
    results = {"item_id": item_id, "item": item}
    return results
```

#### 5.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # item: 使用 Body(embed=True) 将模型嵌入到请求体中
    item: Annotated[Item, Body(embed=True)]
):
    # 返回包含 item_id 和 item 的结果
    results = {"item_id": item_id, "item": item}
    return results
```

#### 5.3 Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated (兼容 Python 3.8)
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # item: 使用 Body(embed=True) 将模型嵌入到请求体中
    item: Annotated[Item, Body(embed=True)]
):
    # 返回包含 item_id 和 item 的结果
    results = {"item_id": item_id, "item": item}
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 5.4 Python 3.10+ - non-Annotated

```python
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串, 默认为 None
    description: str | None = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数, 默认为 None
    tax: float | None = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # item: 使用 Body(embed=True) 将模型嵌入到请求体中
    item: Item = Body(embed=True)
):
    # 返回包含 item_id 和 item 的结果
    results = {"item_id": item_id, "item": item}
    return results
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 5.5 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 Union
from typing import Union
# 导入 FastAPI 框架的 Body
from fastapi import Body, FastAPI
# 导入 Pydantic 的 BaseModel
from pydantic import BaseModel

# 创建应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    # name 字段: 必需的字符串
    name: str
    # description 字段: 可选的字符串或 None, 默认为 None
    description: Union[str, None] = None
    # price 字段: 必需的浮点数
    price: float
    # tax 字段: 可选的浮点数或 None, 默认为 None
    tax: Union[float, None] = None


# 定义路径操作, 更新物品 (不使用 Annotated)
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    # item: 使用 Body(embed=True) 将模型嵌入到请求体中
    item: Item = Body(embed=True)
):
    # 返回包含 item_id 和 item 的结果
    results = {"item_id": item_id, "item": item}
    return results
```

在这种情况下, FastAPI 将期望如下的请求体:

```json
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
}
```

而不是:

```json
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

## 6. 总结

你可以向路径操作函数添加多个请求体参数, 即使一个请求只能有一个请求体.

但是 FastAPI 会处理它, 在你的函数中提供正确的数据, 并在路径操作中验证和记录正确的模式.

你也可以声明单个值作为请求体的一部分接收.

你甚至可以指示 FastAPI 将请求体嵌入到一个键中, 即使只声明了一个参数.
