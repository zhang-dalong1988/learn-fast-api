# 处理错误

在很多情况下, 你需要向使用你 API 的客户端通知错误。

这个客户端可能是一个带有前端的浏览器, 其他人的代码, IoT 设备等。

你可能需要告诉客户端:

- 客户端没有足够的权限执行该操作
- 客户端没有访问该资源的权限
- 客户端试图访问的项目不存在
- 等等

在这些情况下, 你通常会返回 **400** 范围内的 **HTTP 状态码** (从 400 到 499)。

这类似于 200 HTTP 状态码 (从 200 到 299)。那些 "200" 状态码表示请求在某种程度上"成功"了。

400 范围内的状态码表示客户端出现了错误。

还记得所有那些 **"404 Not Found"** 错误 (和笑话) 吗?

## 1. 使用 `HTTPException`

要向客户端返回带有错误的 HTTP 响应, 你可以使用 `HTTPException`。

### 1.1 导入 `HTTPException`

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的数据库
items = {"foo": "The Foo Wrestlers"}

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items/{item_id}")
# 使用 async def 声明异步函数
async def read_item(item_id: str):
    # 检查 item_id 是否存在于 items 字典中
    if item_id not in items:
        # 如果不存在, 抛出 HTTPException 异常, 状态码为 404
        raise HTTPException(status_code=404, detail="Item not found")
    # 如果存在, 返回对应的 item
    return {"item": items[item_id]}
```

### 1.2 在代码中抛出 `HTTPException`

`HTTPException` 是一个普通的 Python 异常, 包含与 API 相关的额外数据。

因为它是一个 Python 异常, 你不 `return` 它, 而是 `raise` 它。

这也意味着, 如果你在*路径操作函数*中调用的工具函数内部, 并从该工具函数内部抛出 `HTTPException`, 它将不会运行*路径操作函数*中的其余代码, 而是立即终止该请求并将 `HTTPException` 的 HTTP 错误发送给客户端。

相比 `return` 一个值, 抛出异常的好处在依赖项和安全性部分会更加明显。

在这个例子中, 当客户端请求一个不存在的 ID 的项目时, 抛出一个状态码为 `404` 的异常:

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的数据库
items = {"foo": "The Foo Wrestlers"}

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items/{item_id}")
# 使用 async def 声明异步函数
async def read_item(item_id: str):
    # 检查 item_id 是否存在于 items 字典中
    if item_id not in items:
        # 如果不存在, 抛出 HTTPException 异常, 状态码为 404
        raise HTTPException(status_code=404, detail="Item not found")
    # 如果存在, 返回对应的 item
    return {"item": items[item_id]}
```

### 1.3 生成的响应

如果客户端请求 `http://example.com/items/foo` (一个 `item_id` 为 `"foo"`), 该客户端将收到 HTTP 状态码 200 和一个 JSON 响应:

```json
{
  "item": "The Foo Wrestlers"
}
```

但如果客户端请求 `http://example.com/items/bar` (一个不存在的 `item_id` `"bar"`), 该客户端将收到 HTTP 状态码 404 ("not found" 错误) 和一个 JSON 响应:

```json
{
  "detail": "Item not found"
}
```

提示

当抛出 `HTTPException` 时, 你可以将任何可以转换为 JSON 的值作为 `detail` 参数传递, 不仅仅是 `str`。

你可以传递 `dict`, `list` 等。

它们会被 **FastAPI** 自动处理并转换为 JSON。

## 2. 添加自定义头部

在某些情况下, 能够向 HTTP 错误添加自定义头是很有用的。例如, 对于某些类型的安全性。

你可能不需要在代码中直接使用它。

但是如果你在高级场景中需要它, 你可以添加自定义头:

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的数据库
items = {"foo": "The Foo Wrestlers"}

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items-header/{item_id}")
# 使用 async def 声明异步函数
async def read_item_header(item_id: str):
    # 检查 item_id 是否存在于 items 字典中
    if item_id not in items:
        # 如果不存在, 抛出 HTTPException 异常
        # status_code: HTTP 状态码
        # detail: 错误详情
        # headers: 自定义响应头
        raise HTTPException(
            status_code=404,
            detail="Item not found",
            headers={"X-Error": "There goes my error"},
        )
    # 如果存在, 返回对应的 item
    return {"item": items[item_id]}
```

## 3. 安装自定义异常处理器

你可以使用与 Starlette 相同的异常工具添加自定义异常处理器。

假设你有一个自定义异常 `UnicornException`, 你 (或你使用的库) 可能会抛出它。

并且你想使用 FastAPI 全局处理这个异常。

你可以使用 `@app.exception_handler()` 添加一个自定义异常处理器:

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 Request
from fastapi import FastAPI, Request
# 从 fastapi.responses 中导入 JSONResponse
from fastapi.responses import JSONResponse

# 定义一个自定义异常类 UnicornException, 继承自 Exception
class UnicornException(Exception):
    # 初始化方法, 接收 name 参数
    def __init__(self, name: str):
        self.name = name

# 创建 FastAPI 应用实例
app = FastAPI()

# 为 UnicornException 注册异常处理器
@app.exception_handler(UnicornException)
# 异常处理器函数, 接收 request 和 exc 参数
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    # 返回 JSONResponse, 状态码为 418
    return JSONResponse(
        status_code=418,
        # 响应内容包含错误消息
        content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
    )

# 定义一个路径操作, 接收 name 路径参数
@app.get("/unicorns/{name}")
# 使用 async def 声明异步函数
async def read_unicorn(name: str):
    # 如果 name 等于 "yolo"
    if name == "yolo":
        # 抛出 UnicornException 异常
        raise UnicornException(name=name)
    # 否则返回 unicorn 名称
    return {"unicorn_name": name}
```

在这里, 如果你请求 `/unicorns/yolo`, *路径操作*将抛出一个 `UnicornException`。

但它会被 `unicorn_exception_handler` 处理。

因此, 你将收到一个清晰的错误, HTTP 状态码为 `418`, JSON 内容为:

```json
{"message": "Oops! yolo did something. There goes a rainbow..."}
```

技术细节

你也可以使用 `from starlette.requests import Request` 和 `from starlette.responses import JSONResponse`。

**FastAPI** 将相同的 `starlette.responses` 作为 `fastapi.responses` 提供, 只是为了方便你, 开发者。但大多数可用的响应直接来自 Starlette。`Request` 也是如此。

## 4. 覆盖默认异常处理器

**FastAPI** 有一些默认异常处理器。

这些处理器负责在抛出 `HTTPException` 和请求包含无效数据时返回默认 JSON 响应。

你可以用自己的异常处理器覆盖这些异常处理器。

### 4.1 覆盖请求验证异常

当请求包含无效数据时, **FastAPI** 在内部会抛出 `RequestValidationError`。

并且它还包括一个默认的异常处理器。

要覆盖它, 导入 `RequestValidationError` 并使用 `@app.exception_handler(RequestValidationError)` 来装饰异常处理器。

异常处理器将接收一个 `Request` 和异常。

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException
# 从 fastapi.exceptions 中导入 RequestValidationError
from fastapi.exceptions import RequestValidationError
# 从 fastapi.responses 中导入 PlainTextResponse
from fastapi.responses import PlainTextResponse
# 从 starlette.exceptions 中导入 HTTPException 并重命名为 StarletteHTTPException
from starlette.exceptions import HTTPException as StarletteHTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 为 StarletteHTTPException 注册异常处理器
@app.exception_handler(StarletteHTTPException)
# 异常处理器函数
async def http_exception_handler(request, exc):
    # 返回纯文本响应, 包含异常详情
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)

# 为 RequestValidationError 注册异常处理器
@app.exception_handler(RequestValidationError)
# 异常处理器函数
async def validation_exception_handler(request, exc):
    # 返回纯文本响应, 包含异常信息
    return PlainTextResponse(str(exc), status_code=400)

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items/{item_id}")
# 使用 async def 声明异步函数
async def read_item(item_id: int):
    # 如果 item_id 等于 3
    if item_id == 3:
        # 抛出 HTTPException 异常, 状态码为 418
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    # 否则返回 item_id
    return {"item_id": item_id}
```

现在, 如果你访问 `/items/foo`, 你将不会得到默认的 JSON 错误:

```json
{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}
```

你会得到一个文本版本:

```
1 validation error
path -> item_id
  value is not a valid integer (type=type_error.integer)
```

#### 4.1.1 `RequestValidationError` vs `ValidationError`

警告

这些是技术细节, 如果现在对你不重要, 你可以跳过。

`RequestValidationError` 是 Pydantic 的 `ValidationError` 的子类。

**FastAPI** 使用它, 这样如果你在 `response_model` 中使用 Pydantic 模型, 并且你的数据有错误, 你将在你的日志中看到错误。

但客户端/用户不会看到它。相反, 客户端将收到 "Internal Server Error", HTTP 状态码为 `500`。

应该是这样的, 因为如果你在你的*响应*或代码的任何地方 (而不是在客户端的*请求*中) 有一个 Pydantic `ValidationError`, 这实际上是你代码中的一个 bug。

当你修复它时, 你的客户端/用户不应该有权访问有关错误的内部信息, 因为这可能会暴露安全漏洞。

### 4.2 覆盖 `HTTPException` 错误处理器

同样, 你可以覆盖 `HTTPException` 处理器。

例如, 你可能希望为这些错误返回纯文本响应而不是 JSON:

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException
# 从 fastapi.exceptions 中导入 RequestValidationError
from fastapi.exceptions import RequestValidationError
# 从 fastapi.responses 中导入 PlainTextResponse
from fastapi.responses import PlainTextResponse
# 从 starlette.exceptions 中导入 HTTPException 并重命名为 StarletteHTTPException
from starlette.exceptions import HTTPException as StarletteHTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 为 StarletteHTTPException 注册异常处理器
@app.exception_handler(StarletteHTTPException)
# 异常处理器函数
async def http_exception_handler(request, exc):
    # 返回纯文本响应, 包含异常详情
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)

# 为 RequestValidationError 注册异常处理器
@app.exception_handler(RequestValidationError)
# 异常处理器函数
async def validation_exception_handler(request, exc):
    # 返回纯文本响应, 包含异常信息
    return PlainTextResponse(str(exc), status_code=400)

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items/{item_id}")
# 使用 async def 声明异步函数
async def read_item(item_id: int):
    # 如果 item_id 等于 3
    if item_id == 3:
        # 抛出 HTTPException 异常, 状态码为 418
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    # 否则返回 item_id
    return {"item_id": item_id}
```

技术细节

你也可以使用 `from starlette.responses import PlainTextResponse`。

**FastAPI** 将相同的 `starlette.responses` 作为 `fastapi.responses` 提供, 只是为了方便你, 开发者。但大多数可用的响应直接来自 Starlette。

### 4.3 使用 `RequestValidationError` 的 body

`RequestValidationError` 包含它接收到的带有无效数据的 `body`。

你可以在开发应用程序时使用它来记录 body 并调试它, 将其返回给用户等。

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI, Request 和 status
from fastapi import FastAPI, Request, status
# 从 fastapi.encoders 中导入 jsonable_encoder
from fastapi.encoders import jsonable_encoder
# 从 fastapi.exceptions 中导入 RequestValidationError
from fastapi.exceptions import RequestValidationError
# 从 fastapi.responses 中导入 JSONResponse
from fastapi.responses import JSONResponse
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 为 RequestValidationError 注册异常处理器
@app.exception_handler(RequestValidationError)
# 异常处理器函数, 接收 request 和 exc 参数
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    # 返回 JSONResponse, 状态码为 422
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        # 响应内容包含错误详情和请求体
        content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
    )

# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    title: str  # title 字段, 字符串类型
    size: int   # size 字段, 整数类型

# 定义一个路径操作, 创建 item
@app.post("/items/")
# 使用 async def 声明异步函数
async def create_item(item: Item):
    # 返回创建的 item
    return item
```

现在尝试发送一个无效的 item, 例如:

```json
{
  "title": "towel",
  "size": "XL"
}
```

你将收到一个响应, 告诉你数据无效, 包含接收到的 body:

```json
{
  "detail": [
    {
      "loc": [
        "body",
        "size"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ],
  "body": {
    "title": "towel",
    "size": "XL"
  }
}
```

#### 4.3.1 FastAPI 的 `HTTPException` vs Starlette 的 `HTTPException`

**FastAPI** 有自己的 `HTTPException`。

并且 **FastAPI** 的 `HTTPException` 错误类继承自 Starlette 的 `HTTPException` 错误类。

唯一的区别是 **FastAPI** 的 `HTTPException` 接受任何可转换为 JSON 的数据作为 `detail` 字段, 而 Starlette 的 `HTTPException` 只接受字符串。

因此, 你可以继续在你的代码中正常抛出 **FastAPI** 的 `HTTPException`。

但是当你注册异常处理器时, 你应该为 Starlette 的 `HTTPException` 注册它。

这样, 如果 Starlette 内部代码的任何部分, 或 Starlette 扩展或插件, 抛出 Starlette `HTTPException`, 你的处理器将能够捕获并处理它。

在这个例子中, 为了能够在同一个代码中拥有两个 `HTTPException`, Starlette 的异常被重命名为 `StarletteHTTPException`:

```python
# 从 starlette.exceptions 中导入 HTTPException 并重命名为 StarletteHTTPException
from starlette.exceptions import HTTPException as StarletteHTTPException
```

### 4.4 重用 **FastAPI** 的异常处理器

如果你想使用异常以及来自 **FastAPI** 的相同默认异常处理器, 你可以从 `fastapi.exception_handlers` 导入并重用默认异常处理器:

Python 3.8+

```python
# 从 fastapi 包中导入 FastAPI 和 HTTPException
from fastapi import FastAPI, HTTPException
# 从 fastapi.exception_handlers 中导入默认异常处理器
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
# 从 fastapi.exceptions 中导入 RequestValidationError
from fastapi.exceptions import RequestValidationError
# 从 starlette.exceptions 中导入 HTTPException 并重命名为 StarletteHTTPException
from starlette.exceptions import HTTPException as StarletteHTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 为 StarletteHTTPException 注册自定义异常处理器
@app.exception_handler(StarletteHTTPException)
# 自定义异常处理器函数
async def custom_http_exception_handler(request, exc):
    # 打印错误信息
    print(f"OMG! An HTTP error!: {repr(exc)}")
    # 调用默认的 http_exception_handler 并返回其结果
    return await http_exception_handler(request, exc)

# 为 RequestValidationError 注册自定义异常处理器
@app.exception_handler(RequestValidationError)
# 自定义异常处理器函数
async def validation_exception_handler(request, exc):
    # 打印错误信息
    print(f"OMG! The client sent invalid data!: {exc}")
    # 调用默认的 request_validation_exception_handler 并返回其结果
    return await request_validation_exception_handler(request, exc)

# 定义一个路径操作, 接收 item_id 路径参数
@app.get("/items/{item_id}")
# 使用 async def 声明异步函数
async def read_item(item_id: int):
    # 如果 item_id 等于 3
    if item_id == 3:
        # 抛出 HTTPException 异常, 状态码为 418
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    # 否则返回 item_id
    return {"item_id": item_id}
```

在这个例子中, 你只是用一个非常有表现力的消息 `print` 错误, 但你明白了。你可以使用异常, 然后只需重用默认异常处理器。
