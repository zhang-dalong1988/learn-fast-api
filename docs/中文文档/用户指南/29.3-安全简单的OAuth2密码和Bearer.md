# 29.3 安全 - 简单的 OAuth2 密码和 Bearer

现在让我们基于上一章的内容, 添加缺失的部分以完成完整的安全流程.

## 1. 获取 `username` 和 `password`

我们将使用 FastAPI 的安全工具来获取 `username` 和 `password`.

OAuth2 规范规定, 当使用 "密码流" (password flow, 即我们正在使用的方式) 时, 客户端/用户必须以表单数据的形式发送 `username` 和 `password` 字段.

规范规定字段必须这样命名. 因此 `user-name` 或 `email` 不会生效.

但别担心, 你可以在前端向最终用户展示任何你想要的名称.

而且你的数据库模型可以使用任何你想要的其他名称.

但是对于登录路径操作, 我们需要使用这些名称以符合规范 (并且能够使用, 例如, 集成的 API 文档系统).

规范还规定 `username` 和 `password` 必须作为表单数据发送 (因此, 这里不是 JSON).

### 1.1 `scope`

规范还规定客户端可以发送另一个表单字段 "`scope`".

表单字段名称是 `scope` (单数形式), 但实际上是一个由空格分隔的 "scopes" 组成的长字符串.

每个 "scope" 只是一个字符串 (不含空格).

它们通常用于声明特定的安全权限, 例如:

- `users:read` 或 `users:write` 是常见的示例.
- `instagram_basic` 被 Facebook/Instagram 使用.
- `https://www.googleapis.com/auth/drive` 被 Google 使用.

信息

在 OAuth2 中, "scope" 只是声明所需特定权限的字符串.

它是否包含其他字符如 `:` 或者它是否是 URL 都不重要.

这些细节是特定于实现的.

对于 OAuth2 来说, 它们只是字符串.

## 2. 获取 `username` 和 `password` 的代码

现在让我们使用 FastAPI 提供的工具来处理这个问题.

### 2.1 `OAuth2PasswordRequestForm`

首先, 导入 `OAuth2PasswordRequestForm`, 并在 `/token` 的路径操作中将其与 `Depends` 一起作为依赖使用:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, HTTPException 和 status
from fastapi import Depends, FastAPI, HTTPException, status
# 从 fastapi.security 导入 OAuth2PasswordBearer 和 OAuth2PasswordRequestForm, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建伪造的用户数据库, 用于演示
# 在实际应用中, 这应该是一个真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",           # 用户名
        "full_name": "John Doe",          # 全名
        "email": "johndoe@example.com",   # 电子邮件
        "hashed_password": "fakehashedsecret",  # 哈希后的密码
        "disabled": False,                # 是否禁用
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,  # 这个用户被禁用了
    },
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个伪造的密码哈希函数
# 在实际应用中, 应该使用真正的密码哈希库, 如 passlib
def fake_hash_password(password: str):
    # 简单地在密码前添加 "fakehashed" 前缀
    return "fakehashed" + password

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义 UserInDB 数据模型, 继承自 User
# 这个模型包含数据库中存储的用户的所有信息, 包括哈希后的密码
class UserInDB(User):
    hashed_password: str  # 哈希后的密码, 必填字段

# 定义从数据库获取用户的函数
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 对象, 使用 **user_dict 解包字典作为参数
        return UserInDB(**user_dict)

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
# 这个例子中没有提供任何安全性, 仅仅用于演示
def fake_decode_token(token):
    # 这完全不提供任何安全性
    # 请查看下一个版本
    # 直接使用 token 作为 username 从数据库获取用户
    user = get_user(fake_users_db, token)
    return user

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 如果用户不存在
    if not user:
        # 抛出 HTTP 401 未授权异常
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,  # 401 未授权状态码
            detail="Invalid authentication credentials",  # 错误详情: 无效的认证凭据
            headers={"WWW-Authenticate": "Bearer"},  # WWW-Authenticate 头, 告诉客户端使用 Bearer token
        )
    # 返回用户对象
    return user

# 定义 get_current_active_user 依赖函数
# current_user 参数通过 Depends(get_current_user) 自动注入
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果当前用户被禁用
    if current_user.disabled:
        # 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Inactive user")  # 400 错误, 非活动用户
    # 返回当前用户
    return current_user

# 定义一个 POST 路由操作, 路径为 /token
# 这是 OAuth2 密码流的标准 token 端点
# form_data 参数通过 Depends() 自动注入, 类型为 OAuth2PasswordRequestForm
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    # 从数据库中获取用户数据
    user_dict = fake_users_db.get(form_data.username)
    # 如果用户不存在
    if not user_dict:
        # 抛出 HTTP 400 异常, 提示用户名或密码不正确
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    # 创建 UserInDB 对象
    user = UserInDB(**user_dict)
    # 对用户输入的密码进行哈希
    hashed_password = fake_hash_password(form_data.password)
    # 检查哈希后的密码是否与数据库中的密码匹配
    if not hashed_password == user.hashed_password:
        # 如果不匹配, 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    # 返回 access_token 和 token_type
    # access_token 是用户的 username (在实际应用中应该是 JWT token)
    # token_type 是 "bearer"
    return {"access_token": user.username, "token_type": "bearer"}

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_active_user) 依赖注入自动获取
# 这确保了只有活动的已认证用户才能访问这个端点
@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户信息
    return current_user
```

`OAuth2PasswordRequestForm` 是一个类依赖, 它声明了一个包含以下内容的表单请求体:

- `username`
- `password`
- 可选的 `scope` 字段, 为一个大字符串, 由空格分隔的字符串组成.
- 可选的 `grant_type`.

提示

OAuth2 规范实际上要求一个 `grant_type` 字段, 其固定值为 `password`, 但 `OAuth2PasswordRequestForm` 不会强制执行它.

如果你需要强制执行它, 请使用 `OAuth2PasswordRequestFormStrict` 而不是 `OAuth2PasswordRequestForm`.

- 可选的 `client_id` (我们的示例不需要它).
- 可选的 `client_secret` (我们的示例不需要它).

信息

`OAuth2PasswordRequestForm` 不是像 `OAuth2PasswordBearer` 那样的 FastAPI 特殊类.

`OAuth2PasswordBearer` 使 FastAPI 知道它是一个安全方案. 因此它以这种方式添加到 OpenAPI.

但 `OAuth2PasswordRequestForm` 只是一个类依赖, 你可以自己编写, 或者你可以直接声明 `Form` 参数.

但由于这是一个常见用例, FastAPI 直接提供它, 只是为了使它更容易.

### 2.2 使用表单数据

提示

依赖类 `OAuth2PasswordRequestForm` 的实例不会有一个包含空格分隔的长字符串的 `scope` 属性, 相反, 它将有一个 `scopes` 属性, 其中包含发送的每个范围的实际字符串列表.

我们在这个示例中没有使用 `scopes`, 但如果你需要它, 功能是存在的.

现在, 使用表单字段中的 `username` 从 (伪造的) 数据库中获取用户数据.

如果没有这样的用户, 我们会返回一个错误, 提示 "用户名或密码不正确".

对于错误, 我们使用异常 `HTTPException`:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, HTTPException 和 status
from fastapi import Depends, FastAPI, HTTPException, status
# 从 fastapi.security 导入 OAuth2PasswordBearer 和 OAuth2PasswordRequestForm, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建伪造的用户数据库, 用于演示
# 在实际应用中, 这应该是一个真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",           # 用户名
        "full_name": "John Doe",          # 全名
        "email": "johndoe@example.com",   # 电子邮件
        "hashed_password": "fakehashedsecret",  # 哈希后的密码
        "disabled": False,                # 是否禁用
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,  # 这个用户被禁用了
    },
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个伪造的密码哈希函数
# 在实际应用中, 应该使用真正的密码哈希库, 如 passlib
def fake_hash_password(password: str):
    # 简单地在密码前添加 "fakehashed" 前缀
    return "fakehashed" + password

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义 UserInDB 数据模型, 继承自 User
# 这个模型包含数据库中存储的用户的所有信息, 包括哈希后的密码
class UserInDB(User):
    hashed_password: str  # 哈希后的密码, 必填字段

# 定义从数据库获取用户的函数
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 对象, 使用 **user_dict 解包字典作为参数
        return UserInDB(**user_dict)

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
# 这个例子中没有提供任何安全性, 仅仅用于演示
def fake_decode_token(token):
    # 这完全不提供任何安全性
    # 请查看下一个版本
    # 直接使用 token 作为 username 从数据库获取用户
    user = get_user(fake_users_db, token)
    return user

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 如果用户不存在
    if not user:
        # 抛出 HTTP 401 未授权异常
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,  # 401 未授权状态码
            detail="Invalid authentication credentials",  # 错误详情: 无效的认证凭据
            headers={"WWW-Authenticate": "Bearer"},  # WWW-Authenticate 头, 告诉客户端使用 Bearer token
        )
    # 返回用户对象
    return user

# 定义 get_current_active_user 依赖函数
# current_user 参数通过 Depends(get_current_user) 自动注入
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果当前用户被禁用
    if current_user.disabled:
        # 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Inactive user")  # 400 错误, 非活动用户
    # 返回当前用户
    return current_user

# 定义一个 POST 路由操作, 路径为 /token
# 这是 OAuth2 密码流的标准 token 端点
# form_data 参数通过 Depends() 自动注入, 类型为 OAuth2PasswordRequestForm
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    # 从数据库中获取用户数据, 使用表单中的 username
    user_dict = fake_users_db.get(form_data.username)
    # 如果用户不存在
    if not user_dict:
        # 抛出 HTTP 400 异常, 提示用户名或密码不正确
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    # 创建 UserInDB 对象, 解包 user_dict
    user = UserInDB(**user_dict)
    # 对用户输入的密码进行哈希
    hashed_password = fake_hash_password(form_data.password)
    # 检查哈希后的密码是否与数据库中的密码匹配
    if not hashed_password == user.hashed_password:
        # 如果不匹配, 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    # 返回 access_token 和 token_type
    # access_token 是用户的 username (在实际应用中应该是 JWT token)
    # token_type 是 "bearer"
    return {"access_token": user.username, "token_type": "bearer"}

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_active_user) 依赖注入自动获取
# 这确保了只有活动的已认证用户才能访问这个端点
@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户信息
    return current_user
```

### 2.3 检查密码

此时我们已经从数据库中获取了用户数据, 但我们还没有检查密码.

让我们首先将数据放入 Pydantic `UserInDB` 模型中.

你永远不应该保存明文密码, 所以, 我们将使用 (伪造的) 密码哈希系统.

如果密码不匹配, 我们返回相同的错误.

#### 2.3.1 密码哈希

"哈希" 意味着: 将某些内容 (在这种情况下是密码) 转换为字节序列 (只是一个字符串), 看起来像乱码.

每当你传递完全相同的内容 (完全相同的密码) 时, 你会得到完全相同的乱码.

但你不能从乱码转换回密码.

##### 为什么要使用密码哈希

如果你的数据库被盗, 小偷将不会拥有你用户的明文密码, 只有哈希值.

因此, 小偷将无法尝试在另一个系统中使用这些相同的密码 (由于许多用户在任何地方都使用相同的密码, 这将是很危险的).

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, HTTPException 和 status
from fastapi import Depends, FastAPI, HTTPException, status
# 从 fastapi.security 导入 OAuth2PasswordBearer 和 OAuth2PasswordRequestForm, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建伪造的用户数据库, 用于演示
# 在实际应用中, 这应该是一个真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",           # 用户名
        "full_name": "John Doe",          # 全名
        "email": "johndoe@example.com",   # 电子邮件
        "hashed_password": "fakehashedsecret",  # 哈希后的密码
        "disabled": False,                # 是否禁用
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,  # 这个用户被禁用了
    },
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个伪造的密码哈希函数
# 在实际应用中, 应该使用真正的密码哈希库, 如 passlib
def fake_hash_password(password: str):
    # 简单地在密码前添加 "fakehashed" 前缀
    return "fakehashed" + password

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义 UserInDB 数据模型, 继承自 User
# 这个模型包含数据库中存储的用户的所有信息, 包括哈希后的密码
class UserInDB(User):
    hashed_password: str  # 哈希后的密码, 必填字段

# 定义从数据库获取用户的函数
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 对象, 使用 **user_dict 解包字典作为参数
        return UserInDB(**user_dict)

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
# 这个例子中没有提供任何安全性, 仅仅用于演示
def fake_decode_token(token):
    # 这完全不提供任何安全性
    # 请查看下一个版本
    # 直接使用 token 作为 username 从数据库获取用户
    user = get_user(fake_users_db, token)
    return user

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 如果用户不存在
    if not user:
        # 抛出 HTTP 401 未授权异常
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,  # 401 未授权状态码
            detail="Invalid authentication credentials",  # 错误详情: 无效的认证凭据
            headers={"WWW-Authenticate": "Bearer"},  # WWW-Authenticate 头, 告诉客户端使用 Bearer token
        )
    # 返回用户对象
    return user

# 定义 get_current_active_user 依赖函数
# current_user 参数通过 Depends(get_current_user) 自动注入
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果当前用户被禁用
    if current_user.disabled:
        # 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Inactive user")  # 400 错误, 非活动用户
    # 返回当前用户
    return current_user

# 定义一个 POST 路由操作, 路径为 /token
# 这是 OAuth2 密码流的标准 token 端点
# form_data 参数通过 Depends() 自动注入, 类型为 OAuth2PasswordRequestForm
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    # 从数据库中获取用户数据, 使用表单中的 username
    user_dict = fake_users_db.get(form_data.username)
    # 如果用户不存在
    if not user_dict:
        # 抛出 HTTP 400 异常, 提示用户名或密码不正确
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    # 创建 UserInDB 对象, 解包 user_dict
    user = UserInDB(**user_dict)
    # 对用户输入的密码进行哈希
    hashed_password = fake_hash_password(form_data.password)
    # 检查哈希后的密码是否与数据库中的密码匹配
    if not hashed_password == user.hashed_password:
        # 如果不匹配, 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    # 返回 access_token 和 token_type
    # access_token 是用户的 username (在实际应用中应该是 JWT token)
    # token_type 是 "bearer"
    return {"access_token": user.username, "token_type": "bearer"}

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_active_user) 依赖注入自动获取
# 这确保了只有活动的已认证用户才能访问这个端点
@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户信息
    return current_user
```

#### 2.3.2 关于 `**user_dict`

`UserInDB(**user_dict)` 意思是:

_直接将 `user_dict` 的键和值作为键值参数传递, 等价于:_

```python
UserInDB(
    username = user_dict["username"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    disabled = user_dict["disabled"],
    hashed_password = user_dict["hashed_password"],
)
```

## 3. 返回 token

`token` 端点的响应必须是一个 JSON 对象.

它应该有一个 `token_type`. 在我们的例子中, 由于我们使用 "Bearer" 令牌, 令牌类型应该是 "`bearer`".

它应该有一个 `access_token`, 包含我们的访问令牌的字符串.

对于这个简单的示例, 我们将完全不安全, 并返回相同的 `username` 作为令牌.

提示

在下一章中, 你将看到一个真正的安全实现, 使用密码哈希和 JWT 令牌.

但现在, 让我们专注于我们需要的具体细节.

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, HTTPException 和 status
from fastapi import Depends, FastAPI, HTTPException, status
# 从 fastapi.security 导入 OAuth2PasswordBearer 和 OAuth2PasswordRequestForm, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建伪造的用户数据库, 用于演示
# 在实际应用中, 这应该是一个真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",           # 用户名
        "full_name": "John Doe",          # 全名
        "email": "johndoe@example.com",   # 电子邮件
        "hashed_password": "fakehashedsecret",  # 哈希后的密码
        "disabled": False,                # 是否禁用
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,  # 这个用户被禁用了
    },
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个伪造的密码哈希函数
# 在实际应用中, 应该使用真正的密码哈希库, 如 passlib
def fake_hash_password(password: str):
    # 简单地在密码前添加 "fakehashed" 前缀
    return "fakehashed" + password

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义 UserInDB 数据模型, 继承自 User
# 这个模型包含数据库中存储的用户的所有信息, 包括哈希后的密码
class UserInDB(User):
    hashed_password: str  # 哈希后的密码, 必填字段

# 定义从数据库获取用户的函数
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 对象, 使用 **user_dict 解包字典作为参数
        return UserInDB(**user_dict)

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
# 这个例子中没有提供任何安全性, 仅仅用于演示
def fake_decode_token(token):
    # 这完全不提供任何安全性
    # 请查看下一个版本
    # 直接使用 token 作为 username 从数据库获取用户
    user = get_user(fake_users_db, token)
    return user

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 如果用户不存在
    if not user:
        # 抛出 HTTP 401 未授权异常
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,  # 401 未授权状态码
            detail="Invalid authentication credentials",  # 错误详情: 无效的认证凭据
            headers={"WWW-Authenticate": "Bearer"},  # WWW-Authenticate 头, 告诉客户端使用 Bearer token
        )
    # 返回用户对象
    return user

# 定义 get_current_active_user 依赖函数
# current_user 参数通过 Depends(get_current_user) 自动注入
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果当前用户被禁用
    if current_user.disabled:
        # 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Inactive user")  # 400 错误, 非活动用户
    # 返回当前用户
    return current_user

# 定义一个 POST 路由操作, 路径为 /token
# 这是 OAuth2 密码流的标准 token 端点
# form_data 参数通过 Depends() 自动注入, 类型为 OAuth2PasswordRequestForm
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    # 从数据库中获取用户数据, 使用表单中的 username
    user_dict = fake_users_db.get(form_data.username)
    # 如果用户不存在
    if not user_dict:
        # 抛出 HTTP 400 异常, 提示用户名或密码不正确
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    # 创建 UserInDB 对象, 解包 user_dict
    user = UserInDB(**user_dict)
    # 对用户输入的密码进行哈希
    hashed_password = fake_hash_password(form_data.password)
    # 检查哈希后的密码是否与数据库中的密码匹配
    if not hashed_password == user.hashed_password:
        # 如果不匹配, 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    # 返回 access_token 和 token_type
    # access_token 是用户的 username (在实际应用中应该是 JWT token)
    # token_type 是 "bearer"
    return {"access_token": user.username, "token_type": "bearer"}

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_active_user) 依赖注入自动获取
# 这确保了只有活动的已认证用户才能访问这个端点
@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户信息
    return current_user
```

提示

根据规范, 你应该返回一个包含 `access_token` 和 `token_type` 的 JSON, 与此示例相同.

这是你必须在代码中自己做的事情, 并确保你使用这些 JSON 键.

这几乎是你必须记住正确做的唯一事情, 以符合规范.

对于其余部分, FastAPI 为你处理.

## 4. 更新依赖

现在我们将更新我们的依赖.

我们想要获取 `current_user`, 仅当此用户处于活动状态时.

因此, 我们创建一个额外的依赖 `get_current_active_user`, 它依次使用 `get_current_user` 作为依赖.

这两个依赖都会在用户不存在或处于非活动状态时返回 HTTP 错误.

因此, 在我们的端点中, 我们只有在用户存在, 已正确通过身份验证且处于活动状态时才会获得用户:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, HTTPException 和 status
from fastapi import Depends, FastAPI, HTTPException, status
# 从 fastapi.security 导入 OAuth2PasswordBearer 和 OAuth2PasswordRequestForm, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建伪造的用户数据库, 用于演示
# 在实际应用中, 这应该是一个真实的数据库
fake_users_db = {
    "johndoe": {
        "username": "johndoe",           # 用户名
        "full_name": "John Doe",          # 全名
        "email": "johndoe@example.com",   # 电子邮件
        "hashed_password": "fakehashedsecret",  # 哈希后的密码
        "disabled": False,                # 是否禁用
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,  # 这个用户被禁用了
    },
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个伪造的密码哈希函数
# 在实际应用中, 应该使用真正的密码哈希库, 如 passlib
def fake_hash_password(password: str):
    # 简单地在密码前添加 "fakehashed" 前缀
    return "fakehashed" + password

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义 UserInDB 数据模型, 继承自 User
# 这个模型包含数据库中存储的用户的所有信息, 包括哈希后的密码
class UserInDB(User):
    hashed_password: str  # 哈希后的密码, 必填字段

# 定义从数据库获取用户的函数
def get_user(db, username: str):
    # 如果用户名存在于数据库中
    if username in db:
        # 获取用户字典
        user_dict = db[username]
        # 返回 UserInDB 对象, 使用 **user_dict 解包字典作为参数
        return UserInDB(**user_dict)

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
# 这个例子中没有提供任何安全性, 仅仅用于演示
def fake_decode_token(token):
    # 这完全不提供任何安全性
    # 请查看下一个版本
    # 直接使用 token 作为 username 从数据库获取用户
    user = get_user(fake_users_db, token)
    return user

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 如果用户不存在
    if not user:
        # 抛出 HTTP 401 未授权异常
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,  # 401 未授权状态码
            detail="Invalid authentication credentials",  # 错误详情: 无效的认证凭据
            headers={"WWW-Authenticate": "Bearer"},  # WWW-Authenticate 头, 告诉客户端使用 Bearer token
        )
    # 返回用户对象
    return user

# 定义 get_current_active_user 依赖函数
# current_user 参数通过 Depends(get_current_user) 自动注入
# 这个依赖依赖于 get_current_user, 形成依赖链
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    # 如果当前用户被禁用
    if current_user.disabled:
        # 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Inactive user")  # 400 错误, 非活动用户
    # 返回当前用户
    return current_user

# 定义一个 POST 路由操作, 路径为 /token
# 这是 OAuth2 密码流的标准 token 端点
# form_data 参数通过 Depends() 自动注入, 类型为 OAuth2PasswordRequestForm
@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    # 从数据库中获取用户数据, 使用表单中的 username
    user_dict = fake_users_db.get(form_data.username)
    # 如果用户不存在
    if not user_dict:
        # 抛出 HTTP 400 异常, 提示用户名或密码不正确
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    # 创建 UserInDB 对象, 解包 user_dict
    user = UserInDB(**user_dict)
    # 对用户输入的密码进行哈希
    hashed_password = fake_hash_password(form_data.password)
    # 检查哈希后的密码是否与数据库中的密码匹配
    if not hashed_password == user.hashed_password:
        # 如果不匹配, 抛出 HTTP 400 异常
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    # 返回 access_token 和 token_type
    # access_token 是用户的 username (在实际应用中应该是 JWT token)
    # token_type 是 "bearer"
    return {"access_token": user.username, "token_type": "bearer"}

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_active_user) 依赖注入自动获取
# 这确保了只有活动的已认证用户才能访问这个端点
@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    # 返回当前用户信息
    return current_user
```

信息

我们在这里返回的带有值 `Bearer` 的附加头 `WWW-Authenticate` 也是规范的一部分.

任何 HTTP (错误) 状态码 401 "UNAUTHORIZED" 都应该返回一个 `WWW-Authenticate` 头.

在 bearer 令牌 (我们的例子) 的情况下, 该头的值应该是 `Bearer`.

你实际上可以跳过那个额外的头, 它仍然可以工作.

但这里提供它是为了符合规范.

此外, 可能有一些工具期望并使用它 (现在或将来), 这可能对你或你的用户有用, 现在或将来.

这就是标准的好处...

## 5. 实际操作

打开交互式文档: http://127.0.0.1:8000/docs.

### 5.1 身份验证

点击 "Authorize" 按钮.

使用凭据:

用户: `johndoe`

密码: `secret`

在系统中进行身份验证后, 你将看到:

### 5.2 获取你自己的用户数据

现在使用路径为 `/users/me` 的 `GET` 操作.

你将获得你的用户数据, 如:

```json
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false,
  "hashed_password": "fakehashedsecret"
}
```

如果你点击锁图标并注销, 然后再次尝试相同的操作, 你将获得 HTTP 401 错误:

```json
{
  "detail": "Not authenticated"
}
```

### 5.3 非活动用户

现在尝试使用非活动用户, 使用以下凭据进行身份验证:

用户: `alice`

密码: `secret2`

并尝试使用路径为 `/users/me` 的 `GET` 操作.

你将获得 "Inactive user" 错误, 如:

```json
{
  "detail": "Inactive user"
}
```

## 6. 总结

你现在拥有了为你的 API 实现基于 `username` 和 `password` 的完整安全系统的工具.

使用这些工具, 你可以使安全系统与任何数据库以及任何用户或数据模型兼容.

唯一缺少的细节是它实际上还不 "安全".

在下一章中, 你将看到如何使用安全的密码哈希库和 JWT 令牌.
