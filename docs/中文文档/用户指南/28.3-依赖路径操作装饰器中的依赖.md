# 依赖 - 路径操作装饰器中的依赖

在某些情况下, 你在 _路径操作函数_ 中并不真正需要依赖项的返回值。

或者依赖项不返回值。

但你仍然需要它被执行/解析。

对于这些情况, 你不必使用 `Depends` 声明 _路径操作函数_ 参数, 而是可以将依赖项 `list` 添加到 _路径操作装饰器_ 中。

## 1. 将 `dependencies` 添加到 _路径操作装饰器_

_路径操作装饰器_ 接收一个可选参数 `dependencies`。

它应该是一个由 `Depends()` 组成的 `list`:

### Python 3.9+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends, FastAPI, Header 和 HTTPException
# Depends: 用于声明依赖项
# FastAPI: 应用主类
# Header: 用于获取 Header 参数
# HTTPException: 用于抛出 HTTP 异常
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 verify_token 依赖函数
# x_token: 从 Header 中获取的 X-Token 参数, 类型为字符串
async def verify_token(x_token: Annotated[str, Header()]):
    # 如果 token 不等于预设的密钥
    if x_token != "fake-super-secret-token":
        # 抛出 HTTP 400 异常, 表示 X-Token header 无效
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# x_key: 从 Header 中获取的 X-Key 参数, 类型为字符串
async def verify_key(x_key: Annotated[str, Header()]):
    # 如果 key 不等于预设的密钥
    if x_key != "fake-super-secret-key":
        # 抛出 HTTP 400 异常, 表示 X-Key header 无效
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值 (虽然在这个装饰器用法中不会被使用)
    return x_key

# 定义 GET 路径操作 /items/
# dependencies 参数接收一个依赖项列表
# 这些依赖项会在路径操作函数执行之前被调用
# 但它们的返回值不会传递给路径操作函数
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 返回一个包含两个项目的列表
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### Python 3.8+

```python
# 从 fastapi 导入依赖项相关类
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated (Python 3.8 需要使用 typing_extensions)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 verify_token 依赖函数
# 验证请求头中的 X-Token 是否有效
async def verify_token(x_token: Annotated[str, Header()]):
    # 检查 token 是否匹配预设值
    if x_token != "fake-super-secret-token":
        # 如果不匹配, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# 验证请求头中的 X-Key 是否有效
async def verify_key(x_key: Annotated[str, Header()]):
    # 检查 key 是否匹配预设值
    if x_key != "fake-super-secret-key":
        # 如果不匹配, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 定义 GET 路径操作 /items/
# 使用 dependencies 参数声明依赖项列表
# 这些依赖项会在请求处理前执行, 用于验证权限
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 返回项目列表
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**提示**

如果可能, 尽量使用 `Annotated` 版本。

### Python 3.8+ 不使用 Annotated

```python
# 从 fastapi 导入依赖项相关类
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 verify_token 依赖函数
# x_token: 字符串类型的 Header 参数, 使用默认的 Header() 获取
async def verify_token(x_token: str = Header()):
    # 验证 token 是否有效
    if x_token != "fake-super-secret-token":
        # token 无效时抛出异常
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# x_key: 字符串类型的 Header 参数
async def verify_key(x_key: str = Header()):
    # 验证 key 是否有效
    if x_key != "fake-super-secret-key":
        # key 无效时抛出异常
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 定义 GET 路径操作 /items/
# 在装饰器中声明依赖项, 而不是在函数参数中
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 返回项目数据
    return [{"item": "Foo"}, {"item": "Bar"}]
```

这些依赖项将以与普通依赖项相同的方式被执行/解析。但它们的返回值 (如果有的话) 不会传递给你的 _路径操作函数_。

**提示**

一些编辑器会检查未使用的函数参数, 并将它们显示为错误。

在 _路径操作装饰器_ 中使用这些 `dependencies`, 可以确保依赖项被执行, 同时避免编辑器/工具的错误提示。

这也有助于避免新开发人员的困惑, 他们看到代码中有未使用的参数, 可能会认为这是不必要的。

**信息**

在这个示例中, 我们使用自定义的 headers `X-Key` 和 `X-Token`。

但在实际情况下, 当实现安全性时, 使用集成的安全工具 (下一章) 会获得更多好处。

## 2. 依赖项错误和返回值

你可以使用与通常相同的依赖项 _函数_。

### 2.1 依赖项要求

它们可以声明请求要求 (例如 headers) 或其他子依赖项:

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: Annotated[str, Header()]):
    # 检查 token 是否等于预设值
    if x_token != "fake-super-secret-token":
        # 如果不等于, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
async def verify_key(x_key: Annotated[str, Header()]):
    # 检查 key 是否等于预设值
    if x_key != "fake-super-secret-key":
        # 如果不等于, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 定义路径操作, 使用 dependencies 参数声明依赖项列表
# 这些依赖项会在处理请求前被调用
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 返回项目列表
    return [{"item": "Foo"}, {"item": "Bar"}]
```

#### Python 3.8+

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: Annotated[str, Header()]):
    # 验证 token
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
async def verify_key(x_key: Annotated[str, Header()]):
    # 验证 key
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

# 定义路径操作
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**提示**

如果可能, 尽量使用 `Annotated` 版本。

#### Python 3.8+ 不使用 Annotated

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
# 使用默认的 Header() 参数获取请求头
async def verify_token(x_token: str = Header()):
    # 验证 token 是否有效
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
async def verify_key(x_key: str = Header()):
    # 验证 key 是否有效
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

# 定义路径操作, 声明依赖项列表
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### 2.2 抛出异常

这些依赖项可以 `raise` 异常, 与普通依赖项相同:

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖函数
# 用于验证请求头中的 token
async def verify_token(x_token: Annotated[str, Header()]):
    # 检查 token 是否匹配
    if x_token != "fake-super-secret-token":
        # 不匹配时抛出异常, 请求将被中断
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖函数
# 用于验证请求头中的 key
async def verify_key(x_key: Annotated[str, Header()]):
    # 检查 key 是否匹配
    if x_key != "fake-super-secret-key":
        # 不匹配时抛出异常
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key (虽然在这个用法中不会被使用)
    return x_key

# 定义路径操作
# 在装饰器中使用 dependencies 参数
# 依赖项抛出异常时, 路径操作函数不会被执行
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 只有当所有依赖项都通过验证时才会执行
    return [{"item": "Foo"}, {"item": "Bar"}]
```

#### Python 3.8+

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: Annotated[str, Header()]):
    # 验证 token, 无效时抛出异常
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
async def verify_key(x_key: Annotated[str, Header()]):
    # 验证 key, 无效时抛出异常
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

# 定义路径操作
# 依赖项验证失败时, 会抛出异常并中断请求
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**提示**

如果可能, 尽量使用 `Annotated` 版本。

#### Python 3.8+ 不使用 Annotated

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: str = Header()):
    # 验证 token, 失败时抛出异常
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
async def verify_key(x_key: str = Header()):
    # 验证 key, 失败时抛出异常
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

# 定义路径操作
# 依赖项在装饰器中声明, 可以抛出异常来中断请求
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### 2.3 返回值

它们可以返回值也可以不返回值, 这些值不会被使用。

因此, 你可以重用你已经在其他地方使用的普通依赖项 (返回值的依赖项), 即使该值不会被使用, 依赖项也会被执行:

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 verify_token 依赖
# 这个依赖不返回值, 只进行验证
async def verify_token(x_token: Annotated[str, Header()]):
    # 验证 token
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖
# 这个依赖返回值, 但在装饰器中使用时返回值会被忽略
async def verify_key(x_key: Annotated[str, Header()]):
    # 验证 key
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key, 但在 dependencies 参数中使用时不会被传递给路径操作函数
    return x_key

# 定义路径操作
# 即使 verify_key 返回了值, 这个值也不会被传递给 read_items 函数
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    # 这里无法访问 verify_token 或 verify_key 的返回值
    # 但依赖项仍然会被执行, 可以利用它们进行验证或其他操作
    return [{"item": "Foo"}, {"item": "Bar"}]
```

#### Python 3.8+

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
# 返回值在装饰器依赖中不会被使用
async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回值, 但会被忽略
    return x_key

# 定义路径操作
# 依赖项被执行, 但返回值不会传递给路径操作函数
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**提示**

如果可能, 尽量使用 `Annotated` 版本。

#### Python 3.8+ 不使用 Annotated

```python
# 从 fastapi 导入所需组件
from fastapi import Depends, FastAPI, Header, HTTPException

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 token 验证依赖
async def verify_token(x_token: str = Header()):
    # 验证 token, 失败时抛出异常
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 key 验证依赖
# 返回值在装饰器依赖中不会被使用
async def verify_key(x_key: str = Header()):
    # 验证 key, 失败时抛出异常
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回值, 但会被忽略
    return x_key

# 定义路径操作
# 依赖项被执行, 但返回值不会传递给路径操作函数
@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

## 3. 为一组 _路径操作_ 声明依赖项

稍后, 在阅读如何构建更大的应用程序 (Bigger Applications - Multiple Files), 可能包含多个文件时, 你将学习如何为一组 _路径操作_ 声明单个 `dependencies` 参数。

## 4. 全局依赖项

接下来我们将看到如何将依赖项添加到整个 `FastAPI` 应用程序, 以便它们应用于每个 _路径操作_。
