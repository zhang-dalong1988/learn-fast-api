# 29.1 安全 - 第一步

让我们想象一下, 你的 __backend__ API 在某个域中.

而你的 __frontend__ 在另一个域中, 或在同一域的不同路径中 (或在移动应用程序中).

并且你想让前端有一种使用 __username__ 和 __password__ 与后端进行身份验证的方法.

我们可以使用 __OAuth2__ 和 __FastAPI__ 来构建它.

但是, 让我们为你节省阅读完整冗长规范的时间, 只是为了找到你需要的那小部分信息.

让我们使用 __FastAPI__ 提供的工具来处理安全性.

## 1. 它的外观

让我们先使用代码并看看它是如何工作的, 然后我们将回来了解发生了什么.

## 2. 创建 `main.py`

将示例复制到文件 `main.py` 中:

Python 3.9+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ non-Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ (without Annotated)

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# token: str = Depends(oauth2_scheme) 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    # 返回包含 token 的字典
    return {"token": token}
```

## 3. 运行它

当你运行 `pip install "fastapi[standard]"` 命令时, `python-multipart` 包会随 __FastAPI__ 自动安装.

但是, 如果你使用 `pip install fastapi` 命令, 默认情况下不包含 `python-multipart` 包.

要手动安装它, 请确保你创建了一个虚拟环境, 激活它, 然后使用以下命令安装:

```bash
# 安装 python-multipart 包, 用于处理表单数据
$ pip install python-multipart
```

这是因为 __OAuth2__ 使用 "form data" 来发送 `username` 和 `password`.

使用以下命令运行示例:

```bash
# 使用 fastapi dev 命令启动开发服务器
$ fastapi dev main.py

# Uvicorn 服务器在 http://127.0.0.1:8000 上运行 (按 CTRL+C 退出)
<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

## 4. 检查它

转到交互式文档: http://127.0.0.1:8000/docs.

你会看到类似这样的内容:

![Image 1](https://fastapi.tiangolo.com/img/tutorial/security/image01.png)

### 4.1 授权按钮!

你已经有了一个闪亮的新 "Authorize" 按钮.

并且你的 _path operation_ 右上角有一个小锁, 你可以点击它.

如果你点击它, 你会有一个小授权表单来输入 `username` 和 `password` (以及其他可选字段):

![Image 2](https://fastapi.tiangolo.com/img/tutorial/security/image02.png)

注意, 你在表单中输入什么并不重要, 它还不会工作. 但我们会实现的.

当然, 这不是最终用户的前端, 但它是一个很好的自动工具, 可以交互式地记录所有你的 API.

前端团队 (也可以是你自己) 可以使用它.

第三方应用程序和系统可以使用它.

你也可以自己使用它来调试, 检查和测试同一个应用程序.

## 5. `password` 流程

现在让我们回顾一下并理解那是什么.

`password` "flow" 是 OAuth2 中定义的处理安全性和身份验证的方法 ("flows") 之一.

OAuth2 的设计使得后端或 API 可以独立于验证用户的服务器.

但在这种情况下, 同一个 __FastAPI__ 应用程序将处理 API 和身份验证.

所以, 让我们从这个简化的角度来回顾它:

- 用户在前端输入 `username` 和 `password`, 然后按 `Enter`.
- 前端 (在用户的浏览器中运行) 将该 `username` 和 `password` 发送到我们 API 中的特定 URL (使用 `tokenUrl="token"` 声明).
- API 检查该 `username` 和 `password`, 并响应一个 "token" (我们还没有实现其中的任何部分).
  - "token" 只是一个包含一些内容的字符串, 我们可以稍后用它来验证此用户.
  - 通常, token 被设置为在一段时间后过期.
    - 因此, 用户必须在稍后的某个时间再次登录.
    - 并且如果 token 被盗, 风险就更小. 它不像一个永久密钥, 将永远有效 (在大多数情况下).
- 前端将 token 暂时存储在某处.
- 用户在前端中点击以转到前端 Web 应用程序的另一个部分.
- 前端需要从 API 获取更多数据.
  - 但它需要对该特定端点进行身份验证.
  - 因此, 为了与我们的 API 进行身份验证, 它发送一个 `Authorization` header, 值为 `Bearer` 加上 token.
  - 如果 token 包含 `foobar`, 则 `Authorization` header 的内容将是: `Bearer foobar`.

## 6. __FastAPI__ 的 `OAuth2PasswordBearer`

__FastAPI__ 提供了几个工具, 在不同的抽象级别, 来实现这些安全特性.

在这个例子中, 我们将使用 __OAuth2__, 使用 __Password__ 流程, 使用 __Bearer__ token. 我们使用 `OAuth2PasswordBearer` 类来做到这一点.

提示, "bearer" token 不是唯一的选择.

但它是我们用例的最佳选择.

对于大多数用例来说, 它可能是最好的, 除非你是一个 OAuth2 专家, 并且确切地知道为什么有另一个选项更适合你的需求.

在这种情况下, __FastAPI__ 还为你提供了构建它的工具.

当我们创建 `OAuth2PasswordBearer` 类的实例时, 我们传入 `tokenUrl` 参数. 此参数包含客户端 (在用户浏览器中运行的前端) 将用于发送 `username` 和 `password` 以获取 token 的 URL.

Python 3.9+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ non-Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ (without Annotated)

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# token: str = Depends(oauth2_scheme) 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    # 返回包含 token 的字典
    return {"token": token}
```

提示, 这里 `tokenUrl="token"` 指的是我们尚未创建的相对 URL `token`. 由于它是一个相对 URL, 因此它等效于 `./token`.

因为我们使用相对 URL, 如果你的 API 位于 `https://example.com/`, 那么它将引用 `https://example.com/token`. 但如果你的 API 位于 `https://example.com/api/v1/`, 那么它将引用 `https://example.com/api/v1/token`.

使用相对 URL 很重要, 可以确保你的应用程序即使在诸如 Behind a Proxy 之类的高级用例中也能继续工作.

此参数不会创建该端点 / _path operation_, 而是声明 URL `/token` 将是客户端用于获取 token 的 URL. 该信息在 OpenAPI 中使用, 然后在交互式 API 文档系统中使用.

我们很快也会创建实际的路径操作.

提示, 如果你是一个非常严格的 "Pythonista", 你可能会不喜欢参数名称 `tokenUrl` 而不是 `token_url` 的风格.

这是因为它使用与 OpenAPI 规范相同的名称. 因此, 如果你需要调查有关这些安全方案的更多信息, 你可以直接复制并粘贴它以查找有关它的更多信息.

`oauth2_scheme` 变量是 `OAuth2PasswordBearer` 的实例, 但它也是一个 "callable".

它可以被调用为:

```python
# oauth2_scheme 可以像函数一样调用, 传入参数
oauth2_scheme(some, parameters)
```

因此, 它可以与 `Depends` 一起使用.

### 6.1 使用它

现在你可以通过 `Depends` 在依赖项中传递该 `oauth2_scheme`.

Python 3.9+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ non-Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ (without Annotated)

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# token: str = Depends(oauth2_scheme) 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    # 返回包含 token 的字典
    return {"token": token}
```

此依赖项将提供一个 `str`, 该值分配给 _路径操作函数_ 的参数 `token`.

__FastAPI__ 将知道它可以使用此依赖项在 OpenAPI 架构 (和自动 API 文档) 中定义 "安全方案".

技术细节, __FastAPI__ 将知道它可以使用在依赖项中声明的类 `OAuth2PasswordBearer` 在 OpenAPI 中定义安全方案, 因为它继承自 `fastapi.security.oauth2.OAuth2`, 而 `fastapi.security.oauth2.OAuth2` 又继承自 `fastapi.security.base.SecurityBase`.

所有与 OpenAPI (和自动 API 文档) 集成的安全工具都继承自 `SecurityBase`, 这就是 __FastAPI__ 如何知道如何在 OpenAPI 中集成它们.

## 7. 它的作用

它将在请求中查找该 `Authorization` header, 检查值是否为 `Bearer` 加上一些 token, 并将 token 作为 `str` 返回.

如果它没有看到 `Authorization` header, 或者值没有 `Bearer` token, 它将直接响应 401 状态代码错误 (`UNAUTHORIZED`).

你甚至不需要检查 token 是否存在以返回错误. 你可以确定, 如果你的函数被执行, 它将在该 token 中有一个 `str`.

你可以在交互式文档中尝试:

![Image 3](https://fastapi.tiangolo.com/img/tutorial/security/image03.png)

我们还没有验证 token 的有效性, 但这已经是一个开始了.

## 8. 总结

因此, 在只需 3 或 4 行额外代码中, 你已经有了一些基本形式的安全性.
