# 请求体 - 嵌套模型

借助 **FastAPI**, 你可以定义、验证、文档化和使用任意深度嵌套的模型 (得益于 Pydantic)。

## 10.1 List 字段

你可以将某个属性定义为子类型. 例如, 一个 Python `list`:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

这将使 `tags` 成为一个列表, 虽然它没有声明列表元素的类型。

## 10.2 带类型参数的 List 字段

但是 Python 有一种特定的方式来声明带有内部类型的列表, 或者叫 "类型参数":

### 从 typing 导入 `List`

在 Python 3.9 及以上版本中, 你可以使用标准的 `list` 来声明这些类型注解, 正如我们将在下面看到的那样。

但在 Python 3.9 之前的版本 (3.6 及以上), 你首先需要从 Python 标准库的 `typing` 模块中导入 `List`:

#### Python 3.8+

```python
from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### 声明带有类型参数的 `list`

要声明具有类型参数 (内部类型) 的类型, 比如 `list`, `dict`, `tuple`:

- 如果你使用的 Python 版本低于 3.9, 从 `typing` 模块导入它们的等价版本
- 使用方括号 `[` 和 `]` 将内部类型作为 "类型参数" 传递

在 Python 3.9 中, 它会是:

```python
my_list: list[str]
```

在 Python 3.9 之前的版本中, 它会是:

```python
from typing import List

my_list: List[str]
```

这些都是 Python 类型声明的标准语法。

对具有内部类型的模型属性使用相同的标准语法。

因此, 在我们的例子中, 我们可以让 `tags` 明确成为 "字符串列表":

#### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.8+

```python
from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

## 10.3 Set 类型

但是当我们仔细考虑时, 我们意识到标签不应该重复, 它们应该是唯一的字符串。

而 Python 有一个特殊的数据类型用于存储唯一项的集合, 那就是 `set`。

然后我们可以将 `tags` 声明为字符串集合:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.8+

```python
from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

这样, 即使你收到包含重复数据的请求, 它也会被转换为唯一项的集合。

并且每当你输出该数据时, 即使源数据中有重复项, 它也会作为唯一项的集合输出。

它也会被相应地注解/文档化。

## 10.4 嵌套模型

Pydantic 模型的每个属性都有一个类型。

但是该类型本身可以是另一个 Pydantic 模型。

因此, 你可以声明具有特定属性名称、类型和验证的深度嵌套 JSON "对象"。

所有这些, 可以任意嵌套。

### 定义子模型

例如, 我们可以定义一个 `Image` 模型:

#### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


# 定义 Image 模型
class Image(BaseModel):
    url: str
    name: str


# 定义 Item 模型, 包含 Image 作为嵌套模型
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None  # Image 是可选的嵌套模型


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.8+

```python
from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### 将子模型用作类型

然后我们可以将其用作属性的类型:

#### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

#### Python 3.8+

```python
from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Image(BaseModel):
    url: str
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

这意味着 **FastAPI** 将期望类似于以下的请求体:

```json
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
```

同样, 仅通过这样的声明, 使用 **FastAPI** 你可以获得:

- 编辑器支持 (自动补全等), 即使是嵌套模型
- 数据转换
- 数据验证
- 自动文档

## 10.5 特殊类型和验证

除了普通的单一类型如 `str`, `int`, `float` 等, 你还可以使用更复杂的、继承自 `str` 的单一类型。

要查看你拥有的所有选项, 请查看 Pydantic 的类型概述。你将在下一章看到一些示例。

例如, 在 `Image` 模型中我们有一个 `url` 字段, 我们可以将它声明为 Pydantic 的 `HttpUrl` 实例而不是 `str`:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl  # 使用 HttpUrl 类型而不是 str
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.8+

```python
from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

字符串将被检查为有效的 URL, 并在 JSON Schema / OpenAPI 中相应地记录。

## 10.6 带有子模型列表的属性

你还可以将 Pydantic 模型用作 `list`, `set` 等的子类型:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None  # Image 模型的列表


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

### Python 3.8+

```python
from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

这将期望 (转换、验证、文档化等) 类似于以下的 JSON 请求体:

```json
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}
```

> **提示**
>
> 注意 `images` 键现在包含一个 image 对象列表。

## 10.7 深度嵌套模型

你可以定义任意深度嵌套的模型:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None  # Item 包含 Image 列表


class Offer(BaseModel):
    name: str
    description: str | None = None
    price: float
    items: list[Item]  # Offer 包含 Item 列表


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
```

### Python 3.9+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: set[str] = set()
    images: Union[list[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
```

### Python 3.8+

```python
from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: List[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
```

> **提示**
>
> 注意 `Offer` 包含一个 `Item` 列表, 而 `Item` 又包含一个可选的 `Image` 列表。

## 10.8 纯列表请求体

如果你期望的 JSON 请求体的顶层值是一个 JSON `array` (一个 Python `list`), 你可以在函数参数中声明类型, 就像在 Pydantic 模型中一样:

或者在 Python 3.9 及以上版本中:

就像这样:

### Python 3.9+

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):  # 直接接收 Image 列表
    return images
```

### Python 3.8+

```python
from typing import List

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: List[Image]):
    return images
```

## 10.9 到处都有编辑器支持

你在任何地方都能获得编辑器支持。

即使是列表内部的项目:

![编辑器支持](https://fastapi.tiangolo.com/img/tutorial/body-nested-models/image01.png)

如果你直接使用 `dict` 而不是 Pydantic 模型, 你无法获得这种编辑器支持。

但你也不必担心它们, 传入的字典会自动转换, 你的输出也会自动转换为 JSON。

## 10.10 任意 `dict` 请求体

你还可以将请求体声明为 `dict`, 具有某种类型的键和某种其他类型的值。

这样, 你不必事先知道有效的字段/属性名称 (就像使用 Pydantic 模型那样)。

如果你想要接收你不知道的键, 这将很有用。

---

另一个有用的案例是当你想要使用其他类型的键 (例如 `int`)。

这就是我们要在这里看到的。

在这种情况下, 你会接受任何 `dict`, 只要它具有带 `float` 值的 `int` 键:

### Python 3.9+

```python
from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):  # 键是 int, 值是 float
    return weights
```

### Python 3.8+

```python
from typing import Dict

from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: Dict[int, float]):
    return weights
```

> **提示**
>
> 请记住, JSON 只支持 `str` 作为键。
>
> 但是 Pydantic 具有自动数据转换功能。
>
> 这意味着, 即使你的 API 客户端只能发送字符串作为键, 只要这些字符串包含纯整数, Pydantic 就会转换并验证它们。
>
> 并且你作为 `weights` 接收到的 `dict` 实际上将具有 `int` 键和 `float` 值。

## 10.11 总结

借助 **FastAPI**, 你拥有 Pydantic 模型提供的最大灵活性, 同时保持代码简单、简洁和优雅。

但拥有所有好处:

- 编辑器支持 (到处都有自动补全!)
- 数据转换 (也称为解析/序列化)
- 数据验证
- 模式文档
- 自动文档
