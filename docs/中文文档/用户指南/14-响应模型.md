# 第 14 章 响应模型 - 返回类型

## 1. 基本概念

你可以通过注解路径操作函数的返回类型来声明响应使用的类型。

你可以像在函数参数中声明输入数据那样使用类型注解, 可以使用 Pydantic 模型、列表、字典、标量值(如整数、布尔值等)。

### 1.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必需
    description: str | None = None  # 描述字段, 可选, 默认为 None
    price: float  # 价格字段, 必需
    tax: float | None = None  # 税字段, 可选, 默认为 None
    tags: list[str] = []  # 标签列表, 可选, 默认为空列表


# POST 端点: 创建项目
# 返回类型注解为 Item, 表示返回一个 Item 对象
@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item  # 直接返回传入的 item


# GET 端点: 读取项目列表
# 返回类型注解为 list[Item], 表示返回一个 Item 列表
@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),  # 创建 Portal Gun 项目
        Item(name="Plumbus", price=32.0),     # 创建 Plumbus 项目
    ]
```

### 1.2 Python 3.9+ 示例

```python
from typing import Union  # 导入 Union 类型用于可选字段

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必需
    description: Union[str, None] = None  # 描述字段, 可选(使用 Union 语法)
    price: float  # 价格字段, 必需
    tax: Union[float, None] = None  # 税字段, 可选(使用 Union 语法)
    tags: list[str] = []  # 标签列表, 可选, 默认为空列表


# POST 端点: 创建项目
# 返回类型注解为 Item
@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item  # 返回传入的 item


# GET 端点: 读取项目列表
# 返回类型注解为 list[Item]
@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),  # 创建 Portal Gun 项目
        Item(name="Plumbus", price=32.0),     # 创建 Plumbus 项目
    ]
```

### 1.3 Python 3.8+ 示例

```python
from typing import List, Union  # 导入 List 和 Union 类型

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必需
    description: Union[str, None] = None  # 描述字段, 可选
    price: float  # 价格字段, 必需
    tax: Union[float, None] = None  # 税字段, 可选
    tags: List[str] = []  # 标签列表(使用 List 语法), 可选, 默认为空列表


# POST 端点: 创建项目
@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item


# GET 端点: 读取项目列表
# 返回类型注解为 List[Item]
@app.get("/items/")
async def read_items() -> List[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]
```

## 2. FastAPI 如何使用返回类型

FastAPI 将使用返回类型来:

- **验证返回的数据**
  - 如果数据无效(例如缺少字段), 这意味着你的应用代码有问题, 没有返回应该返回的数据, FastAPI 将返回服务器错误而不是返回错误数据。这样你和你的客户端可以确信他们将接收预期的数据和数据格式。
- 在 OpenAPI 路径操作中添加响应的 **JSON Schema**
  - 这将被用于**自动文档**
  - 它也将被用于自动客户端代码生成工具

但最重要的是:

- 它将**限制和过滤**输出数据, 只保留返回类型中定义的内容
  - 这对于**安全性**特别重要, 我们将在下面看到更多示例

## 3. response_model 参数

在某些情况下, 你需要或想要返回一些与类型声明不完全相同的数据。

例如, 你可能想要**返回一个字典**或数据库对象, 但**将其声明为 Pydantic 模型**。这样 Pydantic 模型将为你返回的对象(例如字典或数据库对象)完成所有数据文档、验证等工作。

如果你添加了返回类型注解, 工具和编辑器会报错(正确地)告诉你, 函数返回的类型(例如 dict)与你声明的类型(例如 Pydantic 模型)不同。

在这些情况下, 你可以使用路径操作装饰器参数 `response_model` 代替返回类型。

你可以在任何路径操作中使用 `response_model` 参数:

- `@app.get()`
- `@app.post()`
- `@app.put()`
- `@app.delete()`
- 等等

### 3.1 Python 3.10+ 示例

```python
from typing import Any  # 导入 Any 类型, 表示任意类型

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str  # 名称字段, 必需
    description: str | None = None  # 描述字段, 可选
    price: float  # 价格字段, 必需
    tax: float | None = None  # 税字段, 可选
    tags: list[str] = []  # 标签列表, 可选


# POST 端点: 使用 response_model 参数指定响应模型
# 虽然 return type 注解为 Any, 但 response_model=Item 会将返回数据转换为 Item 格式
@app.post("/items/", response_model=Item)
async def create_item(item: Item) -> Any:
    return item  # 返回 Item 对象


# GET 端点: 返回 Item 列表
# response_model=list[Item] 会将字典列表转换为 Item 对象列表
@app.get("/items/", response_model=list[Item])
async def read_items() -> Any:
    return [
        {"name": "Portal Gun", "price": 42.0},  # 返回字典, FastAPI 会自动转换为 Item
        {"name": "Plumbus", "price": 32.0},     # 返回字典, FastAPI 会自动转换为 Item
    ]
```

### 3.2 Python 3.9+ 示例

```python
from typing import Any, Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


# 使用 response_model 参数
@app.post("/items/", response_model=Item)
async def create_item(item: Item) -> Any:
    return item


@app.get("/items/", response_model=list[Item])
async def read_items() -> Any:
    return [
        {"name": "Portal Gun", "price": 42.0},
        {"name": "Plumbus", "price": 32.0},
    ]
```

### 3.3 Python 3.8+ 示例

```python
from typing import Any, List, Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


# 使用 response_model 参数
@app.post("/items/", response_model=Item)
async def create_item(item: Item) -> Any:
    return item


@app.get("/items/", response_model=List[Item])
async def read_items() -> Any:
    return [
        {"name": "Portal Gun", "price": 42.0},
        {"name": "Plumbus", "price": 32.0},
    ]
```

**注意**

注意 `response_model` 是 "装饰器" 方法(`get`、`post` 等)的参数, 而不是你的路径操作函数的参数。

`response_model` 接收与 Pydantic 模型字段相同的类型, 因此它可以是 Pydantic 模型, 也可以是 Pydantic 模型的 `list`, 例如 `List[Item]`。

FastAPI 将使用这个 `response_model` 来完成所有数据文档、验证等工作, 并**转换和过滤输出数据**以匹配其类型声明。

**提示**

如果你在编辑器、mypy 等中有严格的类型检查, 可以将函数返回类型声明为 `Any`。

这样你告诉编辑器你是有意返回任何类型。但 FastAPI 仍然会使用 `response_model` 进行数据文档、验证、过滤等工作。

### 3.4 response_model 优先级

如果你同时声明了返回类型和 `response_model`, `response_model` 将优先并供 FastAPI 使用。

这样, 即使你返回的类型与响应模型不同, 也可以为函数添加正确的类型注解, 供编辑器和 mypy 等工具使用。并且仍然可以让 FastAPI 使用 `response_model` 进行数据验证、文档等工作。

你也可以使用 `response_model=None` 来禁用该路径操作的响应模型创建, 如果你为不是有效 Pydantic 字段的内容添加类型注解, 可能需要这样做, 你将在下面的部分中看到示例。

## 4. 返回相同的输入数据

这里我们声明一个 `UserIn` 模型, 它将包含明文密码:

### 4.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr  # 导入 EmailStr 用于邮箱验证

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型, 包含密码
class UserIn(BaseModel):
    username: str  # 用户名, 必需
    password: str  # 密码, 必需(明文)
    email: EmailStr  # 邮箱, 必需(会验证邮箱格式)
    full_name: str | None = None  # 全名, 可选


# 创建用户端点
# 警告: 不要在生产环境中这样做!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user  # 直接返回用户, 包括密码
```

### 4.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型
class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


# 创建用户端点
# 警告: 不要在生产环境中这样做!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user
```

**信息**

要使用 `EmailStr`, 首先需要安装 `email-validator`。

确保你创建了一个虚拟环境, 激活它, 然后安装它, 例如:

```bash
$ pip install email-validator
```

或者使用:

```bash
$ pip install "pydantic[email]"
```

我们使用这个模型来声明输入, 并使用相同的模型来声明输出:

### 4.3 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型
class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


# 不要在生产环境中这样做!
# 这个端点会将用户密码包含在响应中
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user
```

### 4.4 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型
class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


# 不要在生产环境中这样做!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user
```

现在, 每当浏览器创建带有密码的用户时, API 将在响应中返回相同的密码。

在这种情况下, 这可能不是问题, 因为是同一个用户发送密码。

但如果我们对另一个路径操作使用相同的模型, 我们可能会将用户密码发送给每个客户端。

**危险**

永远不要存储用户的明文密码或像这样在响应中发送它, 除非你知道所有注意事项并且你知道你在做什么。

## 5. 添加输出模型

我们可以改为创建一个包含明文密码的输入模型和一个不包含密码的输出模型:

### 5.1 Python 3.10+ 示例

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型(包含密码)
class UserIn(BaseModel):
    username: str
    password: str  # 包含密码
    email: EmailStr
    full_name: str | None = None


# 定义用户输出模型(不包含密码)
class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
    # 注意: 没有 password 字段


# 创建用户端点
# 使用 response_model=UserOut, 响应将不包含密码
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user  # 返回包含密码的 user, 但响应会被过滤
```

### 5.2 Python 3.8+ 示例

```python
from typing import Any, Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义用户输入模型
class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


# 定义用户输出模型(不包含密码)
class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


# 创建用户端点
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user
```

在这里, 即使我们的路径操作函数返回的是包含密码的相同输入用户:

### 5.3 完整示例 (Python 3.10+)

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户输入模型(包含密码)
class UserIn(BaseModel):
    username: str
    password: str  # 密码字段
    email: EmailStr
    full_name: str | None = None


# 用户输出模型(不包含密码)
class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
    # 注意: password 字段被排除了


# 创建用户端点
# 虽然函数返回 UserIn(包含密码), 但 response_model=UserOut 会过滤掉密码
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user  # 返回完整的 user 对象
```

### 5.4 完整示例 (Python 3.8+)

```python
from typing import Any, Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户输入模型
class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


# 用户输出模型
class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


# 创建用户端点
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user
```

...我们声明 `response_model` 为我们的模型 `UserOut`, 它不包括密码:

### 5.5 完整示例再次展示 (Python 3.10+)

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str  # 输入包含密码
    email: EmailStr
    full_name: str | None = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
    # 输出不包含密码


# 使用 response_model 参数过滤输出
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user  # FastAPI 会自动过滤掉 password 字段
```

### 5.6 完整示例再次展示 (Python 3.8+)

```python
from typing import Any, Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


# 使用 response_model
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user
```

因此, **FastAPI** 将负责过滤掉输出模型中未声明的所有数据(使用 Pydantic)。

### 5.7 response_model 或返回类型

在这种情况下, 因为两个模型不同, 如果我们将函数返回类型注解为 `UserOut`, 编辑器和工具会抱怨我们返回了无效类型, 因为它们是不同的类。

这就是为什么在这个例子中我们必须在 `response_model` 参数中声明它。

...但继续阅读下面, 看看如何解决这个问题。

## 6. 返回类型和数据过滤

让我们继续前面的例子。我们想要**用一种类型注解函数**, 但我们希望能够从函数返回实际包含**更多数据**的内容。

我们希望 FastAPI 继续使用响应模型**过滤**数据。这样, 即使函数返回更多数据, 响应也只包含响应模型中声明的字段。

在前面的例子中, 因为类是不同的, 我们必须使用 `response_model` 参数。但这也意味着我们无法从编辑器和工具检查函数返回类型获得支持。

但在大多数需要这样做的情况下, 我们只是想要模型**过滤/删除**一些数据, 就像这个例子一样。

在这些情况下, 我们可以使用类和继承来利用函数**类型注解**, 以在编辑器和工具中获得更好的支持, 并且仍然获得 FastAPI **数据过滤**。

### 6.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义基础用户模型(不包含密码)
class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


# 定义用户输入模型, 继承自 BaseUser, 添加密码字段
class UserIn(BaseUser):
    password: str  # 添加密码字段


# 创建用户端点
# 返回类型注解为 BaseUser, 但实际返回 UserIn
# FastAPI 会过滤掉 password 字段
@app.post("/user/")
async def create_user(user: UserIn) -> BaseUser:
    return user  # 返回 UserIn, 但只输出 BaseUser 的字段
```

### 6.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义基础用户模型
class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


# 定义用户输入模型, 继承 BaseUser
class UserIn(BaseUser):
    password: str  # 添加密码字段


# 创建用户端点
@app.post("/user/")
async def create_user(user: UserIn) -> BaseUser:
    return user
```

通过这种方式, 我们获得了工具支持, 从编辑器和 mypy 来看, 这段代码在类型方面是正确的, 但我们也获得了 FastAPI 的数据过滤。

这是如何工作的? 让我们来看看。

### 6.3 类型注解和工具支持

首先让我们看看编辑器、mypy 和其他工具如何看待这个问题。

`BaseUser` 具有基本字段。然后 `UserIn` 继承自 `BaseUser` 并添加 `password` 字段, 因此它将包含两个模型中的所有字段。

我们将函数返回类型注解为 `BaseUser`, 但我们实际返回的是 `UserIn` 实例。

编辑器、mypy 和其他工具不会对此抱怨, 因为在类型方面, `UserIn` 是 `BaseUser` 的子类, 这意味着当期望的是 `BaseUser` 的任何内容时, 它是一个_有效_类型。

### 6.4 FastAPI 数据过滤

现在, 对于 FastAPI, 它将看到返回类型并确保你返回的内容__仅__包含类型中声明的字段。

FastAPI 在内部与 Pydantic 一起做了很多事情, 以确保这些相同的类继承规则不用于返回数据过滤, 否则你最终可能会返回比预期更多的数据。

通过这种方式, 你可以获得两全其美的效果: 具有**工具支持**的类型注解和**数据过滤**。

## 7. 在文档中查看

当你查看自动文档时, 你可以检查输入模型和输出模型都将拥有自己的 JSON Schema:

并且两个模型都将用于交互式 API 文档:

## 8. 其他返回类型注解

在某些情况下, 你可能会返回一些不是有效 Pydantic 字段的内容, 并且你在函数中对其进行注解, 只是为了获得工具(编辑器、mypy 等)提供的支持。

### 8.1 直接返回 Response

最常见的情况是直接返回 Response, 这将在后面的高级文档中解释。

### 8.2 Python 3.8+ 示例

```python
from fastapi import FastAPI, Response
from fastapi.responses import JSONResponse, RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 获取门户端点
# 根据 teleport 参数返回不同的响应
@app.get("/portal")
async def get_portal(teleport: bool = False) -> Response:
    if teleport:
        # 如果 teleport 为 True, 返回重定向响应
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    # 否则返回 JSON 响应
    return JSONResponse(content={"message": "Here's your interdimensional portal."})
```

这个简单的情况由 FastAPI 自动处理, 因为返回类型注解是 `Response` 类(或其子类)。

工具也会很高兴, 因为 `RedirectResponse` 和 `JSONResponse` 都是 `Response` 的子类, 所以类型注解是正确的。

### 8.3 注解 Response 子类

你也可以在类型注解中使用 `Response` 的子类:

### 8.4 Python 3.8+ 示例

```python
from fastapi import FastAPI
from fastapi.responses import RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 传送端点, 返回 RedirectResponse
@app.get("/teleport")
async def get_teleport() -> RedirectResponse:
    return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
```

这也将工作, 因为 `RedirectResponse` 是 `Response` 的子类, FastAPI 将自动处理这个简单的情况。

### 8.5 无效的返回类型注解

但是, 当你返回一些不是有效 Pydantic 类型的其他任意对象(例如数据库对象)并且你在函数中这样注解它时, FastAPI 将尝试从该类型注解创建 Pydantic 响应模型, 并且将失败。

如果你有不同类型之间的联合, 其中一个或多个不是有效的 Pydantic 类型, 也会发生同样的情况, 例如这将失败:

#### 8.5.1 Python 3.10+ 示例

```python
from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 这个端点会失败, 因为返回类型是 Response | dict 的联合类型
@app.get("/portal")
async def get_portal(teleport: bool = False) -> Response | dict:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}
```

#### 8.5.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 这个端点会失败
@app.get("/portal")
async def get_portal(teleport: bool = False) -> Union[Response, dict]:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}
```

...这会失败, 因为类型注解不是 Pydantic 类型, 也不只是单个 `Response` 类或子类, 它是 `Response` 和 `dict` 之间的联合(两者之一)。

### 8.6 禁用响应模型

继续上面的例子, 你可能不想拥有 FastAPI 执行的默认数据验证、文档、过滤等。

但你可能仍然希望在函数中保留返回类型注解, 以从编辑器和类型检查器(例如 mypy)等工具获得支持。

在这种情况下, 你可以通过设置 `response_model=None` 来禁用响应模型生成:

#### 8.6.1 Python 3.10+ 示例

```python
from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 使用 response_model=None 禁用响应模型生成
@app.get("/portal", response_model=None)
async def get_portal(teleport: bool = False) -> Response | dict:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}
```

#### 8.6.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

# 创建 FastAPI 应用实例
app = FastAPI()


# 使用 response_model=None 禁用响应模型
@app.get("/portal", response_model=None)
async def get_portal(teleport: bool = False) -> Union[Response, dict]:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}
```

这将使 FastAPI 跳过响应模型生成, 这样你就可以拥有任何你需要的返回类型注解, 而不会影响你的 FastAPI 应用。

## 9. 响应模型编码参数

你的响应模型可能有默认值, 例如:

### 9.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str  # 名称字段, 必需
    description: str | None = None  # 描述字段, 可选, 默认为 None
    price: float  # 价格字段, 必需
    tax: float = 10.5  # 税字段, 可选, 默认为 10.5
    tags: list[str] = []  # 标签列表, 可选, 默认为空列表


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


# 读取项目端点
# 使用 response_model_exclude_unset=True 排除未设置的字段
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

### 9.2 Python 3.9+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5  # 默认值
    tags: list[str] = []


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


# 使用 response_model_exclude_unset
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

### 9.3 Python 3.8+ 示例

```python
from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5  # 默认税率为 10.5
    tags: List[str] = []  # 默认为空列表


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


# 使用 response_model_exclude_unset 排除未设置的字段
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

说明:

- `description: Union[str, None] = None` (或 Python 3.10 中的 `str | None = None`) 默认值为 `None`
- `tax: float = 10.5` 默认值为 `10.5`
- `tags: List[str] = []` 默认值为空列表: `[]`

但如果它们没有实际存储, 你可能希望从结果中省略它们。

例如, 如果你在 NoSQL 数据库中有许多可选属性的模型, 但你不想发送充满默认值的非常长的 JSON 响应。

### 9.4 使用 response_model_exclude_unset 参数

你可以设置路径操作装饰器参数 `response_model_exclude_unset=True`:

#### 9.4.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5  # 有默认值的字段
    tags: list[str] = []


# 模拟数据库数据
items = {
    "foo": {"name": "Foo", "price": 50.2},  # 没有设置 description, tax, tags
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


# 读取项目端点
# response_model_exclude_unset=True 会排除未显式设置的字段(使用默认值的字段)
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

#### 9.4.2 Python 3.9+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

#### 9.4.3 Python 3.8+ 示例

```python
from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5
    tags: List[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```

这些默认值将不会包含在响应中, 只包含实际设置的值。

因此, 如果你向该路径操作发送 ID 为 `foo` 的项目的请求, 响应(不包括默认值)将是:

```json
{
    "name": "Foo",
    "price": 50.2
}
```

**信息**

在 Pydantic v1 中, 该方法称为 `.dict()`, 在 Pydantic v2 中被弃用(但仍受支持), 并重命名为 `.model_dump()`。

这里的示例使用 `.dict()` 以与 Pydantic v1 兼容, 但如果你可以使用 Pydantic v2, 应该使用 `.model_dump()`。

**信息**

你也可以使用:

- `response_model_exclude_defaults=True`
- `response_model_exclude_none=True`

如 Pydantic 文档中关于 `exclude_defaults` 和 `exclude_none` 所述。

#### 9.4.4 具有默认值字段值的数据

但是, 如果你的数据对于具有默认值的模型字段有值, 例如 ID 为 `bar` 的项目:

```json
{
    "name": "Bar",
    "description": "The bartenders",
    "price": 62,
    "tax": 20.2
}
```

它们将包含在响应中。

#### 9.4.5 具有与默认值相同值的数据

如果数据具有与默认值相同的值, 例如 ID 为 `baz` 的项目:

```json
{
    "name": "Baz",
    "description": null,
    "price": 50.2,
    "tax": 10.5,
    "tags": []
}
```

FastAPI 足够聪明(实际上是 Pydantic 足够聪明), 能够意识到, 即使 `description`、`tax` 和 `tags` 具有与默认值相同的值, 它们也是显式设置的(而不是取自默认值)。

因此, 它们将包含在 JSON 响应中。

**提示**

注意, 默认值可以是任何东西, 不仅是 `None`。

它们可以是列表(`[]`)、`10.5` 的 `float` 等。

### 9.5 response_model_include 和 response_model_exclude

你也可以使用路径操作装饰器参数 `response_model_include` 和 `response_model_exclude`。

它们接收一个包含要包含(省略其余部分)或排除(包含其余部分)的属性名称的 `str` 的 `set`。

如果你只有一个 Pydantic 模型并想从输出中删除一些数据, 这可以用作快速快捷方式。

**提示**

但仍然建议使用上面的想法, 使用多个类, 而不是这些参数。

这是因为你的应用的 OpenAPI(和文档)中生成的 JSON Schema 仍然将是完整模型的, 即使你使用 `response_model_include` 或 `response_model_exclude` 来省略某些属性。

这也同样适用于类似工作的 `response_model_by_alias`。

#### 9.5.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5  # 这个字段可以被排除


# 模拟数据库数据
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


# 读取项目名称端点
# response_model_include 只包含指定的字段
@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include={"name", "description"},
)
async def read_item_name(item_id: str):
    return items[item_id]


# 读取项目公共数据端点
# response_model_exclude 排除指定的字段(如 tax)
@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
async def read_item_public_data(item_id: str):
    return items[item_id]
```

#### 9.5.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


# 只包含指定字段
@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include={"name", "description"},
)
async def read_item_name(item_id: str):
    return items[item_id]


# 排除指定字段
@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
async def read_item_public_data(item_id: str):
    return items[item_id]
```

**提示**

语法 `{"name", "description"}` 创建一个包含这两个值的 `set`。

它等效于 `set(["name", "description"])`。

#### 9.5.3 使用 list 而不是 set

如果你忘记使用 `set` 而使用 `list` 或 `tuple`, FastAPI 仍然会将其转换为 `set` 并且它会正确工作:

##### 9.5.3.1 Python 3.10+ 示例

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


# 使用 list 而不是 set, FastAPI 会自动转换
@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include=["name", "description"],
)
async def read_item_name(item_id: str):
    return items[item_id]


# 使用 list 排除字段
@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude=["tax"])
async def read_item_public_data(item_id: str):
    return items[item_id]
```

##### 9.5.3.2 Python 3.8+ 示例

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5


# 模拟数据库
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


# 使用 list
@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include=["name", "description"],
)
async def read_item_name(item_id: str):
    return items[item_id]


@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude=["tax"])
async def read_item_public_data(item_id: str):
    return items[item_id]
```

## 10. 总结

- 使用路径操作装饰器的参数 `response_model` 来定义响应模型, 特别是确保过滤掉私有数据
- 使用 `response_model_exclude_unset` 仅返回显式设置的值

### 关键要点

1. **返回类型注解**: 可以直接通过函数返回类型注解来声明响应模型
2. **response_model 参数**: 当返回类型与响应模型不同时使用
3. **数据过滤**: FastAPI 会自动过滤掉响应模型中未声明的字段
4. **安全性**: 使用不同的输入和输出模型可以防止敏感数据(如密码)泄露
5. **类继承**: 可以使用类继承在保持类型安全的同时实现数据过滤
6. **排除未设置字段**: 使用 `response_model_exclude_unset` 可以只返回显式设置的字段
7. **包含/排除特定字段**: 使用 `response_model_include` 和 `response_model_exclude` 可以快速控制响应中包含的字段
