# 查询参数模型

如果你有一组相关的查询参数, 你可以创建一个 Pydantic 模型来声明它们.

这允许你在多个地方重用该模型, 并且可以一次性为所有参数声明验证和元数据.

**注意**

此功能从 FastAPI 版本 `0.115.0` 开始支持.

## 1. 使用 Pydantic 模型声明查询参数

在 Pydantic 模型中声明你需要的查询参数, 然后将参数声明为 `Query`:

### 1.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated 和 Literal
from typing import Annotated, Literal
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

#### 1.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Literal
from typing import Annotated, Literal
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Annotated 和 Literal (兼容 Python 3.9)
from typing_extensions import Annotated, Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

#### 1.3 Python 3.8+

```python
# 从 typing 模块导入 List
from typing import List
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Annotated 和 Literal (兼容 Python 3.8)
from typing_extensions import Annotated, Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: List[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 1.4 Python 3.10+ - non-Annotated

```python
# 从 typing 模块导入 Literal
from typing import Literal
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 1.5 Python 3.9+ - non-Annotated

```python
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Literal (兼容 Python 3.9)
from typing_extensions import Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 1.6 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 List
from typing import List
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Literal (兼容 Python 3.8)
from typing_extensions import Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型
class FilterParams(BaseModel):
    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: List[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

FastAPI 将从请求中的查询参数中为每个字段提取数据, 并为你提供你定义的 Pydantic 模型.

## 2. 检查文档

你可以在 `/docs` 的文档 UI 中查看查询参数.

## 3. 限制额外的查询参数

在某些特殊用例中 (可能不太常见), 你可能希望限制你想要接收的查询参数.

你可以使用 Pydantic 的模型配置来 `forbid` (禁止) 任何 `extra` (额外) 字段:

### 3.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated 和 Literal
from typing import Annotated, Literal
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

#### 3.2 Python 3.9+

```python
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Annotated 和 Literal (兼容 Python 3.9)
from typing_extensions import Annotated, Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

#### 3.3 Python 3.8+

```python
# 从 typing 模块导入 List
from typing import List
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Annotated 和 Literal (兼容 Python 3.8)
from typing_extensions import Annotated, Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: List[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 3.4 Python 3.10+ - non-Annotated

```python
# 从 typing 模块导入 Literal
from typing import Literal
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 3.5 Python 3.9+ - non-Annotated

```python
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Literal (兼容 Python 3.9)
from typing_extensions import Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: list[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

**提示**

如果可能, 尽量使用 `Annotated` 版本.

##### 3.6 Python 3.8+ - non-Annotated

```python
# 从 typing 模块导入 List
from typing import List
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 导入 Pydantic 的 BaseModel 和 Field
from pydantic import BaseModel, Field
# 从 typing_extensions 导入 Literal (兼容 Python 3.8)
from typing_extensions import Literal

# 创建应用实例
app = FastAPI()


# 定义过滤参数模型, 禁止额外字段
class FilterParams(BaseModel):
    # 配置模型禁止额外字段
    model_config = {"extra": "forbid"}

    # limit 参数: 默认值为 100, 必须大于 0 且小于等于 100
    limit: int = Field(100, gt=0, le=100)
    # offset 参数: 默认值为 0, 必须大于等于 0
    offset: int = Field(0, ge=0)
    # order_by 参数: 只能是 "created_at" 或 "updated_at" 之一, 默认为 "created_at"
    order_by: Literal["created_at", "updated_at"] = "created_at"
    # tags 参数: 字符串列表, 默认为空列表
    tags: List[str] = []


# 定义路径操作, 使用 FilterParams 模型声明查询参数 (不使用 Annotated)
@app.get("/items/")
async def read_items(filter_query: FilterParams = Query()):
    # 返回过滤查询参数
    return filter_query
```

如果客户端尝试在查询参数中发送一些额外的数据, 它们将收到一个错误响应.

例如, 如果客户端尝试发送一个值为 `plumbus` 的 `tool` 查询参数, 如:

```
https://example.com/items/?limit=10&tool=plumbus
```

他们将收到一个错误响应, 告诉他们查询参数 `tool` 不被允许:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["query", "tool"],
            "msg": "Extra inputs are not permitted",
            "input": "plumbus"
        }
    ]
}
```

## 4. 总结

你可以在 FastAPI 中使用 Pydantic 模型来声明查询参数.

**提示**

剧透: 你也可以使用 Pydantic 模型来声明 cookies 和 headers, 但你将在教程的后面部分了解到这些内容.
