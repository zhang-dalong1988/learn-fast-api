# 类作为依赖

在深入探讨**依赖注入**系统之前, 让我们先升级之前的示例。

## 1. 之前示例中的 `dict`

在之前的示例中, 我们从依赖项("可依赖项")返回一个 `dict`:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
# q: 可选的字符串查询参数
# skip: 跳过的记录数, 默认为 0
# limit: 返回的最大记录数, 默认为 100
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/, 使用 Depends 注入依赖
# commons 参数将通过 common_parameters 函数获取
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/, 同样使用相同的依赖
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
# q: 可选的字符串查询参数 (Union[str, None] 表示可以是 str 或 None)
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/, 使用 Depends 注入依赖
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/, 同样使用相同的依赖
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated (Python 3.8 需要使用 typing_extensions)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/, 使用 Depends 注入依赖
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/, 同样使用相同的依赖
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
# 使用直接的类型注解和 Depends, 不使用 Annotated
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons
```

但这样我们在*路径操作函数*的参数 `commons` 中得到的是一个 `dict`。

我们知道编辑器无法为 `dict` 提供太多支持(如自动补全), 因为它们无法知道键和值的类型。

我们可以做得更好...

## 2. 什么构成了依赖

到目前为止, 你已经见过将依赖项声明为函数的方式。

但这并不是声明依赖项的唯一方式(虽然它可能是最常见的方式)。

关键因素是依赖项应该是一个"可调用对象"。

Python 中的**可调用对象**是任何可以像函数一样被"调用"的对象。

所以, 如果你有一个对象 `something`(它可能*不是*函数), 并且你可以像这样"调用"它(执行它):

```python
something()
```

或者

```python
something(some_argument, some_keyword_argument="foo")
```

那么它就是一个"可调用对象"。

## 3. 类作为依赖

你可能已经注意到, 要创建 Python 类的实例, 你使用的是相同的语法。

例如:

```python
# 定义一个 Cat 类
class Cat:
    # 初始化方法, 接受 name 参数
    def __init__(self, name: str):
        # 将 name 赋值给实例属性
        self.name = name

# 创建 Cat 类的实例 fluffy
fluffy = Cat(name="Mr Fluffy")
```

在这种情况下, `fluffy` 是 `Cat` 类的一个实例。

而为了创建 `fluffy`, 你正在"调用" `Cat`。

因此, Python 类也是一个**可调用对象**。

然后, 在 **FastAPI** 中, 你可以使用 Python 类作为依赖项。

FastAPI 实际检查的是它是否是一个"可调用对象"(函数、类或其他任何东西)以及定义的参数。

如果你在 **FastAPI** 中将"可调用对象"作为依赖项传递, 它将分析该"可调用对象"的参数, 并以与*路径操作函数*的参数相同的方式处理它们。包括子依赖。

这也适用于完全没有参数的可调用对象。与没有参数的*路径操作函数*相同。

然后, 我们可以将上面的依赖"可依赖项" `common_parameters` 改为类 `CommonQueryParams`:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 使用 Depends 注入 CommonQueryParams 类作为依赖
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 使用直接的类型注解, 不使用 Annotated
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

请注意用于创建类实例的 `__init__` 方法:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    # 这些参数与之前的函数依赖参数相同
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

...它与我们之前的 `common_parameters` 具有相同的参数:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
# 这是一个函数形式的依赖, 与上面的类形式功能相同
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回公共参数
    return commons
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义依赖函数 common_parameters
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含公共参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons

# 定义 GET 路由 /users/
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回公共参数
    return commons
```

这些参数就是 **FastAPI** 将用来"解析"依赖的参数。

在两种情况下, 它都将具有:

- 一个可选的 `q` 查询参数, 类型为 `str`
- 一个 `skip` 查询参数, 类型为 `int`, 默认值为 `0`
- 一个 `limit` 查询参数, 类型为 `int`, 默认值为 `100`

在两种情况下, 数据都将被转换、验证、在 OpenAPI 模式中记录等。

## 4. 使用它

现在你可以使用这个类声明你的依赖项。

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 使用 Depends 注入 CommonQueryParams 类
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

**FastAPI** 会调用 `CommonQueryParams` 类。这会创建该类的一个"实例", 该实例将作为参数 `commons` 传递给你的函数。

## 5. 类型注解与 `Depends`

注意我们在上面的代码中写了两次 `CommonQueryParams`:

### Python 3.8+

```python
# 使用 Annotated 语法, CommonQueryParams 出现两次
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

### Python 3.8+ 不使用 Annotated

```python
# 使用传统语法, CommonQueryParams 出现两次
commons: CommonQueryParams = Depends(CommonQueryParams)
```

最后一个 `CommonQueryParams`, 在:

```python
... Depends(CommonQueryParams)
```

...是 **FastAPI** 实际用来知道依赖项是什么的。

FastAPI 将从这个类中提取声明的参数, 这也是 FastAPI 实际调用的。

---

在这种情况下, 第一个 `CommonQueryParams`, 在:

### Python 3.8+

```python
commons: Annotated[CommonQueryParams, ...
```

### Python 3.8+ 不使用 Annotated

```python
commons: CommonQueryParams ...
```

...对 **FastAPI** 来说没有任何特殊含义。FastAPI 不会将其用于数据转换、验证等(因为它使用 `Depends(CommonQueryParams)` 来做这些)。

你实际上可以只写:

### Python 3.8+

```python
# 使用 Any 作为类型, 因为类型不重要
commons: Annotated[Any, Depends(CommonQueryParams)]
```

### Python 3.8+ 不使用 Annotated

```python
# 不声明类型
commons = Depends(CommonQueryParams)
```

...就像这样:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated 和 Any
from typing import Annotated, Any

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 使用 Any 作为类型注解, 这样编辑器不知道具体类型
@app.get("/items/")
async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated, Any 和 Union
from typing import Annotated, Any, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+

```python
# 从 typing 模块导入 Any 和 Union
from typing import Any, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 不声明类型, 直接使用 Depends
@app.get("/items/")
async def read_items(commons=Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons=Depends(CommonQueryParams)):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

但是鼓励声明类型, 因为这样你的编辑器就会知道将什么作为参数 `commons` 传递, 然后它可以帮助你进行代码补全、类型检查等。

## 6. 快捷方式

但是你看到我们在这里有一些代码重复, 写了两次 `CommonQueryParams`:

### Python 3.8+

```python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

### Python 3.8+ 不使用 Annotated

```python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

**FastAPI** 为这些情况提供了一个快捷方式, 在这种情况下, 依赖项*专门*是一个 **FastAPI** 将"调用"来创建类本身实例的类。

对于这些特定情况, 你可以执行以下操作:

不写:

### Python 3.8+

```python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

### Python 3.8+ 不使用 Annotated

```python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

...而是写:

### Python 3.8+

```python
commons: Annotated[CommonQueryParams, Depends()]
```

### Python 3.8+ 不使用 Annotated

```python
commons: CommonQueryParams = Depends()
```

你将依赖项声明为参数的类型, 并且你使用不带任何参数的 `Depends()`, 而不必在 `Depends(CommonQueryParams)` 内*再次*编写完整的类。

然后, 同一个示例看起来像这样:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
# 使用 Depends() 而不传入参数, FastAPI 会自动从类型注解中推断
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 模拟的物品数据库
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

# 定义 CommonQueryParams 类作为依赖
class CommonQueryParams:
    # 初始化方法, 定义依赖的参数
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        # 将查询参数赋值给实例属性
        self.q = q
        self.skip = skip
        self.limit = limit

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    # 创建空字典作为响应
    response = {}
    # 如果提供了查询参数 q, 将其添加到响应中
    if commons.q:
        response.update({"q": commons.q})
    # 根据 skip 和 limit 参数从模拟数据库中获取物品
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    # 将物品列表添加到响应中
    response.update({"items": items})
    # 返回响应
    return response
```

...**FastAPI** 会知道该做什么。

**提示**: 如果这似乎令人困惑而不是有帮助, 请忽略它, 你*不需要*它。

这只是一个快捷方式。因为 **FastAPI** 关心帮助你最大限度地减少代码重复。
