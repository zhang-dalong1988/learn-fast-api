# 路径参数和数字验证

与可以使用 `Query` 为查询参数声明更多验证和元数据的方式相同, 你可以使用 `Path` 为路径参数声明相同类型的验证和元数据。

## 1. 导入 `Path`

首先, 从 `fastapi` 导入 `Path`, 并导入 `Annotated`:

### 1.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[str | None, Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 1.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 1.3 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

你可以声明与 `Query` 相同的所有参数。

例如, 要为路径参数 `item_id` 声明 `title` 元数据值, 你可以这样输入:

#### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加标题元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[str | None, Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加标题元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Path 为路径参数添加标题元数据
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[Union[str, None], Query(alias="item-query")] = None,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

**注意**

路径参数始终是必需的, 因为它必须是路径的一部分。即使你用 `None` 声明它或设置默认值, 也不会影响任何东西, 它仍然始终是必需的。

## 2. 按需排列参数

**提示**

如果你使用 `Annotated`, 这可能并不那么重要或必要。

假设你想将查询参数 `q` 声明为必需的 `str`。

并且你不需要为该参数声明任何其他内容, 所以你不需要真正使用 `Query`。

但是你仍然需要为 `item_id` 路径参数使用 `Path`。并且由于某种原因你不想使用 `Annotated`。

如果你在没有任何 "默认" 的值之前放置一个带有 "默认" 的值, Python 会抱怨。

但是你可以重新排序它们, 将没有默认值的值 (查询参数 `q`) 放在第一位。

对于 **FastAPI** 来说这并不重要。它将通过名称, 类型和默认声明 (`Query`, `Path` 等) 检测参数, 它不关心顺序。

因此, 你可以将函数声明为:

#### Python 3.8+ - non-Annotated

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 在前 (无默认值), item_id 在后 (有默认值)
@app.get("/items/{item_id}")
async def read_items(q: str, item_id: int = Path(title="The ID of the item to get")):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 参数顺序不重要
@app.get("/items/{item_id}")
async def read_items(
    q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 参数顺序不重要
@app.get("/items/{item_id}")
async def read_items(
    q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

但请记住, 如果你使用 `Annotated`, 你不会有这个问题, 因为你没有使用函数参数默认值来设置 `Query()` 或 `Path()`。

##### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 参数顺序不重要
@app.get("/items/{item_id}")
async def read_items(
    q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

##### Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 参数顺序不重要
@app.get("/items/{item_id}")
async def read_items(
    q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 3. 按需排列参数, 技巧

**提示**

如果你使用 `Annotated`, 这可能并不那么重要或必要。

这是一个可能会有用的 **小技巧**, 但你不会经常需要它。

如果你想:

- 声明查询参数 `q` 而不使用 `Query` 或任何默认值
- 使用 `Path` 声明路径参数 `item_id`
- 将它们以不同的顺序排列
- 不使用 `Annotated`

...Python 有一个小的特殊语法。

将 `*` 作为函数的第一个参数传递。

Python 不会对那个 `*` 做任何事情, 但它会知道所有以下参数应该作为关键字参数 (键值对) 调用, 也称为 `kwargs`。即使它们没有默认值。

#### Python 3.8+ - non-Annotated

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 * 强制后面的参数使用关键字
@app.get("/items/{item_id}")
async def read_items(*, item_id: int = Path(title="The ID of the item to get"), q: str):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 不需要 *
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 不需要 *
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 3.1 使用 `Annotated` 更好

请记住, 如果你使用 `Annotated`, 由于你没有使用函数参数默认值, 你不会有这个问题, 你可能不需要使用 `*`。

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 不需要 *
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Annotated, 不需要 *
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 4. 数字验证: 大于或等于

使用 `Query` 和 `Path` (以及你稍后将看到的其他) 你可以声明数字约束。

在这里, 使用 `ge=1`, `item_id` 需要是大于或等于 `1` 的整数。

`ge` 表示 "**g**reater than or **e**qual" (大于或等于)。

### 4.1 Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, item_id 必须大于或等于 1
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=1)], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 4.2 Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, item_id 必须大于或等于 1
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=1)], q: str
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 5. 数字验证: 大于和小于或等于

同样适用于:

- `gt`: "**g**reater **t**han" (大于)
- `le`: "**l**ess than or **e**qual" (小于或等于)

### 5.1 Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path

# 创建应用实例
app = FastAPI()


# 定义路径操作, item_id 必须大于 0 且小于或等于 1000
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", gt=0, le=1000)],
    q: str,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 5.2 Python 3.8+

```python
# 导入 FastAPI 框架和 Path
from fastapi import FastAPI, Path
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, item_id 必须大于 0 且小于或等于 1000
@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", gt=0, le=1000)],
    q: str,
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 6. 数字验证: 浮点数, 大于和小于

数字验证也适用于 `float` 值。

在这里, 能够声明 `gt` 而不仅仅是 `ge` 变得重要。因为使用它你可以要求, 例如, 值必须大于 `0`, 即使它小于 `1`。

因此, `0.5` 将是有效值。但 `0.0` 或 `0` 不会。

对于 `lt` 也是如此。

`lt` 表示 "**l**ess **t**han" (小于)。

### 6.1 Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 包含数字验证
@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str,
    size: Annotated[float, Query(gt=0, lt=10.5)],
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 如果提供了查询参数 size, 则将其添加到结果中
    if size:
        results.update({"size": size})
    # 返回结果
    return results
```

### 6.2 Python 3.8+

```python
# 导入 FastAPI 框架, Path 和 Query
from fastapi import FastAPI, Path, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 包含数字验证
@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str,
    size: Annotated[float, Query(gt=0, lt=10.5)],
):
    # 创建包含 item_id 的结果字典
    results = {"item_id": item_id}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 如果提供了查询参数 size, 则将其添加到结果中
    if size:
        results.update({"size": size})
    # 返回结果
    return results
```

## 7. 总结

使用 `Query`, `Path` (以及你尚未看到的其他) 你可以以与查询参数和字符串验证相同的方式声明元数据和字符串验证。

你还可以声明数字验证:

- `gt`: "**g**reater **t**han" (大于)
- `ge`: "**g**reater than or **e**qual" (大于或等于)
- `lt`: "**l**ess **t**han" (小于)
- `le`: "**l**ess than or **e**qual" (小于或等于)

**提示**

`Query`, `Path` 和你稍后将看到的其他类是公共 `Param` 类的子类。

它们都共享用于额外验证和元数据的相同参数。
