# 请求体更新

## 1. 使用 PUT 进行替换更新

要更新一个项目, 你可以使用 HTTP `PUT` 操作。

你可以使用 `jsonable_encoder` 将输入数据转换为可以存储为 JSON 的数据 (例如, 在 NoSQL 数据库中)。例如, 将 `datetime` 转换为 `str`。

### 1.1 Python 3.10+

```python
# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str | None = None  # name 字段, 可选字符串
    description: str | None = None  # description 字段, 可选字符串
    price: float | None = None  # price 字段, 可选浮点数
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PUT 路径操作, 更新 item
# response_model: 响应模型为 Item
@app.put("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 使用 jsonable_encoder 将 item 转换为可 JSON 编码的字典
    update_item_encoded = jsonable_encoder(item)
    # 将编码后的 item 存储到 items 字典中, 替换原有数据
    items[item_id] = update_item_encoded
    # 返回更新后的 item
    return update_item_encoded
```

### 1.2 Python 3.9+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PUT 路径操作, 更新 item
# response_model: 响应模型为 Item
@app.put("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 使用 jsonable_encoder 将 item 转换为可 JSON 编码的字典
    update_item_encoded = jsonable_encoder(item)
    # 将编码后的 item 存储到 items 字典中, 替换原有数据
    items[item_id] = update_item_encoded
    # 返回更新后的 item
    return update_item_encoded
```

### 1.3 Python 3.8+

```python
# 从 typing 中导入 List 和 Union 用于类型注解
from typing import List, Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: List[str] = []  # tags 字段, 字符串列表, 默认为空列表 (使用 List)


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PUT 路径操作, 更新 item
# response_model: 响应模型为 Item
@app.put("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 使用 jsonable_encoder 将 item 转换为可 JSON 编码的字典
    update_item_encoded = jsonable_encoder(item)
    # 将编码后的 item 存储到 items 字典中, 替换原有数据
    items[item_id] = update_item_encoded
    # 返回更新后的 item
    return update_item_encoded
```

`PUT` 用于接收应该替换现有数据的数据。

### 1.4 关于替换的警告

这意味着, 如果你想使用 `PUT` 更新项目 `bar`, 并发送包含以下内容的请求体:

```json
{
    "name": "Barz",
    "price": 3,
    "description": None,
}
```

由于它不包含已存储的属性 `"tax": 20.2`, 输入模型将采用默认值 `"tax": 10.5`。

并且数据将以"新"的 `tax` 值 `10.5` 保存。

## 2. 使用 PATCH 进行部分更新

你也可以使用 HTTP `PATCH` 操作来 部分更新数据。

这意味着你可以只发送想要更新的数据, 保持其余部分不变。

注意

`PATCH` 比 `PUT` 更不常用, 也更不为人知。

许多团队即使进行部分更新也只使用 `PUT`。

你可以 自由地按任何方式使用它们, FastAPI 不会施加任何限制。

但本指南大致展示了它们应该如何使用。

### 2.1 使用 Pydantic 的 `exclude_unset` 参数

如果你想接收部分更新, 在 Pydantic 模型的 `.model_dump()` 中使用参数 `exclude_unset` 非常有用。

例如 `item.model_dump(exclude_unset=True)`。

技术细节

在 Pydantic v1 中, 该方法称为 `.dict()`, 在 Pydantic v2 中被弃用 (但仍支持), 并重命名为 `.model_dump()`。

这里的示例使用 `.dict()` 以兼容 Pydantic v1, 但如果你可以使用 Pydantic v2, 应该使用 `.model_dump()`。

这将生成一个 `dict`, 仅包含在创建 `item` 模型时设置的数据, 排除默认值。

然后, 你可以使用它来生成一个 `dict`, 仅包含设置的数据 (在请求中发送的), 省略默认值:

#### 2.1.1 Python 3.10+

```python
# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str | None = None  # name 字段, 可选字符串
    description: str | None = None  # description 字段, 可选字符串
    price: float | None = None  # price 字段, 可选浮点数
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.1.2 Python 3.9+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.1.3 Python 3.8+

```python
# 从 typing 中导入 List 和 Union 用于类型注解
from typing import List, Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: List[str] = []  # tags 字段, 字符串列表, 默认为空列表 (使用 List)


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

### 2.2 使用 Pydantic 的 `update` 参数

现在, 你可以使用 `.model_copy()` 创建现有模型的副本, 并传递包含要更新数据的 `dict` 作为 `update` 参数。

技术细节

在 Pydantic v1 中, 该方法称为 `.copy()`, 在 Pydantic v2 中被弃用 (但仍支持), 并重命名为 `.model_copy()`。

这里的示例使用 `.copy()` 以兼容 Pydantic v1, 但如果你可以使用 Pydantic v2, 应该使用 `.model_copy()`。

例如 `stored_item_model.model_copy(update=update_data)`:

#### 2.2.1 Python 3.10+

```python
# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str | None = None  # name 字段, 可选字符串
    description: str | None = None  # description 字段, 可选字符串
    price: float | None = None  # price 字段, 可选浮点数
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.2.2 Python 3.9+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.2.3 Python 3.8+

```python
# 从 typing 中导入 List 和 Union 用于类型注解
from typing import List, Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: List[str] = []  # tags 字段, 字符串列表, 默认为空列表 (使用 List)


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

### 2.3 部分更新总结

总之, 要应用部分更新, 你应该:

- (可选) 使用 `PATCH` 代替 `PUT`。
- 检索存储的数据。
- 将该数据放入 Pydantic 模型中。
- 从输入模型生成一个没有默认值的 `dict` (使用 `exclude_unset`)。
  - 这样你只能更新用户实际设置的值, 而不是用模型中的默认值覆盖已存储的值。
- 创建存储模型的副本, 使用接收到的部分更新更新其属性 (使用 `update` 参数)。
- 将复制的模型转换为可以存储在数据库中的内容 (例如, 使用 `jsonable_encoder`)。
  - 这与再次使用模型的 `.model_dump()` 方法相当, 但它确保 (并转换) 值为可以转换为 JSON 的数据类型, 例如, 将 `datetime` 转换为 `str`。
- 将数据保存到数据库。
- 返回更新后的模型。

#### 2.3.1 Python 3.10+

```python
# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: str | None = None  # name 字段, 可选字符串
    description: str | None = None  # description 字段, 可选字符串
    price: float | None = None  # price 字段, 可选浮点数
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.3.2 Python 3.9+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: list[str] = []  # tags 字段, 字符串列表, 默认为空列表


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

#### 2.3.3 Python 3.8+

```python
# 从 typing 中导入 List 和 Union 用于类型注解
from typing import List, Union

# 从 fastapi 包中导入 FastAPI 和 jsonable_encoder
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
# 从 pydantic 中导入 BaseModel
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 Item 模型, 继承自 BaseModel
class Item(BaseModel):
    name: Union[str, None] = None  # name 字段, 可选字符串 (使用 Union)
    description: Union[str, None] = None  # description 字段, 可选字符串 (使用 Union)
    price: Union[float, None] = None  # price 字段, 可选浮点数 (使用 Union)
    tax: float = 10.5  # tax 字段, 浮点数, 默认值为 10.5
    tags: List[str] = []  # tags 字段, 字符串列表, 默认为空列表 (使用 List)


# 模拟数据库存储的 items 字典
items = {
    "foo": {"name": "Foo", "price": 50.2},  # foo 项目
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},  # bar 项目
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},  # baz 项目
}


# 定义一个 GET 路径操作, 读取 item
# response_model: 响应模型为 Item
@app.get("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数
async def read_item(item_id: str):
    # 返回指定 item_id 的 item
    return items[item_id]


# 定义一个 PATCH 路径操作, 部分更新 item
# response_model: 响应模型为 Item
@app.patch("/items/{item_id}", response_model=Item)
# 使用 async def 声明异步函数, 接收 item_id 路径参数和 Item 类型的请求体
async def update_item(item_id: str, item: Item):
    # 从存储中获取现有 item 的数据
    stored_item_data = items[item_id]
    # 将存储的数据转换为 Pydantic 模型
    stored_item_model = Item(**stored_item_data)
    # 使用 exclude_unset=True 仅获取用户实际设置的字段, 排除默认值
    update_data = item.dict(exclude_unset=True)
    # 创建存储模型的副本, 并使用 update 参数更新其属性
    updated_item = stored_item_model.copy(update=update_data)
    # 将更新后的模型编码为可存储在数据库中的格式
    items[item_id] = jsonable_encoder(updated_item)
    # 返回更新后的 item
    return updated_item
```

提示

你实际上可以使用相同的技术与 HTTP `PUT` 操作。

但这里的示例使用 `PATCH`, 因为它是为这些用例创建的。

注意

请注意, 输入模型仍然会被验证。

因此, 如果你想接收可以省略所有属性的部分更新, 你需要有一个所有属性都标记为可选的模型 (具有默认值或 `None`)。

要区分用于 更新 的所有可选值模型和用于 创建 的具有必需值的模型, 你可以使用额外模型中描述的想法。
