# 依赖 - 子依赖

你可以创建具有 __子依赖__ 的依赖项。

它们可以 __深__ 到你需要的程度。

__FastAPI__ 会负责解析它们。

## 1. 第一个依赖 "可依赖项"

你可以创建一个第一个依赖项 ("可依赖项"), 例如:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
# Cookie: 用于获取 Cookie 参数
# Depends: 用于声明依赖项
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
# q: 可选的查询参数, 类型为字符串或 None
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
# 这个依赖使用了另一个依赖, 所以它是 "子依赖"
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    # q 参数将从 query_extractor 函数的返回值获取
    q: Annotated[str, Depends(query_extractor)],
    # 声明一个可选的 Cookie 参数 last_query
    # 如果没有提供该 Cookie, 默认为 None
    last_query: Annotated[str | None, Cookie()] = None,
):
    # 如果没有查询参数 q
    if not q:
        # 返回之前保存的 last_query Cookie 值
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
# 使用 Depends 注入 query_or_cookie_extractor 依赖
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
# q: 可选的查询参数 (Union[str, None] 表示可以是 str 或 None)
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: Annotated[str, Depends(query_extractor)],
    # 声明一个可选的 Cookie 参数 last_query
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI
# 从 typing_extensions 导入 Annotated (Python 3.8 需要使用 typing_extensions)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: Annotated[str, Depends(query_extractor)],
    # 声明一个可选的 Cookie 参数 last_query
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
# 不使用 Annotated, 直接在参数默认值中使用 Depends
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query, 默认值为 None
    last_query: str | None = Cookie(default=None)
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query
    last_query: Union[str, None] = Cookie(default=None),
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

它声明了一个可选的查询参数 `q`, 类型为 `str`, 然后直接返回它。

这非常简单 (不是很有用), 但有助于我们专注于子依赖是如何工作的。

## 2. 第二个依赖, "可依赖项" 和 "依赖者"

然后你可以创建另一个依赖函数 (一个 "可依赖项"), 同时它声明了自己的依赖 (所以它也是一个 "依赖者"):

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor (子依赖)
# 这个函数提取查询参数 q
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
# 这个函数本身是一个依赖, 同时也依赖于 query_extractor
def query_or_cookie_extractor(
    # q 参数从 query_extractor 依赖获取
    # 这是子依赖的核心: 一个依赖依赖于另一个依赖
    q: Annotated[str, Depends(query_extractor)],
    # last_query 是一个可选的 Cookie 参数
    # 如果用户没有提供查询参数 q, 将使用这个 Cookie 中的值
    last_query: Annotated[str | None, Cookie()] = None,
):
    # 如果没有查询参数 q
    if not q:
        # 返回之前保存的 last_query Cookie 值
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
# 使用 Depends 注入 query_or_cookie_extractor 依赖
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    # query_or_cookie_extractor 会先调用 query_extractor 获取 q 值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor (子依赖)
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # q 参数从 query_extractor 依赖获取
    q: Annotated[str, Depends(query_extractor)],
    # last_query 是一个可选的 Cookie 参数
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor (子依赖)
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # q 参数从 query_extractor 依赖获取
    q: Annotated[str, Depends(query_extractor)],
    # last_query 是一个可选的 Cookie 参数
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor (子依赖)
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query
    last_query: str | None = Cookie(default=None)
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor (子依赖)
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query
    last_query: Union[str, None] = Cookie(default=None),
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

让我们专注于声明的参数:

- 即使这个函数本身就是一个依赖 ("可依赖项"), 但它同时也声明了另一个依赖 (它 "依赖于" 其他东西)。
  - 它依赖于 `query_extractor`, 并将其返回的值赋给参数 `q`。
- 它还声明了一个可选的 `last_query` Cookie, 类型为 `str`。
  - 如果用户没有提供任何查询参数 `q`, 我们使用之前使用的查询, 之前我们将其保存到了 Cookie 中。

## 3. 使用依赖

然后我们可以这样使用依赖:

### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
# 这是最底层的依赖, 它没有子依赖
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
# 这个依赖依赖于 query_extractor
def query_or_cookie_extractor(
    # 从 query_extractor 获取 q 的值
    # FastAPI 会先解析 query_extractor, 然后将结果传递给这里
    q: Annotated[str, Depends(query_extractor)],
    # 从 Cookie 中获取 last_query 的值
    last_query: Annotated[str | None, Cookie()] = None,
):
    # 如果没有查询参数 q
    if not q:
        # 返回之前保存的 Cookie 值
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
# 这是路径操作函数, 它依赖于 query_or_cookie_extractor
@app.get("/items/")
async def read_query(
    # FastAPI 会自动解析整个依赖链:
    # 1. 先调用 query_extractor 获取 q
    # 2. 然后调用 query_or_cookie_extractor, 使用 q 和 last_query
    # 3. 最后将结果传递给这个参数
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 从 query_extractor 获取 q 的值
    q: Annotated[str, Depends(query_extractor)],
    # 从 Cookie 中获取 last_query 的值
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 从 query_extractor 获取 q 的值
    q: Annotated[str, Depends(query_extractor)],
    # 从 Cookie 中获取 last_query 的值
    last_query: Annotated[Union[str, None], Cookie()] = None,
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: str | None = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query
    last_query: str | None = Cookie(default=None)
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 模块导入 Union
from typing import Union

# 从 fastapi 导入 Cookie, Depends 和 FastAPI
from fastapi import Cookie, Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义第一个依赖函数 query_extractor
def query_extractor(q: Union[str, None] = None):
    # 直接返回查询参数 q
    return q

# 定义第二个依赖函数 query_or_cookie_extractor
def query_or_cookie_extractor(
    # 使用 Depends 声明子依赖 query_extractor
    q: str = Depends(query_extractor),
    # 声明一个可选的 Cookie 参数 last_query
    last_query: Union[str, None] = Cookie(default=None),
):
    # 如果没有查询参数 q, 返回 Cookie 值
    if not q:
        return last_query
    # 如果有查询参数 q, 直接返回 q
    return q

# 定义 GET 路由 /items/
@app.get("/items/")
async def read_query(
    # query_or_default 参数将从 query_or_cookie_extractor 函数获取值
    query_or_default: str = Depends(query_or_cookie_extractor)
):
    # 返回包含查询值或 Cookie 值的字典
    return {"q_or_cookie": query_or_default}
```

**信息**

请注意, 我们在*路径操作函数*中只声明了一个依赖, 即 `query_or_cookie_extractor`。

但是 __FastAPI__ 会知道它必须先解析 `query_extractor`, 然后在调用 `query_or_cookie_extractor` 时将 `query_extractor` 的结果传递给它。

依赖关系图:

```
graph TB

query_extractor(["query_extractor"])
query_or_cookie_extractor(["query_or_cookie_extractor"])

read_query["/items/"]

query_extractor --> query_or_cookie_extractor --> read_query
```

## 4. 多次使用同一个依赖

如果你的某个依赖在同一个*路径操作*中被声明多次, 例如, 多个依赖有一个共同的子依赖, __FastAPI__ 会知道每个请求只调用该子依赖一次。

它会将返回的值保存在 "缓存" 中, 并将其传递给该特定请求中需要它的所有 "依赖者", 而不是为同一个请求多次调用该依赖。

在一个高级场景中, 如果你知道需要在同一个请求的每一步 (可能多次) 调用依赖, 而不是使用 "缓存" 的值, 你可以在使用 `Depends` 时设置参数 `use_cache=False`:

### Python 3.8+

```python
# 定义一个需要每次都获取最新值的依赖函数
# use_cache=False 告诉 FastAPI 不要使用缓存, 每次都重新调用 get_value
async def needy_dependency(
    # 使用 use_cache=False 禁用缓存
    # 这样每次调用这个依赖时, 都会重新执行 get_value 函数
    fresh_value: Annotated[str, Depends(get_value, use_cache=False)]
):
    # 返回包含最新值的字典
    return {"fresh_value": fresh_value}
```

### Python 3.8+ 不使用 Annotated

```python
# 定义一个需要每次都获取最新值的依赖函数
async def needy_dependency(
    # 使用 use_cache=False 禁用缓存
    # 这样每次调用这个依赖时, 都会重新执行 get_value 函数
    fresh_value: str = Depends(get_value, use_cache=False)
):
    # 返回包含最新值的字典
    return {"fresh_value": fresh_value}
```

## 5. 总结

除了这里使用的所有花哨术语之外, __依赖注入__ 系统非常简单。

只是看起来与*路径操作函数*相同的函数。

但是, 它非常强大, 允许你声明任意深度嵌套的依赖 "图" (树)。

**提示**

在这些简单的示例中, 所有这些可能看起来不那么有用。

但在关于 __安全__ 的章节中, 你会看到它有多有用。

而且你还会看到它会为你节省多少代码。
