# 依赖

__FastAPI__ 拥有一个非常强大但直观的 __依赖注入__ 系统。

它的设计非常简单易用, 使任何开发人员都可以轻松地将其他组件与 __FastAPI__ 集成。

## 1. 什么是 "依赖注入"

在编程中, __"依赖注入"__ 意味着你的代码 (在本例中是你的 _路径操作函数_) 可以声明它需要工作和使用的内容: "依赖项"。

然后, 该系统 (在本例中是 __FastAPI__) 将负责提供你的代码所需的这些依赖项 ("注入" 依赖项)。

这在以下情况下非常有用:

- 需要共享逻辑 (一次又一次地使用相同的代码逻辑)。
- 共享数据库连接。
- 强制执行安全性、身份验证、角色要求等。
- 以及许多其他事情...

所有这些, 同时最大限度地减少代码重复。

## 2. 第一步

让我们看一个非常简单的例子。它将非常简单, 目前不太有用。

但通过这种方式, 我们可以专注于 __依赖注入__ 系统是如何工作的。

### 2.1 创建依赖项, 或 "可依赖项"

让我们首先关注依赖项。

它只是一个函数, 可以采用与 _路径操作函数_ 相同的所有参数:

#### Python 3.10+

```python
# 从 typing 中导入 Annotated 用于类型注解
from typing import Annotated

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
# q: 可选的查询参数, 字符串类型
# skip: 可选的查询参数, 整数类型, 默认值为 0
# limit: 可选的查询参数, 整数类型, 默认值为 100
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含这些参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路径操作, 处理 /items/ 路径
# commons: 使用 Depends 声明依赖, 类型为 Annotated[dict, Depends(common_parameters)]
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons

# 定义 GET 路径操作, 处理 /users/ 路径
# commons: 使用相同的依赖项
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons
```

#### Python 3.9+

```python
# 从 typing 中导入 Annotated 和 Union 用于类型注解
from typing import Annotated, Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
# q: 可选的查询参数, 字符串或 None 类型 (使用 Union)
# skip: 可选的查询参数, 整数类型, 默认值为 0
# limit: 可选的查询参数, 整数类型, 默认值为 100
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含这些参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路径操作, 处理 /items/ 路径
# commons: 使用 Depends 声明依赖, 类型为 Annotated[dict, Depends(common_parameters)]
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons

# 定义 GET 路径操作, 处理 /users/ 路径
# commons: 使用相同的依赖项
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons
```

#### Python 3.8+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 中导入 Annotated (Python 3.8 需要从 typing_extensions 导入)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
# q: 可选的查询参数, 字符串或 None 类型 (使用 Union)
# skip: 可选的查询参数, 整数类型, 默认值为 0
# limit: 可选的查询参数, 整数类型, 默认值为 100
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含这些参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路径操作, 处理 /items/ 路径
# commons: 使用 Depends 声明依赖, 类型为 Annotated[dict, Depends(common_parameters)]
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons

# 定义 GET 路径操作, 处理 /users/ 路径
# commons: 使用相同的依赖项
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # 直接返回依赖项的结果
    return commons
```

#### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
# q: 可选的查询参数, 字符串类型
# skip: 可选的查询参数, 整数类型, 默认值为 0
# limit: 可选的查询参数, 整数类型, 默认值为 100
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    # 返回包含这些参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路径操作, 处理 /items/ 路径
# commons: 使用 Depends 声明依赖, 类型为 dict
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回依赖项的结果
    return commons

# 定义 GET 路径操作, 处理 /users/ 路径
# commons: 使用相同的依赖项
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回依赖项的结果
    return commons
```

#### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
# q: 可选的查询参数, 字符串或 None 类型 (使用 Union)
# skip: 可选的查询参数, 整数类型, 默认值为 0
# limit: 可选的查询参数, 整数类型, 默认值为 100
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    # 返回包含这些参数的字典
    return {"q": q, "skip": skip, "limit": limit}

# 定义 GET 路径操作, 处理 /items/ 路径
# commons: 使用 Depends 声明依赖, 类型为 dict
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    # 直接返回依赖项的结果
    return commons

# 定义 GET 路径操作, 处理 /users/ 路径
# commons: 使用相同的依赖项
@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    # 直接返回依赖项的结果
    return commons
```

就这样。

__2 行__。

它具有与所有 _路径操作函数_ 相同的形状和结构。

你可以将其视为没有 "装饰器" 的 _路径操作函数_ (没有 `@app.get("/some-path")`)。

并且它可以返回你想要的任何内容。

在这种情况下, 该依赖项期望:

- 可选查询参数 `q`, 是 `str` 类型。
- 可选查询参数 `skip`, 是 `int` 类型, 默认为 `0`。
- 可选查询参数 `limit`, 是 `int` 类型, 默认为 `100`。

然后它只返回包含这些值的 `dict`。

信息

FastAPI 在 0.95.0 版本中添加了对 `Annotated` 的支持 (并开始推荐使用它)。

如果你使用的是旧版本, 尝试使用 `Annotated` 时会报错。

确保在使用 `Annotated` 之前将 FastAPI 版本升级到至少 0.95.1。

### 2.2 导入 `Depends`

#### Python 3.10+

```python
# 从 typing 中导入 Annotated 用于类型注解
from typing import Annotated

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

# 定义路径操作, 使用依赖注入
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.9+

```python
# 从 typing 中导入 Annotated 和 Union 用于类型注解
from typing import Annotated, Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 定义路径操作, 使用依赖注入
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.8+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 中导入 Annotated (Python 3.8 需要)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 定义路径操作, 使用依赖注入
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

# 定义路径操作, 使用依赖注入
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

#### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 定义路径操作, 使用依赖注入
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

### 2.3 在 "依赖者" 中声明依赖项

与在 _路径操作函数_ 参数中使用 `Body`, `Query` 等的方式相同, 使用 `Depends` 声明一个新参数:

#### Python 3.10+

```python
# 从 typing 中导入 Annotated 用于类型注解
from typing import Annotated

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

# 在路径操作函数中使用 Depends 声明依赖
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.9+

```python
# 从 typing 中导入 Annotated 和 Union 用于类型注解
from typing import Annotated, Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 在路径操作函数中使用 Depends 声明依赖
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.8+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 中导入 Annotated (Python 3.8 需要)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 在路径操作函数中使用 Depends 声明依赖
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

#### Python 3.10+ - 不使用 Annotated

```python
# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

# 在路径操作函数中使用 Depends 声明依赖
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

#### Python 3.8+ - 不使用 Annotated

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 在路径操作函数中使用 Depends 声明依赖
@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

尽管你在函数参数中使用 `Depends` 的方式与使用 `Body`, `Query` 等的方式相同, 但 `Depends` 的工作方式略有不同。

你只给 `Depends` 一个参数。

该参数必须是类似函数的东西。

你 __不直接调用它__ (不要在末尾添加括号), 只需将其作为参数传递给 `Depends()`。

并且该函数采用与 _路径操作函数_ 相同的方式采用参数。

提示

你将在下一章中看到除函数之外还可以使用哪些其他 "东西" 作为依赖项。

每当有新请求到达时, __FastAPI__ 将负责:

- 使用正确的参数调用你的依赖项 ("可依赖项") 函数。
- 从你的函数获取结果。
- 将该结果分配给你的 _路径操作函数_ 中的参数。

```
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

这样, 你只需编写一次共享代码, __FastAPI__ 就会为你的 _路径操作_ 调用它。

检查

请注意, 你不必创建一个特殊的类并将其传递到 __FastAPI__ 的某个地方来 "注册" 它或任何类似的东西。

你只需将它传递给 `Depends`, __FastAPI__ 就知道如何做剩下的事情。

在上面的示例中, 你会看到有少量的 __代码重复__。

当你需要使用 `common_parameters()` 依赖项时, 你必须编写带有类型注解和 `Depends()` 的整个参数:

```
commons: Annotated[dict, Depends(common_parameters)]
```

但是因为我们使用的是 `Annotated`, 我们可以将该 `Annotated` 值存储在变量中并在多个地方使用:

#### Python 3.10+

```python
# 从 typing 中导入 Annotated 用于类型注解
from typing import Annotated

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

# 将依赖项的类型注解存储为类型别名, 方便在多处复用
CommonsDep = Annotated[dict, Depends(common_parameters)]

# 使用类型别名声明依赖
@app.get("/items/")
async def read_items(commons: CommonsDep):
    return commons

# 在另一个路径操作中复用相同的类型别名
@app.get("/users/")
async def read_users(commons: CommonsDep):
    return commons
```

#### Python 3.9+

```python
# 从 typing 中导入 Annotated 和 Union 用于类型注解
from typing import Annotated, Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 将依赖项的类型注解存储为类型别名, 方便在多处复用
CommonsDep = Annotated[dict, Depends(common_parameters)]

# 使用类型别名声明依赖
@app.get("/items/")
async def read_items(commons: CommonsDep):
    return commons

# 在另一个路径操作中复用相同的类型别名
@app.get("/users/")
async def read_users(commons: CommonsDep):
    return commons
```

#### Python 3.8+

```python
# 从 typing 中导入 Union 用于类型注解
from typing import Union

# 从 fastapi 中导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 typing_extensions 中导入 Annotated (Python 3.8 需要)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义公共参数依赖函数
async def common_parameters(
    q: Union[str, None] = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

# 将依赖项的类型注解存储为类型别名, 方便在多处复用
CommonsDep = Annotated[dict, Depends(common_parameters)]

# 使用类型别名声明依赖
@app.get("/items/")
async def read_items(commons: CommonsDep):
    return commons

# 在另一个路径操作中复用相同的类型别名
@app.get("/users/")
async def read_users(commons: CommonsDep):
    return commons
```

提示

这只是标准的 Python, 它被称为 "类型别名", 实际上并不特定于 __FastAPI__。

但是因为 __FastAPI__ 基于 Python 标准, 包括 `Annotated`, 你可以在代码中使用这个技巧。

依赖项将按预期继续工作, __最好的部分__ 是 __类型信息将被保留__, 这意味着你的编辑器将能够继续为你提供 __自动完成__, __内联错误__ 等。对于像 `mypy` 这样的其他工具也是如此。

当你在 __大型代码库__ 中在 __许多路径操作__ 中一次又一次地使用 __相同的依赖项__ 时, 这将特别有用。

## 3. 使用 `async` 还是不使用 `async`

由于依赖项也将由 __FastAPI__ 调用 (与你的 _路径操作函数_ 相同), 因此在定义函数时适用相同的规则。

你可以使用 `async def` 或普通的 `def`。

你可以在普通的 `def` _路径操作函数_ 中声明带有 `async def` 的依赖项, 或在 `async def` _路径操作函数_ 中声明 `def` 依赖项, 等等。

没关系。__FastAPI__ 会知道该怎么做。

## 4. 与 OpenAPI 集成

你的依赖项 (和子依赖项) 的所有请求声明、验证和要求都将集成到同一个 OpenAPI 模式中。

因此, 交互式文档也将包含来自这些依赖项的所有信息:

![带有依赖项的交互式 API 文档](https://fastapi.tiangolo.com/img/tutorial/dependencies/image01.png)

## 5. 简单用法

如果你看它, _路径操作函数_ 被声明为在 _路径_ 和 _操作_ 匹配时使用, 然后 __FastAPI__ 负责使用正确的参数调用函数, 从请求中提取数据。

实际上, 所有 (或大多数) Web 框架都以这种方式工作。

你从不直接调用这些函数。它们由你的框架调用 (在本例中是 __FastAPI__)。

使用依赖注入系统, 你还可以告诉 __FastAPI__, 你的 _路径操作函数_ 也 "依赖" 于其他东西, 这些东西应该在你的 _路径操作函数_ 之前执行, __FastAPI__ 将负责执行它并 "注入" 结果。

对于 "依赖注入" 的同一想法, 其他常用术语是:

- resources (资源)
- providers (提供者)
- services (服务)
- injectables (可注入项)
- components (组件)

## 6. __FastAPI__ 插件

可以使用 __依赖注入__ 系统构建集成和 "插件"。但实际上, 实际上 __不需要创建 "插件"__, 因为通过使用依赖项, 可以声明无数的集成和交互, 这些集成和交互可用于你的 _路径操作函数_。

依赖项可以以一种非常简单直观的方式创建, 使你只需导入所需的 Python 包, 并在几行代码中将它们与 API 函数集成, _字面上_。

你将在接下来的章节中看到这方面的示例, 关于关系型和 NoSQL 数据库、安全性等。

## 7. __FastAPI__ 兼容性

依赖注入系统的简单性使 __FastAPI__ 与以下内容兼容:

- 所有的关系型数据库
- NoSQL 数据库
- 外部包
- 外部 API
- 身份验证和授权系统
- API 使用监控系统
- 响应数据注入系统
- 等等

## 8. 简单而强大

尽管分层依赖注入系统非常简单易用, 但它仍然非常强大。

你可以定义依赖项, 而这些依赖项又可以定义它们自己的依赖项。

最后, 构建了一个分层的依赖树, __依赖注入__ 系统负责为你解决所有这些依赖项 (及其子依赖项) 并在每一步提供 (注入) 结果。

例如, 假设你有 4 个 API 端点 (_路径操作_):

- `/items/public/`
- `/items/private/`
- `/users/{user_id}/activate`
- `/items/pro/`

那么你可以仅使用依赖项和子依赖项为每个端点添加不同的权限要求:

```
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

## 9. 与 __OpenAPI__ 集成

所有这些依赖项在声明其要求时, 也会向你的 _路径操作_ 添加参数、验证等。

__FastAPI__ 会将所有内容添加到 OpenAPI 模式中, 以便在交互式文档系统中显示。
