# 后台任务

你可以定义在返回响应**之后**运行的后台任务。

这对于需要在请求之后执行的操作非常有用, 但客户端不必等待操作完成就能收到响应。

这包括例如:

- 执行操作后发送的电子邮件通知:
  - 由于连接到电子邮件服务器和发送邮件往往比较"慢"（几秒钟）, 你可以立即返回响应并在后台发送电子邮件通知。
- 处理数据:
  - 例如, 假设你收到一个必须经过缓慢处理的文件, 你可以返回 "Accepted" 响应（HTTP 202）并在后台处理文件。

## 1. 使用 `BackgroundTasks`

首先, 导入 `BackgroundTasks` 并在你的路径操作函数中用 `BackgroundTasks` 类型声明定义一个参数:

**Python 3.8+**

```python
# 从 fastapi 导入 FastAPI 和 BackgroundTasks
# BackgroundTasks 用于在返回响应后执行后台任务
from fastapi import BackgroundTasks, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个后台任务函数
# 这个函数会写入通知到文件（模拟发送邮件）
# email: 收件人邮箱地址
# message: 通知内容, 默认为空字符串
def write_notification(email: str, message=""):
    # 以写入模式打开 log.txt 文件
    with open("log.txt", mode="w") as email_file:
        # 格式化通知内容
        content = f"notification for {email}: {message}"
        # 将内容写入文件
        email_file.write(content)

# 定义 POST 路径操作, 发送通知
# {email} 是路径参数, 会自动传递给函数
# background_tasks 参数由 FastAPI 自动注入
@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    # 添加后台任务
    # 参数 1: 要执行的函数 (write_notification)
    # 参数 2: 位置参数 (email)
    # 参数 3: 关键字参数 (message="some notification")
    background_tasks.add_task(write_notification, email, message="some notification")
    # 立即返回响应, 不需要等待后台任务完成
    return {"message": "Notification sent in the background"}
```

__FastAPI__ 会为你创建类型为 `BackgroundTasks` 的对象并将其作为该参数传递。

## 2. 创建任务函数

创建一个作为后台任务运行的函数。

这只是一个可以接收参数的标准函数。

它可以是 `async def` 或普通 `def` 函数, __FastAPI__ 会知道如何正确处理它。

在这个例子中, 任务函数将写入一个文件（模拟发送电子邮件）。

由于写入操作不使用 `async` 和 `await`, 我们用普通 `def` 定义函数:

**Python 3.8+**

```python
from fastapi import BackgroundTasks, FastAPI

app = FastAPI()

# 后台任务函数
# 使用普通 def 而不是 async def, 因为文件操作不需要异步
def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)

@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    # 将任务添加到后台任务列表
    # 任务会在响应返回给客户端后执行
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}
```

## 3. 添加后台任务

在你的路径操作函数中, 使用 `.add_task()` 方法将任务函数传递给后台任务对象:

**Python 3.8+**

```python
from fastapi import BackgroundTasks, FastAPI

app = FastAPI()

def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)

@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    # add_task 方法接收:
    # 1. 任务函数 (write_notification)
    # 2. 按顺序传递给任务函数的位置参数 (email)
    # 3. 传递给任务函数的关键字参数 (message="some notification")
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}
```

`.add_task()` 接收的参数:

- 要在后台运行的任务函数（`write_notification`）。
- 应该按顺序传递给任务函数的任何参数序列（`email`）。
- 应该传递给任务函数的任何关键字参数（`message="some notification"`）。

## 4. 依赖注入

使用 `BackgroundTasks` 也可以与依赖注入系统一起工作, 你可以在多个级别声明类型为 `BackgroundTasks` 的参数: 在路径操作函数中、在依赖项（可依赖项）中、在子依赖项中等。

__FastAPI__ 知道在每种情况下该做什么, 以及如何重用同一个对象, 以便所有后台任务合并在一起并在之后在后台运行:

**Python 3.10+**

```python
# 从 typing 导入 Annotated, 用于类型注解
from typing import Annotated

# 导入 FastAPI 相关组件
from fastapi import BackgroundTasks, Depends, FastAPI

app = FastAPI()

# 定义一个后台任务函数, 写入日志
# mode="a" 表示追加模式, 不会覆盖已有内容
def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)

# 定义一个依赖函数, 处理查询参数
# background_tasks 参数会自动注入, 可以在依赖中添加后台任务
def get_query(background_tasks: BackgroundTasks, q: str | None = None):
    # 如果有查询参数 q
    if q:
        # 创建日志消息
        message = f"found query: {q}\n"
        # 在依赖中添加后台任务
        # 这个任务会在响应返回后执行
        background_tasks.add_task(write_log, message)
    # 返回查询参数
    return q

# 定义 POST 路径操作
# 使用 Depends(get_query) 注入依赖
# q 参数的值来自 get_query 函数的返回值
@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
):
    # 创建通知消息
    message = f"message to {email}\n"
    # 添加另一个后台任务
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}
```

在这个例子中, 消息将在发送响应**之后**写入 `log.txt` 文件。

如果请求中有查询参数, 它将在后台任务中写入日志。

然后在路径操作函数中生成的另一个后台任务将使用 `email` 路径参数写入消息。

### 其他版本和变体

**Python 3.9+**

```python
from typing import Annotated, Union

from fastapi import BackgroundTasks, Depends, FastAPI

app = FastAPI()

def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)

# Python 3.9 使用 Union[str, None] 表示可选字符串
def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):
    if q:
        message = f"found query: {q}\n"
        background_tasks.add_task(write_log, message)
    return q

@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
):
    message = f"message to {email}\n"
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}
```

**Python 3.8+**

```python
from typing import Union

from fastapi import BackgroundTasks, Depends, FastAPI
from typing_extensions import Annotated

app = FastAPI()

def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)

def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):
    if q:
        message = f"found query: {q}\n"
        background_tasks.add_task(write_log, message)
    return q

@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
):
    message = f"message to {email}\n"
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}
```

### 提示

尽可能使用 `Annotated` 版本。

**Python 3.10+ non-Annotated**

```python
from fastapi import BackgroundTasks, Depends, FastAPI

app = FastAPI()

def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)

def get_query(background_tasks: BackgroundTasks, q: str | None = None):
    if q:
        message = f"found query: {q}\n"
        background_tasks.add_task(write_log, message)
    return q

# 不使用 Annotated 的版本, 直接在参数类型中使用 Depends
@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query)
):
    message = f"message to {email}\n"
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}
```

### 提示

尽可能使用 `Annotated` 版本。

**Python 3.8+ non-Annotated**

```python
from typing import Union

from fastapi import BackgroundTasks, Depends, FastAPI

app = FastAPI()

def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)

def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):
    if q:
        message = f"found query: {q}\n"
        background_tasks.add_task(write_log, message)
    return q

@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query)
):
    message = f"message to {email}\n"
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}
```

## 5. 技术细节

`BackgroundTasks` 类直接来自 `starlette.background`。

它被直接导入/包含到 FastAPI 中, 以便你可以从 `fastapi` 导入它, 并避免意外从 `starlette.background` 导入替代的 `BackgroundTask`（末尾没有 `s`）。

通过只使用 `BackgroundTasks`（而不是 `BackgroundTask`）, 就可以将其作为路径操作函数参数使用, 并让 __FastAPI__ 为你处理其余部分, 就像直接使用 `Request` 对象一样。

仍然可以在 FastAPI 中单独使用 `BackgroundTask`, 但你必须在代码中创建对象并返回包含它的 Starlette `Response`。

你可以在 Starlette 的后台任务官方文档中查看更多详细信息。

## 6. 注意事项

如果你需要执行繁重的后台计算, 并且不一定需要由同一进程运行它（例如, 你不需要共享内存、变量等）, 你可能会受益于使用其他更大的工具, 如 Celery。

它们往往需要更复杂的配置、消息/作业队列管理器, 如 RabbitMQ 或 Redis, 但它们允许你在多个进程, 特别是多个服务器中运行后台任务。

但是, 如果你需要访问同一个 __FastAPI__ 应用程序中的变量和对象, 或者你需要执行小型后台任务（如发送电子邮件通知）, 你可以只使用 `BackgroundTasks`。

## 7. 总结

在路径操作函数和依赖项中导入并使用带有参数的 `BackgroundTasks` 来添加后台任务。
