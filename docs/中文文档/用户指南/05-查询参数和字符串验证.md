# 查询参数和字符串验证

FastAPI 允许你为参数声明额外的信息和验证。

让我们以这个应用程序为例:

### 0.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI

# 创建应用实例
app = FastAPI()


# 定义路径操作, 包含可选查询参数 q
@app.get("/items/")
async def read_items(q: str | None = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 0.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI

# 创建应用实例
app = FastAPI()


# 定义路径操作, 包含可选查询参数 q
@app.get("/items/")
async def read_items(q: Union[str, None] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

查询参数 `q` 的类型是 `str | None`, 这意味着它是 `str` 类型, 但也可以是 `None`, 实际上, 默认值是 `None`, 所以 FastAPI 会知道它不是必需的。

## 1. 额外验证

我们要强制执行, 即使 `q` 是可选的, 但只要提供了它, **其长度就不超过 50 个字符**。

### 1.1 导入 `Query` 和 `Annotated`

为此, 首先导入:

- 从 `fastapi` 导入 `Query`
- 从 `typing` 导入 `Annotated`

#### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最大长度
@app.get("/items/")
async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最大长度
@app.get("/items/")
async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 2. 在 `q` 参数的类型中使用 `Annotated`

我们有这个类型注解:

```python
q: Union[str, None] = None
```

我们要做的是用 `Annotated` 包装它, 所以它变成:

```python
q: Annotated[Union[str, None]] = None
```

这两个版本的意思是一样的, `q` 是一个可以是 `str` 或 `None` 的参数, 默认情况下, 它是 `None`。

## 3. 在 `q` 参数的 `Annotated` 中添加 `Query`

现在我们有了这个 `Annotated`, 可以在其中放置更多信息 (在这种情况下是一些额外的验证), 在 `Annotated` 中添加 `Query`, 并将参数 `max_length` 设置为 `50`:

### 3.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最大长度
@app.get("/items/")
async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 3.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最大长度
@app.get("/items/")
async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

请注意, 默认值仍然是 `None`, 所以参数仍然是可选的。

但是现在, 在 `Annotated` 中有 `Query(max_length=50)`, 我们告诉 FastAPI, 我们希望对这个值进行 **额外验证**, 我们希望它的最大长度为 50 个字符。

FastAPI 现在将:

- **验证** 数据, 确保最大长度为 50 个字符
- 当数据无效时, 为客户端显示 **清晰的错误**
- 在 OpenAPI 模式 *路径操作* 中 **文档化** 参数 (因此它将显示在 **自动文档 UI** 中)

## 4. 添加更多验证

你还可以添加参数 `min_length`:

### 4.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最小和最大长度
@app.get("/items/")
async def read_items(
    q: Annotated[str | None, Query(min_length=3, max_length=50)] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 4.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最小和最大长度
@app.get("/items/")
async def read_items(
    q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 5. 添加正则表达式

你可以定义参数应该匹配的正则表达式 `pattern`:

### 5.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的长度和模式
@app.get("/items/")
async def read_items(
    q: Annotated[
        str | None, Query(min_length=3, max_length=50, pattern="^fixedquery$")
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 5.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的长度和模式
@app.get("/items/")
async def read_items(
    q: Annotated[
        Union[str, None], Query(min_length=3, max_length=50, pattern="^fixedquery$")
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

这个特定的正则表达式模式检查接收到的参数值:

- `^`: 以以下字符开头, 之前没有字符。
- `fixedquery`: 具有确切的值 `fixedquery`。
- `$`: 在那里结束, `fixedquery` 之后没有更多字符。

## 6. 默认值

当然, 你可以使用除 `None` 以外的默认值。

假设你想声明 `q` 查询参数的 `min_length` 为 `3`, 默认值为 `"fixedquery"`:

### 6.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最小长度, 并设置默认值
@app.get("/items/")
async def read_items(q: Annotated[str, Query(min_length=3)] = "fixedquery"):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 6.2 Python 3.8+

```python
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 使用 Query 限制查询参数的最小长度, 并设置默认值
@app.get("/items/")
async def read_items(q: Annotated[str, Query(min_length=3)] = "fixedquery"):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 7. 必需参数

当我们不需要声明更多验证或元数据时, 我们可以通过不声明默认值来使 `q` 查询参数成为必需参数。

但我们现在使用 `Query` 声明它, 所以当你需要在使用 `Query` 时将值声明为必需参数时, 可以简单地不声明默认值:

### 7.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 为必需参数, 最小长度为 3
@app.get("/items/")
async def read_items(q: Annotated[str, Query(min_length=3)]):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 7.2 Python 3.8+

```python
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 为必需参数, 最小长度为 3
@app.get("/items/")
async def read_items(q: Annotated[str, Query(min_length=3)]):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 8. 必需参数, 但可以为 `None`

你可以声明参数可以接受 `None`, 但它仍然是必需的。这将强制客户端发送一个值, 即使该值是 `None`。

为此, 你可以声明 `None` 是有效类型, 但只是不声明默认值:

### 8.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 为必需参数, 可以为 None 或字符串, 最小长度为 3
@app.get("/items/")
async def read_items(q: Annotated[str | None, Query(min_length=3)]):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 8.2 Python 3.8+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 为必需参数, 可以为 None 或字符串, 最小长度为 3
@app.get("/items/")
async def read_items(q: Annotated[Union[str, None], Query(min_length=3)]):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 9. 查询参数列表 / 多个值

当你使用 `Query` 显式定义查询参数时, 你还可以声明它接收值列表, 或者换句话说, 接收多个值。

例如, 要声明可以在 URL 中多次出现的查询参数 `q`, 你可以这样写:

### 9.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值
@app.get("/items/")
async def read_items(q: Annotated[list[str] | None, Query()] = None):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

### 9.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值
@app.get("/items/")
async def read_items(q: Annotated[list[str] | None, Query()] = None):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

### 9.3 Python 3.8+

```python
# 从 typing 模块导入 List 和 Union 类型
from typing import List, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值
@app.get("/items/")
async def read_items(q: Annotated[Union[List[str], None], Query()] = None):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

然后, 使用像这样的 URL:

```
http://localhost:8000/items/?q=foo&q=bar
```

你将在 *路径操作函数* 内的 *函数参数* `q` 中, 以 Python `list` 的形式接收到多个 `q` *查询参数* 的值 (`foo` 和 `bar`)。

因此, 该 URL 的响应将是:

```json
{
  "q": [
    "foo",
    "bar"
  ]
}
```

## 10. 查询参数列表 / 带默认值的多个值

你还可以定义一个默认的值 `list`, 如果没有提供任何值:

### 10.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值, 有默认值列表
@app.get("/items/")
async def read_items(q: Annotated[list[str], Query()] = ["foo", "bar"]):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

### 10.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值, 有默认值列表
@app.get("/items/")
async def read_items(q: Annotated[list[str], Query()] = ["foo", "bar"]):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

### 10.3 Python 3.8+

```python
# 从 typing 模块导入 List 类型
from typing import List
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, q 可以接收多个值, 有默认值列表
@app.get("/items/")
async def read_items(q: Annotated[List[str], Query()] = ["foo", "bar"]):
    # 返回包含查询参数列表的字典
    query_items = {"q": q}
    return query_items
```

如果你访问:

```
http://localhost:8000/items/
```

`q` 的默认值将是: `["foo", "bar"]`, 你的响应将是:

```json
{
  "q": [
    "foo",
    "bar"
  ]
}
```

## 11. 添加更多信息

你可以添加有关参数的更多信息。

该信息将包含在生成的 OpenAPI 中, 并被文档用户界面和外部工具使用。

### 11.1 添加 `title`

你可以添加 `title`:

#### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[str | None, Query(title="Query string", min_length=3)] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[Union[str, None], Query(title="Query string", min_length=3)] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[Union[str, None], Query(title="Query string", min_length=3)] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 11.2 添加 `description`

和 `description`:

#### Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题, 描述和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[
        str | None,
        Query(
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题, 描述和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[
        Union[str, None],
        Query(
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

#### Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加标题, 描述和最小长度限制
@app.get("/items/")
async def read_items(
    q: Annotated[
        Union[str, None],
        Query(
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 12. 别名参数

假设你希望参数名为 `item-query`。

像这样:

```
http://127.0.0.1:8000/items/?item-query=foobaritems
```

但 `item-query` 不是有效的 Python 变量名。

最接近的是 `item_query`。

但你仍然需要它完全是 `item-query`...

然后你可以声明一个 `alias`, 该别名将用于查找参数值:

### 12.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加别名
@app.get("/items/")
async def read_items(q: Annotated[str | None, Query(alias="item-query")] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 12.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加别名
@app.get("/items/")
async def read_items(q: Annotated[Union[str, None], Query(alias="item-query")] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 12.3 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 为查询参数添加别名
@app.get("/items/")
async def read_items(q: Annotated[Union[str, None], Query(alias="item-query")] = None):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 13. 弃用参数

现在假设你不再喜欢这个参数了。

你必须保留它一段时间, 因为有客户端在使用它, 但你希望文档清楚地将其显示为已弃用。

然后将参数 `deprecated=True` 传递给 `Query`:

### 13.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 标记查询参数为已弃用
@app.get("/items/")
async def read_items(
    q: Annotated[
        str | None,
        Query(
            alias="item-query",
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
            max_length=50,
            pattern="^fixedquery$",
            deprecated=True,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 13.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 标记查询参数为已弃用
@app.get("/items/")
async def read_items(
    q: Annotated[
        Union[str, None],
        Query(
            alias="item-query",
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
            max_length=50,
            pattern="^fixedquery$",
            deprecated=True,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

### 13.3 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 标记查询参数为已弃用
@app.get("/items/")
async def read_items(
    q: Annotated[
        Union[str, None],
        Query(
            alias="item-query",
            title="Query string",
            description="Query string for the items to search in the database that have a good match",
            min_length=3,
            max_length=50,
            pattern="^fixedquery$",
            deprecated=True,
        ),
    ] = None,
):
    # 创建包含两个项目的默认结果列表
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        results.update({"q": q})
    # 返回结果
    return results
```

## 14. 从 OpenAPI 中排除参数

要从生成的 OpenAPI 模式中排除查询参数 (因此从自动文档系统中排除), 请将 `Query` 的参数 `include_in_schema` 设置为 `False`:

### 14.1 Python 3.10+

```python
# 从 typing 模块导入 Annotated
from typing import Annotated
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 隐藏查询参数不出现在文档中
@app.get("/items/")
async def read_items(
    hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None,
):
    # 如果提供了隐藏查询参数, 则返回它
    if hidden_query:
        return {"hidden_query": hidden_query}
    # 否则返回未找到
    else:
        return {"hidden_query": "Not found"}
```

### 14.2 Python 3.9+

```python
# 从 typing 模块导入 Annotated 和 Union 类型
from typing import Annotated, Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query

# 创建应用实例
app = FastAPI()


# 定义路径操作, 隐藏查询参数不出现在文档中
@app.get("/items/")
async def read_items(
    hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None,
):
    # 如果提供了隐藏查询参数, 则返回它
    if hidden_query:
        return {"hidden_query": hidden_query}
    # 否则返回未找到
    else:
        return {"hidden_query": "Not found"}
```

### 14.3 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架和 Query
from fastapi import FastAPI, Query
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建应用实例
app = FastAPI()


# 定义路径操作, 隐藏查询参数不出现在文档中
@app.get("/items/")
async def read_items(
    hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None,
):
    # 如果提供了隐藏查询参数, 则返回它
    if hidden_query:
        return {"hidden_query": hidden_query}
    # 否则返回未找到
    else:
        return {"hidden_query": "Not found"}
```

## 15. 总结

你可以为参数声明额外的验证和元数据。

通用验证和元数据:

- `alias` - 别名
- `title` - 标题
- `description` - 描述
- `deprecated` - 弃用

字符串特有的验证:

- `min_length` - 最小长度
- `max_length` - 最大长度
- `pattern` - 正则表达式模式

在这些示例中, 你看到了如何为 `str` 值声明验证。

请参阅后续章节, 了解如何为其他类型 (如数字) 声明验证。
