# 第 15 章 额外模型

继续前面的示例，拥有多个相关模型是很常见的情况。

这对于用户模型尤其如此，因为:

- **输入模型** 需要能够包含密码
- **输出模型** 不应该包含密码
- **数据库模型** 可能需要包含哈希后的密码

!!! danger
永远不要存储用户的明文密码. 始终存储一个可以验证的"安全哈希".

    如果你不知道什么是"密码哈希", 将在安全章节中学习.

## 15.1 多个模型

以下是这些模型的外观及其密码字段和使用位置的大致思路:

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户输入模型 - 包含明文密码
class UserIn(BaseModel):
    username: str  # 用户名
    password: str  # 明文密码
    email: EmailStr  # 邮箱地址
    full_name: str | None = None  # 全名, 可选


# 用户输出模型 - 不包含密码
class UserOut(BaseModel):
    username: str  # 用户名
    email: EmailStr  # 邮箱地址
    full_name: str | None = None  # 全名, 可选


# 数据库中的用户模型 - 包含哈希密码
class UserInDB(BaseModel):
    username: str  # 用户名
    hashed_password: str  # 哈希后的密码
    email: EmailStr  # 邮箱地址
    full_name: str | None = None  # 全名, 可选


# 模拟密码哈希函数
def fake_password_hasher(raw_password: str):
    # 在实际应用中, 这里应该使用真正的密码哈希算法(如 bcrypt)
    return "supersecret" + raw_password


# 模拟保存用户到数据库的函数
def fake_save_user(user_in: UserIn):
    # 对用户密码进行哈希
    hashed_password = fake_password_hasher(user_in.password)
    # 从 UserIn 创建 UserInDB 对象
    # **user_in.dict() 会解包 UserIn 的所有字段
    # hashed_password=hashed_password 添加哈希密码字段
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")  # 实际应用中这里是真正的数据库保存操作
    return user_in_db


# 创建用户的路由端点
@app.post("/user/", response_model=UserOut)  # 指定响应模型为 UserOut, 不会返回密码
async def create_user(user_in: UserIn):
    # 保存用户(包括密码哈希处理)
    user_saved = fake_save_user(user_in)
    # 返回用户数据, FastAPI 会根据 response_model 自动过滤掉密码字段
    return user_saved
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户输入模型 - 包含明文密码
class UserIn(BaseModel):
    username: str  # 用户名
    password: str  # 明文密码
    email: EmailStr  # 邮箱地址
    full_name: Union[str, None] = None  # 全名, 可选


# 用户输出模型 - 不包含密码
class UserOut(BaseModel):
    username: str  # 用户名
    email: EmailStr  # 邮箱地址
    full_name: Union[str, None] = None  # 全名, 可选


# 数据库中的用户模型 - 包含哈希密码
class UserInDB(BaseModel):
    username: str  # 用户名
    hashed_password: str  # 哈希后的密码
    email: EmailStr  # 邮箱地址
    full_name: Union[str, None] = None  # 全名, 可选


# 模拟密码哈希函数
def fake_password_hasher(raw_password: str):
    # 在实际应用中, 这里应该使用真正的密码哈希算法(如 bcrypt)
    return "supersecret" + raw_password


# 模拟保存用户到数据库的函数
def fake_save_user(user_in: UserIn):
    # 对用户密码进行哈希
    hashed_password = fake_password_hasher(user_in.password)
    # 从 UserIn 创建 UserInDB 对象
    # **user_in.dict() 会解包 UserIn 的所有字段
    # hashed_password=hashed_password 添加哈希密码字段
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")  # 实际应用中这里是真正的数据库保存操作
    return user_in_db


# 创建用户的路由端点
@app.post("/user/", response_model=UserOut)  # 指定响应模型为 UserOut, 不会返回密码
async def create_user(user_in: UserIn):
    # 保存用户(包括密码哈希处理)
    user_saved = fake_save_user(user_in)
    # 返回用户数据, FastAPI 会根据 response_model 自动过滤掉密码字段
    return user_saved
```

!!! info
在 Pydantic v1 中, 该方法名为 `.dict()`, 在 Pydantic v2 中被弃用(但仍支持), 并重命名为 `.model_dump()`.

    这里的示例使用 `.dict()` 以保持与 Pydantic v1 的兼容性, 但如果你可以使用 Pydantic v2, 应该使用 `.model_dump()`.

### 15.1.1 关于 `**user_in.dict()`

#### Pydantic 的 `.dict()` 方法

`user_in` 是 `UserIn` 类的 Pydantic 模型.

Pydantic 模型有一个 `.dict()` 方法, 该方法返回一个包含模型数据的 `dict`.

因此, 如果我们创建一个 Pydantic 对象 `user_in`, 如:

```python
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
```

然后我们调用:

```python
user_dict = user_in.dict()
```

现在我们在变量 `user_dict` 中有了一个包含数据的 `dict` (它是 `dict` 而不是 Pydantic 模型对象).

如果我们调用:

```python
print(user_dict)
```

我们会得到一个 Python `dict`, 内容如下:

```python
{
    'username': 'john',
    'password': 'secret',
    'email': 'john.doe@example.com',
    'full_name': None,
}
```

#### 解包 `dict`

如果我们使用 `**user_dict` 将像 `user_dict` 这样的 `dict` 传递给函数(或类), Python 会"解包"它. 它会将 `user_dict` 的键和值直接作为键值参数传递.

因此, 继续使用上面的 `user_dict`, 编写:

```python
UserInDB(**user_dict)
```

结果等同于:

```python
UserInDB(
    username="john",
    password="secret",
    email="john.doe@example.com",
    full_name=None,
)
```

或者更准确地说, 直接使用 `user_dict`, 以及它未来可能包含的任何内容:

```python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
)
```

#### 从另一个 Pydantic 模型的内容创建 Pydantic 模型

正如上面的示例中我们从 `user_in.dict()` 获取 `user_dict`, 这段代码:

```python
user_dict = user_in.dict()
UserInDB(**user_dict)
```

等同于:

```python
UserInDB(**user_in.dict())
```

...因为 `user_in.dict()` 是一个 `dict`, 然后我们通过将它传递给带有 `**` 前缀的 `UserInDB` 来让 Python "解包"它.

因此, 我们从另一个 Pydantic 模型的数据中获取一个 Pydantic 模型.

#### 解包 `dict` 和额外的关键字

然后添加额外的关键字参数 `hashed_password=hashed_password`, 如:

```python
UserInDB(**user_in.dict(), hashed_password=hashed_password)
```

...最终结果类似于:

```python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    hashed_password = hashed_password,
)
```

!!! warning
支持函数 `fake_password_hasher` 和 `fake_save_user` 只是为了演示可能的数据流, 但它们当然不提供任何真正的安全性.

## 15.2 减少重复

减少代码重复是 **FastAPI** 的核心思想之一.

因为代码重复会增加出现 bug、安全问题、代码不同步问题(当你在一个地方更新但没有在其他地方更新)等的可能性.

而且这些模型都共享大量数据, 并重复属性名称和类型.

我们可以做得更好.

我们可以声明一个 `UserBase` 模型, 作为其他模型的基础. 然后我们可以创建该模型的子类, 继承其属性(类型声明、验证等).

所有数据转换、验证、文档等仍然可以正常工作.

这样, 我们只需声明模型之间的差异(使用明文 `password`, 使用 `hashed_password` 和不使用密码):

### Python 3.10+

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户基础模型 - 包含所有用户共享的字段
class UserBase(BaseModel):
    username: str  # 用户名
    email: EmailStr  # 邮箱地址
    full_name: str | None = None  # 全名, 可选


# 用户输入模型 - 继承 UserBase, 添加明文密码
class UserIn(UserBase):
    password: str  # 明文密码, 仅在输入时使用


# 用户输出模型 - 继承 UserBase, 不包含密码
class UserOut(UserBase):
    pass  # 不需要额外的字段, 只返回基础字段


# 数据库中的用户模型 - 继承 UserBase, 添加哈希密码
class UserInDB(UserBase):
    hashed_password: str  # 哈希后的密码, 存储在数据库中


# 模拟密码哈希函数
def fake_password_hasher(raw_password: str):
    # 在实际应用中, 这里应该使用真正的密码哈希算法(如 bcrypt)
    return "supersecret" + raw_password


# 模拟保存用户到数据库的函数
def fake_save_user(user_in: UserIn):
    # 对用户密码进行哈希
    hashed_password = fake_password_hasher(user_in.password)
    # 从 UserIn 创建 UserInDB 对象
    # **user_in.dict() 会解包 UserIn 的所有字段
    # hashed_password=hashed_password 添加哈希密码字段
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")  # 实际应用中这里是真正的数据库保存操作
    return user_in_db


# 创建用户的路由端点
@app.post("/user/", response_model=UserOut)  # 指定响应模型为 UserOut, 不会返回密码
async def create_user(user_in: UserIn):
    # 保存用户(包括密码哈希处理)
    user_saved = fake_save_user(user_in)
    # 返回用户数据, FastAPI 会根据 response_model 自动过滤掉密码字段
    return user_saved
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

# 创建 FastAPI 应用实例
app = FastAPI()


# 用户基础模型 - 包含所有用户共享的字段
class UserBase(BaseModel):
    username: str  # 用户名
    email: EmailStr  # 邮箱地址
    full_name: Union[str, None] = None  # 全名, 可选


# 用户输入模型 - 继承 UserBase, 添加明文密码
class UserIn(UserBase):
    password: str  # 明文密码, 仅在输入时使用


# 用户输出模型 - 继承 UserBase, 不包含密码
class UserOut(UserBase):
    pass  # 不需要额外的字段, 只返回基础字段


# 数据库中的用户模型 - 继承 UserBase, 添加哈希密码
class UserInDB(UserBase):
    hashed_password: str  # 哈希后的密码, 存储在数据库中


# 模拟密码哈希函数
def fake_password_hasher(raw_password: str):
    # 在实际应用中, 这里应该使用真正的密码哈希算法(如 bcrypt)
    return "supersecret" + raw_password


# 模拟保存用户到数据库的函数
def fake_save_user(user_in: UserIn):
    # 对用户密码进行哈希
    hashed_password = fake_password_hasher(user_in.password)
    # 从 UserIn 创建 UserInDB 对象
    # **user_in.dict() 会解包 UserIn 的所有字段
    # hashed_password=hashed_password 添加哈希密码字段
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")  # 实际应用中这里是真正的数据库保存操作
    return user_in_db


# 创建用户的路由端点
@app.post("/user/", response_model=UserOut)  # 指定响应模型为 UserOut, 不会返回密码
async def create_user(user_in: UserIn):
    # 保存用户(包括密码哈希处理)
    user_saved = fake_save_user(user_in)
    # 返回用户数据, FastAPI 会根据 response_model 自动过滤掉密码字段
    return user_saved
```

## 15.3 `Union` 或 `anyOf`

你可以将响应声明为两种或多种类型的 `Union`, 这意味着响应将是其中任何一种.

它将在 OpenAPI 中使用 `anyOf` 定义.

为此, 请使用标准的 Python 类型提示 `typing.Union`:

!!! note
定义 `Union` 时, 首先包含最具体的类型, 然后是不太具体的类型. 在下面的示例中, 更具体的 `PlaneItem` 在 `Union[PlaneItem, CarItem]` 中位于 `CarItem` 之前.

### Python 3.10+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 物品基础模型
class BaseItem(BaseModel):
    description: str  # 描述
    type: str  # 类型


# 汽车物品模型
class CarItem(BaseItem):
    type: str = "car"  # 类型默认为 "car"


# 飞机物品模型
class PlaneItem(BaseItem):
    type: str = "plane"  # 类型默认为 "plane"
    size: int  # 大小


# 模拟物品数据库
items = {
    "item1": {"description": "All my friends drive a low rider", "type": "car"},
    "item2": {
        "description": "Music is my aeroplane, it's my aeroplane",
        "type": "plane",
        "size": 5,
    },
}


# 获取物品的路由端点
# response_model=Union[PlaneItem, CarItem] 表示返回类型可能是 PlaneItem 或 CarItem
@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    return items[item_id]
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 物品基础模型
class BaseItem(BaseModel):
    description: str  # 描述
    type: str  # 类型


# 汽车物品模型
class CarItem(BaseItem):
    type: str = "car"  # 类型默认为 "car"


# 飞机物品模型
class PlaneItem(BaseItem):
    type: str = "plane"  # 类型默认为 "plane"
    size: int  # 大小


# 模拟物品数据库
items = {
    "item1": {"description": "All my friends drive a low rider", "type": "car"},
    "item2": {
        "description": "Music is my aeroplane, it's my aeroplane",
        "type": "plane",
        "size": 5,
    },
}


# 获取物品的路由端点
# response_model=Union[PlaneItem, CarItem] 表示返回类型可能是 PlaneItem 或 CarItem
@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    return items[item_id]
```

### 15.3.1 Python 3.10 中的 `Union`

在这个示例中, 我们将 `Union[PlaneItem, CarItem]` 作为参数 `response_model` 的值传递.

因为我们是将它作为 **参数的值** 传递, 而不是放在 **类型注解** 中, 所以即使在 Python 3.10 中也必须使用 `Union`.

如果它在类型注解中, 我们可以使用竖线, 如:

```python
some_variable: PlaneItem | CarItem
```

但是如果我们将其放在赋值 `response_model=PlaneItem | CarItem` 中, 我们会得到一个错误, 因为 Python 会尝试在 `PlaneItem` 和 `CarItem` 之间执行 **无效操作**, 而不是将其解释为类型注解.

## 15.4 模型列表

同样, 你可以声明对象列表的响应.

为此, 请使用标准的 Python `typing.List` (或者在 Python 3.9 及以上版本中直接使用 `list`):

### Python 3.9+

```python
from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 物品模型
class Item(BaseModel):
    name: str  # 名称
    description: str  # 描述


# 模拟物品列表数据库
items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]


# 获取所有物品的路由端点
# response_model=list[Item] 表示返回 Item 对象的列表
@app.get("/items/", response_model=list[Item])
async def read_items():
    return items
```

### Python 3.8+

```python
from typing import List

from fastapi import FastAPI
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()


# 物品模型
class Item(BaseModel):
    name: str  # 名称
    description: str  # 描述


# 模拟物品列表数据库
items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]


# 获取所有物品的路由端点
# response_model=List[Item] 表示返回 Item 对象的列表
@app.get("/items/", response_model=List[Item])
async def read_items():
    return items
```

## 15.5 使用任意 `dict` 的响应

你还可以使用普通的任意 `dict` 声明响应, 仅声明键和值的类型, 而不使用 Pydantic 模型.

如果你事先不知道有效的字段/属性名称(这是 Pydantic 模型所需要的), 这很有用.

在这种情况下, 你可以使用 `typing.Dict` (或者在 Python 3.9 及以上版本中直接使用 `dict`):

### Python 3.9+

```python
from fastapi import FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()


# 获取关键词权重的路由端点
# response_model=dict[str, float] 表示返回一个字典
# 键是字符串类型, 值是浮点数类型
@app.get("/keyword-weights/", response_model=dict[str, float])
async def read_keyword_weights():
    return {"foo": 2.3, "bar": 3.4}
```

### Python 3.8+

```python
from typing import Dict

from fastapi import FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()


# 获取关键词权重的路由端点
# response_model=Dict[str, float] 表示返回一个字典
# 键是字符串类型, 值是浮点数类型
@app.get("/keyword-weights/", response_model=Dict[str, float])
async def read_keyword_weights():
    return {"foo": 2.3, "bar": 3.4}
```

## 15.6 总结

为每种情况使用多个 Pydantic 模型并自由继承.

如果一个实体必须能够具有不同的"状态", 你不需要为每个实体设置单一数据模型. 例如, 用户"实体"的状态包括 `password`(明文密码)、`password_hash`(哈希密码)和无密码.

---

## 本章要点

1. **多个模型的使用场景**

   - 输入模型: 包含用户提交的所有数据(如明文密码)
   - 输出模型: 只包含可以公开返回的数据(排除敏感信息)
   - 数据库模型: 包含存储在数据库中的数据(如哈希密码)

2. **减少代码重复**

   - 创建基础模型(如 UserBase)包含共享字段
   - 使用继承创建特定的变体模型
   - 避免重复定义相同的字段和类型

3. **`Union` 类型**

   - 使用 Union 声明响应可能是多种类型之一
   - 在 OpenAPI 中生成 `anyOf` 定义
   - 注意在函数参数中必须使用 `Union[...]`, 不能使用 `|` 语法

4. **列表响应**

   - 使用 `list[Model]` (Python 3.9+) 或 `List[Model]` (Python 3.8)
   - 返回对象数组

5. **字典响应**
   - 使用 `dict[key_type, value_type]` 声明任意字典响应
   - 适用于键名不确定的场景
