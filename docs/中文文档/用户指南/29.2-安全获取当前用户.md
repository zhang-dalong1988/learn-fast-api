# 29.2 安全 - 获取当前用户

在上一章中, 安全系统 (基于依赖注入系统) 向路径操作函数提供了一个 `str` 类型的 `token`:

Python 3.9+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ non-Annotated

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# Annotated[str, Depends(oauth2_scheme)] 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    # 返回包含 token 的字典
    return {"token": token}
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义一个 GET 路由操作, 路径为 /items/
# token 参数通过 Depends(oauth2_scheme) 依赖注入自动获取
# token: str = Depends(oauth2_scheme) 表示 token 的类型是 str, 并且从 oauth2_scheme 获取
@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    # 返回包含 token 的字典
    return {"token": token}
```

但这还不够有用.

让我们让它给我们当前用户.

## 1. 创建用户模型

首先, 让我们创建一个 Pydantic 用户模型.

就像我们使用 Pydantic 声明请求体一样, 我们可以在任何其他地方使用它:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.9+ non-Annotated

```python
# 从 typing 模块导入 Annotated 和 Union, 用于类型注解
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ non-Annotated

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.10+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

## 2. 创建 `get_current_user` 依赖

让我们创建一个依赖 `get_current_user`.

还记得依赖可以有子依赖吗?

`get_current_user` 将具有与之前创建的相同的 `oauth2_scheme` 依赖.

就像我们之前直接在路径操作中所做的一样, 我们的新依赖 `get_current_user` 将从子依赖 `oauth2_scheme` 接收一个 `str` 类型的 `token`:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入, oauth2_scheme 是 get_current_user 的子依赖
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.9+ non-Annotated

```python
# 从 typing 模块导入 Annotated 和 Union, 用于类型注解
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入, oauth2_scheme 是 get_current_user 的子依赖
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ non-Annotated

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入, oauth2_scheme 是 get_current_user 的子依赖
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.10+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入, oauth2_scheme 是 get_current_user 的子依赖
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入, oauth2_scheme 是 get_current_user 的子依赖
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

## 3. 获取用户

`get_current_user` 将使用我们创建的一个 (伪造) 工具函数, 该函数接受一个 `str` 类型的 token 并返回我们的 Pydantic `User` 模型:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
# 该函数使用子依赖 oauth2_scheme 获取 token, 然后使用 fake_decode_token 解码 token 并返回用户信息
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.9+ non-Annotated

```python
# 从 typing 模块导入 Annotated 和 Union, 用于类型注解
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
# 该函数使用子依赖 oauth2_scheme 获取 token, 然后使用 fake_decode_token 解码 token 并返回用户信息
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ non-Annotated

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
# 该函数使用子依赖 oauth2_scheme 获取 token, 然后使用 fake_decode_token 解码 token 并返回用户信息
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.10+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
# 该函数使用子依赖 oauth2_scheme 获取 token, 然后使用 fake_decode_token 解码 token 并返回用户信息
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
# 该函数使用子依赖 oauth2_scheme 获取 token, 然后使用 fake_decode_token 解码 token 并返回用户信息
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

## 4. 注入当前用户

所以现在我们可以在路径操作中使用相同的 `Depends` 和我们的 `get_current_user`:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.9+ non-Annotated

```python
# 从 typing 模块导入 Annotated 和 Union, 用于类型注解
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ non-Annotated

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# Annotated[User, Depends(get_current_user)] 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.10+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# current_user: User = Depends(get_current_user) 表示 current_user 的类型是 User, 并且从 get_current_user 获取
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

注意, 我们将 `current_user` 的类型声明为 Pydantic 模型 `User`.

这将帮助我们在函数内部进行所有补全和类型检查.

提示, 你可能还记得请求体也是用 Pydantic 模型声明的.

在这里 __FastAPI__ 不会感到困惑, 因为你使用的是 `Depends`.

检查, 这种依赖系统的设计允许我们拥有不同的依赖 (不同的 "可依赖对象"), 它们都返回一个 `User` 模型.

我们不受限于只能有一个可以返回该类型数据的依赖.

## 5. 其他模型

你现在可以直接在路径操作函数中获取当前用户, 并在依赖注入级别使用 `Depends` 处理安全机制.

你可以为安全要求使用任何模型或数据 (在本例中, 是一个 Pydantic 模型 `User` ).

但你不受限于使用某些特定的数据模型, 类或类型.

你想在你的模型中有一个 `id` 和 `email` 而没有任何 `username` 吗? 当然可以. 你可以使用这些相同的工具.

你想只有一个 `str` 吗? 或者只有一个 `dict`? 或者直接一个数据库类模型实例? 它们的工作方式都是一样的.

实际上, 你的应用程序中没有登录的用户, 而是只有访问令牌的机器人, 机器人或其他系统? 同样, 它们的工作方式都是一样的.

只需使用你的应用程序所需的任何类型的模型, 任何类型的类, 任何类型的数据库. __FastAPI__ 通过依赖注入系统为你提供了全面支持.

## 6. 代码大小

这个示例可能看起来很冗长. 请记住, 我们在同一个文件中混合了安全性, 数据模型, 工具函数和路径操作.

但这里是关键点.

安全性和依赖注入的内容只编写一次.

你可以让它变得尽可能复杂. 但是, 只需在一个地方编写一次. 具有所有的灵活性.

但是你可以拥有数千个使用相同安全系统的端点 (路径操作).

并且所有这些端点 (或你想要的任何部分) 都可以利用重用这些依赖或你创建的任何其他依赖.

所有这些数千个路径操作可以小到只有 3 行:

Python 3.10+

```python
# 从 typing 模块导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# 这就是路径操作函数的主要逻辑, 只有 3 行代码
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.9+ non-Annotated

```python
# 从 typing 模块导入 Annotated 和 Union, 用于类型注解
from typing import Annotated, Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# 这就是路径操作函数的主要逻辑, 只有 3 行代码
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ non-Annotated

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# 这就是路径操作函数的主要逻辑, 只有 3 行代码
@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    # 返回当前用户信息
    return current_user
```

Python 3.10+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: str | None = None  # 电子邮件, 可选字段
    full_name: str | None = None  # 全名, 可选字段
    disabled: bool | None = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# 这就是路径操作函数的主要逻辑, 只有 3 行代码
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

Python 3.8+ (without Annotated)

提示, 如果可能, 尽量使用 `Annotated` 版本.

```python
# 从 typing 模块导入 Union, 用于类型注解
from typing import Union

# 从 fastapi 导入 Depends 和 FastAPI
from fastapi import Depends, FastAPI
# 从 fastapi.security 导入 OAuth2PasswordBearer, 用于 OAuth2 密码流认证
from fastapi.security import OAuth2PasswordBearer
# 从 pydantic 导入 BaseModel, 用于数据模型
from pydantic import BaseModel

# 创建 FastAPI 应用实例
app = FastAPI()

# 创建 OAuth2PasswordBearer 实例
# tokenUrl="token" 指定客户端获取 token 的 URL 地址
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 定义 User 数据模型, 继承自 BaseModel
class User(BaseModel):
    username: str  # 用户名, 必填字段
    email: Union[str, None] = None  # 电子邮件, 可选字段
    full_name: Union[str, None] = None  # 全名, 可选字段
    disabled: Union[bool, None] = None  # 是否禁用, 可选字段

# 定义一个伪造的 token 解码函数
# 在实际应用中, 这里应该是真实的 token 验证和解码逻辑
def fake_decode_token(token):
    # 返回一个 User 对象, username 为 token 加上 "fakedecoded" 后缀
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

# 定义 get_current_user 依赖函数
# token 参数通过 Depends(oauth2_scheme) 自动注入
async def get_current_user(token: str = Depends(oauth2_scheme)):
    # 使用 fake_decode_token 函数解码 token 并获取用户信息
    user = fake_decode_token(token)
    # 返回用户对象
    return user

# 定义一个 GET 路由操作, 路径为 /users/me
# current_user 参数通过 Depends(get_current_user) 依赖注入自动获取
# 这就是路径操作函数的主要逻辑, 只有 3 行代码
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    # 返回当前用户信息
    return current_user
```

## 7. 总结

你现在可以直接在你的路径操作函数中获取当前用户.

我们已经完成了一半.

我们只需要添加一个路径操作, 以便用户/客户端实际发送 `username` 和 `password`.

接下来就是这部分内容.
