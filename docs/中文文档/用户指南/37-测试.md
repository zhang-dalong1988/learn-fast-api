# 测试

多亏了 Starlette, 测试 __FastAPI__ 应用程序变得简单而愉快。

它基于 HTTPX, 而 HTTPX 又是基于 Requests 设计的, 因此它非常熟悉和直观。

有了它, 你可以直接在 __FastAPI__ 中使用 pytest。

## 1. 使用 `TestClient`

### 信息提示

要使用 `TestClient`, 首先安装 `httpx`。

确保你创建了一个虚拟环境, 激活它, 然后安装它, 例如:

```bash
$ pip install httpx
```

导入 `TestClient`。

通过将你的 __FastAPI__ 应用程序传递给它来创建一个 `TestClient`。

创建名称以 `test_` 开头的函数（这是标准的 `pytest` 约定）。

像使用 `httpx` 一样使用 `TestClient` 对象。

使用你需要检查的标准 Python 表达式编写简单的 `assert` 语句（同样, 是标准的 `pytest`）。

**Python 3.8+**

```python
# 从 fastapi 导入 FastAPI
from fastapi import FastAPI
# 从 fastapi.testclient 导入 TestClient
# TestClient 用于在测试中模拟 HTTP 请求
from fastapi.testclient import TestClient

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个简单的 GET 路径操作
@app.get("/")
async def read_main():
    return {"msg": "Hello World"}

# 创建测试客户端, 传入 FastAPI 应用实例
client = TestClient(app)

# 定义测试函数
# 函数名必须以 test_ 开头, 这样 pytest 才能自动发现它
def test_read_main():
    # 使用测试客户端发送 GET 请求到根路径
    response = client.get("/")
    # 断言状态码为 200
    assert response.status_code == 200
    # 断言响应 JSON 数据与预期一致
    assert response.json() == {"msg": "Hello World"}
```

### 提示

请注意, 测试函数是普通的 `def`, 不是 `async def`。

对客户端的调用也是普通调用, 不使用 `await`。

这允许你直接使用 `pytest` 而没有复杂性。

### 技术细节

你也可以使用 `from starlette.testclient import TestClient`。

__FastAPI__ 将相同的 `starlette.testclient` 作为 `fastapi.testclient` 提供, 只是为了方便你, 开发者。但它直接来自 Starlette。

### 提示

如果你想测试中调用 `async` 函数（除了向 FastAPI 应用程序发送请求之外, 例如异步数据库函数）, 请查看高级教程中的异步测试。

## 2. 分离测试

在实际应用程序中, 你可能会将测试放在不同的文件中。

而且你的 __FastAPI__ 应用程序也可能由多个文件/模块组成等。

### 2.1 __FastAPI__ 应用文件

假设你的文件结构如"更大的应用"中所述:

```
.
├── app
│   ├── __init__.py
│   └── main.py
```

在文件 `main.py` 中有你的 __FastAPI__ 应用:

**Python 3.8+**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def read_main():
    return {"msg": "Hello World"}
```

### 2.2 测试文件

然后你可以有一个文件 `test_main.py` 包含你的测试。它可以位于同一个 Python 包中（同一个目录, 带有 `__init__.py` 文件）:

```
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
```

因为这个文件在同一个包中, 你可以使用相对导入从 `main` 模块（`main.py`）导入对象 `app`:

**Python 3.8+**

```python
# 从 fastapi.testclient 导入 TestClient
from fastapi.testclient import TestClient

# 使用相对导入从 main 模块导入 app
# .main 表示同一目录下的 main.py
from .main import app

# 创建测试客户端
client = TestClient(app)

# 定义测试函数
def test_read_main():
    # 发送 GET 请求
    response = client.get("/")
    # 验证响应
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}
```

...测试代码就像之前一样。

## 3. 测试：扩展示例

现在让我们扩展这个示例并添加更多细节, 以查看如何测试不同的部分。

### 3.1 扩展的 __FastAPI__ 应用文件

让我们继续使用之前的相同文件结构:

```
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
```

假设现在包含你的 __FastAPI__ 应用的文件 `main.py` 有一些其他路径操作。

它有一个可能返回错误的 `GET` 操作。

它有一个可能返回多个错误的 `POST` 操作。

两个路径操作都需要一个 `X-Token` header。

**Python 3.10+**

```python
# 从 typing 导入 Annotated, 用于类型注解
from typing import Annotated

# 从 fastapi 导入必要的组件
from fastapi import FastAPI, Header, HTTPException
# 从 pydantic 导入 BaseModel
from pydantic import BaseModel

# 模拟的密钥 token
fake_secret_token = "coneofsilence"

# 模拟的数据库
fake_db = {
    "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
    "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
}

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 Item 模型
class Item(BaseModel):
    id: str
    title: str
    description: str | None = None

# 定义 GET 路径操作, 根据 ID 获取物品
@app.get("/items/{item_id}", response_model=Item)
async def read_main(item_id: str, x_token: Annotated[str, Header()]):
    # 验证 token
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    # 检查物品是否存在
    if item_id not in fake_db:
        raise HTTPException(status_code=404, detail="Item not found")
    # 返回物品数据
    return fake_db[item_id]

# 定义 POST 路径操作, 创建新物品
@app.post("/items/", response_model=Item)
async def create_item(item: Item, x_token: Annotated[str, Header()]):
    # 验证 token
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    # 检查物品是否已存在
    if item.id in fake_db:
        raise HTTPException(status_code=409, detail="Item already exists")
    # 保存到数据库
    fake_db[item.id] = item
    return item
```

### 3.2 扩展的测试文件

然后你可以用扩展的测试更新 `test_main.py`:

**Python 3.8+**

```python
from fastapi.testclient import TestClient

from .main import app

client = TestClient(app)

# 测试读取存在的物品
def test_read_item():
    # 发送 GET 请求, 携带正确的 token
    response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
    assert response.status_code == 200
    assert response.json() == {
        "id": "foo",
        "title": "Foo",
        "description": "There goes my hero",
    }

# 测试使用错误的 token
def test_read_item_bad_token():
    # 使用错误的 token
    response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
    assert response.status_code == 400
    assert response.json() == {"detail": "Invalid X-Token header"}

# 测试读取不存在的物品
def test_read_nonexistent_item():
    # 请求不存在的物品 ID
    response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
    assert response.status_code == 404
    assert response.json() == {"detail": "Item not found"}

# 测试创建新物品
def test_create_item():
    # 发送 POST 请求创建新物品
    response = client.post(
        "/items/",
        headers={"X-Token": "coneofsilence"},
        json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
    )
    assert response.status_code == 200
    assert response.json() == {
        "id": "foobar",
        "title": "Foo Bar",
        "description": "The Foo Barters",
    }

# 测试使用错误 token 创建物品
def test_create_item_bad_token():
    response = client.post(
        "/items/",
        headers={"X-Token": "hailhydra"},
        json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
    )
    assert response.status_code == 400
    assert response.json() == {"detail": "Invalid X-Token header"}

# 测试创建已存在的物品
def test_create_existing_item():
    response = client.post(
        "/items/",
        headers={"X-Token": "coneofsilence"},
        json={
            "id": "foo",
            "title": "The Foo ID Stealers",
            "description": "There goes my stealer",
        },
    )
    assert response.status_code == 409
    assert response.json() == {"detail": "Item already exists"}
```

每当你需要客户端在请求中传递信息而你不知道如何操作时, 你可以搜索（Google）如何在 `httpx` 中执行此操作, 或者甚至如何使用 `requests` 执行此操作, 因为 HTTPX 的设计基于 Requests 的设计。

然后你只需在测试中做同样的事情。

例如:

- 要传递路径或查询参数, 将其添加到 URL 本身。
- 要传递 JSON 主体, 将 Python 对象（例如 `dict`）传递给参数 `json`。
- 如果你需要发送表单数据而不是 JSON, 请改用 `data` 参数。
- 要传递 headers, 在 `headers` 参数中使用 `dict`。
- 对于 cookies, 在 `cookies` 参数中使用 `dict`。

有关如何将数据传递给后端（使用 `httpx` 或 `TestClient`）的更多信息, 请查看 HTTPX 文档。

### 信息提示

请注意, `TestClient` 接收可以转换为 JSON 的数据, 而不是 Pydantic 模型。

如果你在测试中有 Pydantic 模型, 并且想在测试期间将其数据发送到应用程序, 你可以使用 JSON 兼容编码器中描述的 `jsonable_encoder`。

## 4. 运行测试

之后, 你只需要安装 `pytest`。

确保你创建了一个虚拟环境, 激活它, 然后安装它, 例如:

```bash
$ pip install pytest

---> 100%
```

它会自动检测文件和测试, 执行它们, 并向你报告结果。

使用以下命令运行测试:

```bash
$ pytest

================ test session starts ================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items

---> 100%

test_main.py ......                            [100%]

================= 6 passed in 0.03s =================
```
