# 依赖 - 全局依赖

对于某些类型的应用程序, 你可能想要将依赖项添加到整个应用程序。

类似于将 `dependencies` 添加到 _路径操作装饰器_ 的方式, 你可以将它们添加到 `FastAPI` 应用程序。

在这种情况下, 它们将被应用于应用程序中的所有 _路径操作_:

### Python 3.9+

```python
# 从 fastapi 导入依赖项相关类
# Depends: 用于声明依赖项
# FastAPI: 应用主类
# Header: 用于获取 Header 参数
# HTTPException: 用于抛出 HTTP 异常
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated, 用于类型注解
from typing_extensions import Annotated

# 定义 verify_token 依赖函数
# x_token: 从 Header 中获取的 X-Token 参数, 类型为字符串
async def verify_token(x_token: Annotated[str, Header()]):
    # 如果 token 不等于预设的密钥
    if x_token != "fake-super-secret-token":
        # 抛出 HTTP 400 异常, 表示 X-Token header 无效
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# x_key: 从 Header 中获取的 X-Key 参数, 类型为字符串
async def verify_key(x_key: Annotated[str, Header()]):
    # 如果 key 不等于预设的密钥
    if x_key != "fake-super-secret-key":
        # 抛出 HTTP 400 异常, 表示 X-Key header 无效
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 创建 FastAPI 应用实例
# dependencies 参数接收一个依赖项列表
# 这些依赖项将应用于应用程序中的所有路径操作
app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])

# 定义 GET 路径操作 /items/
# 这个路径操作会自动继承全局依赖项
# 在执行前会先验证 verify_token 和 verify_key
@app.get("/items/")
async def read_items():
    # 返回一个包含两个项目的列表
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]

# 定义 GET 路径操作 /users/
# 这个路径操作也会自动继承全局依赖项
# 同样需要在执行前验证 token 和 key
@app.get("/users/")
async def read_users():
    # 返回一个包含两个用户的列表
    return [{"username": "Rick"}, {"username": "Morty"}]
```

### Python 3.8+

```python
# 从 fastapi 导入依赖项相关类
from fastapi import Depends, FastAPI, Header, HTTPException
# 从 typing_extensions 导入 Annotated (Python 3.8 需要使用 typing_extensions)
from typing_extensions import Annotated

# 定义 verify_token 依赖函数
# 验证请求头中的 X-Token 是否有效
async def verify_token(x_token: Annotated[str, Header()]):
    # 检查 token 是否匹配预设值
    if x_token != "fake-super-secret-token":
        # 如果不匹配, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# 验证请求头中的 X-Key 是否有效
async def verify_key(x_key: Annotated[str, Header()]):
    # 检查 key 是否匹配预设值
    if x_key != "fake-super-secret-key":
        # 如果不匹配, 抛出 400 错误
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 创建 FastAPI 应用实例, 声明全局依赖项
# 所有路径操作都会应用这些依赖项
app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])

# 定义 /items/ 路径操作
# 全局依赖项会自动应用
@app.get("/items/")
async def read_items():
    # 返回项目列表
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]

# 定义 /users/ 路径操作
# 同样受到全局依赖项的保护
@app.get("/users/")
async def read_users():
    # 返回用户列表
    return [{"username": "Rick"}, {"username": "Morty"}]
```

**提示**

如果可能, 尽量使用 `Annotated` 版本。

### Python 3.8+ 不使用 Annotated

```python
# 从 fastapi 导入依赖项相关类
from fastapi import Depends, FastAPI, Header, HTTPException

# 定义 verify_token 依赖函数
# x_token: 字符串类型的 Header 参数, 使用默认的 Header() 获取
async def verify_token(x_token: str = Header()):
    # 验证 token 是否有效
    if x_token != "fake-super-secret-token":
        # token 无效时抛出异常
        raise HTTPException(status_code=400, detail="X-Token header invalid")

# 定义 verify_key 依赖函数
# x_key: 字符串类型的 Header 参数
async def verify_key(x_key: str = Header()):
    # 验证 key 是否有效
    if x_key != "fake-super-secret-key":
        # key 无效时抛出异常
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    # 返回 key 值
    return x_key

# 创建 FastAPI 应用实例
# 在应用级别声明依赖项, 适用于所有路径操作
app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])

# 定义路径操作
# 不需要额外声明依赖项, 全局依赖会自动应用
@app.get("/items/")
async def read_items():
    # 返回项目数据
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]

# 定义路径操作
# 同样受到全局依赖项的约束
@app.get("/users/")
async def read_users():
    # 返回用户数据
    return [{"username": "Rick"}, {"username": "Morty"}]
```

关于将 `dependencies` 添加到 _路径操作装饰器_ 的部分中的所有概念仍然适用, 但在这种情况下, 它适用于应用程序中的所有 _路径操作_。

## 1. 为一组 _路径操作_ 声明依赖项

稍后, 在阅读如何构建更大的应用程序 (Bigger Applications - Multiple Files), 可能包含多个文件时, 你将学习如何为一组 _路径操作_ 声明单个 `dependencies` 参数。
