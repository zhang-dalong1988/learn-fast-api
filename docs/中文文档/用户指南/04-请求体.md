# 请求体

当你需要从客户端 (比如浏览器) 向你的 API 发送数据时, 你将其作为 **请求体** 发送。

**请求** 体是客户端发送给你的 API 的数据。**响应** 体是你的 API 发送给客户端的数据。

你的 API 几乎总是需要发送 **响应** 体。但客户端不一定总是需要发送 **请求** 体, 有时它们只是请求一个路径, 可能带有一些查询参数, 但不发送请求体。

要声明 **请求** 体, 你使用 Pydantic 模型及其所有功能和优势。

**提示**

要发送数据, 你应该使用以下方法之一: `POST` (更常见), `PUT`, `DELETE` 或 `PATCH`。

使用 `GET` 请求发送请求体在规范中具有未定义的行为, 尽管如此, FastAPI 仍然支持它, 仅用于非常复杂/极端的用例。

由于不推荐这样做, 当使用 `GET` 时, Swagger UI 的交互式文档不会显示请求体的文档, 中间代理可能不支持它。

## 1. 导入 Pydantic 的 `BaseModel`

首先, 你需要从 `pydantic` 导入 `BaseModel`:

### 1.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

### 1.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

## 2. 创建数据模型

然后你将数据模型声明为继承自 `BaseModel` 的类。

为所有属性使用标准 Python 类型:

### 2.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

### 2.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

与声明查询参数相同, 当模型属性具有默认值时, 它不是必需的。否则, 它是必需的。使用 `None` 使其只是可选的。

例如, 上面的这个模型声明了一个 JSON "`object`" (或 Python `dict`), 像这样:

```json
{
    "name": "Foo",
    "description": "An optional description",
    "price": 45.2,
    "tax": 3.5
}
```

...由于 `description` 和 `tax` 是可选的 (默认值为 `None`), 这个 JSON "`object`" 也是有效的:

```json
{
    "name": "Foo",
    "price": 45.2
}
```

## 3. 将其声明为参数

要将其添加到你的 *路径操作* 中, 像声明路径和查询参数一样声明它:

### 3.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

### 3.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 直接返回接收到的 item 对象
    return item
```

...并将其类型声明为你创建的模型 `Item`。

## 4. 结果

仅通过那个 Python 类型声明, **FastAPI** 将:

- 将请求体作为 JSON 读取。
- 转换相应的类型 (如果需要)。
- 验证数据。
  - 如果数据无效, 它将返回一个漂亮清晰的错误, 准确指示错误数据的位置和内容。
- 在参数 `item` 中给你接收到的数据。
  - 由于你在函数中将其声明为 `Item` 类型, 你还将获得所有属性及其类型的所有编辑器支持 (自动补全等)。
- 为你的模型生成 JSON Schema 定义, 如果对你的项目有意义, 你也可以在其他任何地方使用它们。
- 这些模式将成为生成的 OpenAPI 模式的一部分, 并被自动文档 UI 使用。

## 5. 自动文档

模型的 JSON Schemas 将成为你生成的 OpenAPI 模式的一部分, 并将在交互式 API 文档中显示。

并且还将在每个需要它们的 *路径操作* 内的 API 文档中使用。

## 6. 编辑器支持

在你的编辑器中, 在你的函数内部, 你将处处获得类型提示和自动补全 (如果你接收的是 `dict` 而不是 Pydantic 模型, 这就不会发生)。

你还会获得针对错误类型操作的错误检查。

这并非偶然, 整个框架都是围绕这种设计构建的。

并且在设计阶段进行了彻底的测试, 在任何实现之前, 以确保它可以与所有编辑器一起工作。

甚至 Pydantic 本身也有一些更改来支持这一点。

前面的截图是使用 Visual Studio Code 截取的。

但你在 PyCharm 和大多数其他 Python 编辑器中也会获得相同的编辑器支持。

**提示**

如果你使用 PyCharm 作为编辑器, 你可以使用 Pydantic PyCharm 插件。

它改善了 Pydantic 模型的编辑器支持, 具有:
- 自动补全
- 类型检查
- 重构
- 搜索
- 检查

## 7. 使用模型

在函数内部, 你可以直接访问模型对象的所有属性:

### 7.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 将 item 对象转换为字典
    item_dict = item.dict()
    # 如果提供了税费, 则计算含税价格
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        # 将含税价格添加到字典中
        item_dict.update({"price_with_tax": price_with_tax})
    # 返回包含含税价格的字典
    return item_dict
```

### 7.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 POST 路径操作, 接收 Item 模型作为请求体
@app.post("/items/")
async def create_item(item: Item):
    # 将 item 对象转换为字典
    item_dict = item.dict()
    # 如果提供了税费, 则计算含税价格
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        # 将含税价格添加到字典中
        item_dict.update({"price_with_tax": price_with_tax})
    # 返回包含含税价格的字典
    return item_dict
```

**提示**

在 Pydantic v1 中, 该方法称为 `.dict()`, 在 Pydantic v2 中被弃用 (但仍受支持), 并重命名为 `.model_dump()`。

这里的示例使用 `.dict()` 以兼容 Pydantic v1, 但如果你可以使用 Pydantic v2, 应该使用 `.model_dump()`。

## 8. 请求体 + 路径参数

你可以同时声明路径参数和请求体。

**FastAPI** 将识别与路径参数匹配的函数参数应该 *从路径中获取*, 而声明为 Pydantic 模型的函数参数应该 *从请求体中获取*。

### 8.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 PUT 路径操作, 包含路径参数和请求体
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    # 返回包含 item_id 和 item 所有字段的字典
    return {"item_id": item_id, **item.dict()}
```

### 8.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 PUT 路径操作, 包含路径参数和请求体
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    # 返回包含 item_id 和 item 所有字段的字典
    return {"item_id": item_id, **item.dict()}
```

## 9. 请求体 + 路径 + 查询参数

你还可以同时声明 **请求体**, **路径** 和 **查询** 参数。

**FastAPI** 将识别每个参数并从正确的位置获取数据。

### 9.1 Python 3.10+

```python
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: str | None = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: float | None = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 PUT 路径操作, 包含路径参数, 请求体和查询参数
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: str | None = None):
    # 创建包含 item_id 和 item 所有字段的字典
    result = {"item_id": item_id, **item.dict()}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        result.update({"q": q})
    # 返回结果
    return result
```

### 9.2 Python 3.8+

```python
# 从 typing 模块导入 Union 类型
from typing import Union
# 导入 FastAPI 框架
from fastapi import FastAPI
# 从 pydantic 导入 BaseModel 基类
from pydantic import BaseModel


# 定义 Item 数据模型, 继承自 BaseModel
class Item(BaseModel):
    name: str  # 名称字段, 必填, 字符串类型
    description: Union[str, None] = None  # 描述字段, 可选, 字符串或 None
    price: float  # 价格字段, 必填, 浮点数类型
    tax: Union[float, None] = None  # 税费字段, 可选, 浮点数或 None


# 创建 FastAPI 应用实例
app = FastAPI()


# 定义 PUT 路径操作, 包含路径参数, 请求体和查询参数
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    # 创建包含 item_id 和 item 所有字段的字典
    result = {"item_id": item_id, **item.dict()}
    # 如果提供了查询参数 q, 则将其添加到结果中
    if q:
        result.update({"q": q})
    # 返回结果
    return result
```

函数参数将被识别如下:

- 如果参数也在 **路径** 中声明, 它将被用作路径参数。
- 如果参数是 **单一类型** (如 `int`, `float`, `str`, `bool` 等), 它将被解释为 **查询** 参数。
- 如果参数被声明为 **Pydantic 模型** 的类型, 它将被解释为请求 **体**。

**注意**

FastAPI 将知道 `q` 的值不是必需的, 因为默认值 `= None`。

`str | None` (Python 3.10+) 或 `Union[str, None]` 中的 `Union` (Python 3.8+) 不被 FastAPI 用于确定该值不是必需的, 它将知道它不是必需的, 因为它的默认值为 `= None`。

但是添加类型注解将允许你的编辑器给你更好的支持并检测错误。

## 10. 不使用 Pydantic

如果你不想使用 Pydantic 模型, 你也可以使用 **Body** 参数。参见 Body - 多个参数: 请求体中的单一值的文档。
