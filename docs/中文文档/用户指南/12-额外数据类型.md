# 11. 额外数据类型

到目前为止, 你一直在使用常见的数据类型, 比如:

- `int`
- `float`
- `str`
- `bool`

但你也可以使用更复杂的数据类型.

你仍然可以获得与之前相同的功能:

- 出色的编辑器支持
- 来自传入请求的数据转换
- 响应数据的数据转换
- 数据验证
- 自动注释和文档

## 11.1 其他数据类型

以下是一些你可以使用的额外数据类型:

- `UUID`:
  - 标准的"通用唯一标识符", 在许多数据库和系统中常用作 ID
  - 在请求和响应中将表示为 `str`
- `datetime.datetime`:
  - Python `datetime.datetime`
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`, 例如: `2008-09-15T15:53:00+05:00`
- `datetime.date`:
  - Python `datetime.date`
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`, 例如: `2008-09-15`
- `datetime.time`:
  - Python `datetime.time`
  - 在请求和响应中将表示为 ISO 8601 格式的 `str`, 例如: `14:23:55.003`
- `datetime.timedelta`:
  - Python `datetime.timedelta`
  - 在请求和响应中将表示为总秒数的 `float`
  - Pydantic 还允许将其表示为"ISO 8601 时间差编码", 有关更多信息, 请参阅文档
- `frozenset`:
  - 在请求和响应中, 与 `set` 的处理方式相同:
    - 在请求中, 将读取列表, 消除重复项并将其转换为 `set`
    - 在响应中, `set` 将转换为 `list`
    - 生成的模式将指定 `set` 值是唯一的(使用 JSON Schema 的 `uniqueItems`)
- `bytes`:
  - 标准 Python `bytes`
  - 在请求和响应中将被视为 `str`
  - 生成的模式将指定它是具有 `binary` "格式"的 `str`
- `Decimal`:
  - 标准 Python `Decimal`
  - 在请求和响应中, 与 `float` 的处理方式相同
  - 你可以在此处查看所有有效的 Pydantic 数据类型: Pydantic data types

## 11.2 示例

这是一个使用上述某些类型的路径操作示例.

### Python 3.10+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Annotated, 用于添加类型元数据
from typing import Annotated
# 从 uuid 模块导入 UUID, 用于处理通用唯一标识符
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作, 路径参数 item_id 为 UUID 类型
@app.put("/items/{item_id}")
async def read_items(
    # 路径参数: UUID 类型的物品 ID
    item_id: UUID,
    # 请求体参数: 开始日期时间, 使用 Body() 标记为请求体字段
    start_datetime: Annotated[datetime, Body()],
    # 请求体参数: 结束日期时间, 使用 Body() 标记为请求体字段
    end_datetime: Annotated[datetime, Body()],
    # 请求体参数: 处理时间间隔, 使用 Body() 标记为请求体字段
    process_after: Annotated[timedelta, Body()],
    # 请求体参数: 重复时间(可选), 默认值为 None
    repeat_at: Annotated[time | None, Body()] = None,
):
    # 计算实际开始处理时间: 开始时间 + 延迟时间
    start_process = start_datetime + process_after
    # 计算持续时间: 结束时间 - 实际开始时间
    duration = end_datetime - start_process
    # 返回包含所有计算结果的字典
    return {
        "item_id": item_id,          # UUID 类型的物品 ID
        "start_datetime": start_datetime,  # 开始日期时间
        "end_datetime": end_datetime,      # 结束日期时间
        "process_after": process_after,    # 延迟时间间隔
        "repeat_at": repeat_at,            # 重复时间
        "start_process": start_process,    # 实际开始处理时间
        "duration": duration,              # 持续时间
    }
```

### Python 3.9+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: Annotated[datetime, Body()],  # 开始日期时间
    end_datetime: Annotated[datetime, Body()],    # 结束日期时间
    process_after: Annotated[timedelta, Body()],  # 处理时间间隔
    # 使用 Union[time, None] 表示可选的时间类型
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    # 计算实际开始处理时间
    start_process = start_datetime + process_after
    # 计算持续时间
    duration = end_datetime - start_process
    # 返回结果
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.8+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Union
from typing import Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI
# 从 typing_extensions 导入 Annotated(Python 3.8 需要使用 typing_extensions)
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: Annotated[datetime, Body()],  # 开始日期时间
    end_datetime: Annotated[datetime, Body()],    # 结束日期时间
    process_after: Annotated[timedelta, Body()],  # 处理时间间隔
    repeat_at: Annotated[Union[time, None], Body()] = None,  # 可选的重复时间
):
    # 计算实际开始处理时间
    start_process = start_datetime + process_after
    # 计算持续时间
    duration = end_datetime - start_process
    # 返回结果
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.10+ 非 Annotated 版本

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    # 使用默认值 Body() 标记为请求体字段
    start_datetime: datetime = Body(),
    end_datetime: datetime = Body(),        # 结束日期时间
    process_after: timedelta = Body(),      # 处理时间间隔
    # 使用 | None 语法表示可选类型(Python 3.10+)
    repeat_at: time | None = Body(default=None),
):
    # 计算实际开始处理时间
    start_process = start_datetime + process_after
    # 计算持续时间
    duration = end_datetime - start_process
    # 返回结果
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.8+ 非 Annotated 版本

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Union
from typing import Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: datetime = Body(),        # 开始日期时间
    end_datetime: datetime = Body(),          # 结束日期时间
    process_after: timedelta = Body(),        # 处理时间间隔
    # 使用 Union[time, None] 表示可选类型(Python 3.8-3.9)
    repeat_at: Union[time, None] = Body(default=None),
):
    # 计算实际开始处理时间
    start_process = start_datetime + process_after
    # 计算持续时间
    duration = end_datetime - start_process
    # 返回结果
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

## 11.3 在函数中使用

请注意, 函数内部的参数具有其自然数据类型, 你可以执行正常的日期操作, 例如:

### Python 3.10+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Annotated
from typing import Annotated
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    # 使用 Annotated 标记这些参数为请求体字段
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[time | None, Body()] = None,
):
    # 直接对日期时间进行算术运算
    # start_datetime + process_after: datetime + timedelta = datetime
    start_process = start_datetime + process_after
    # end_datetime - start_process: datetime - datetime = timedelta
    duration = end_datetime - start_process
    # 返回计算结果
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.9+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Annotated 和 Union
from typing import Annotated, Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    # 直接对日期时间进行算术运算
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.8+

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Union
from typing import Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI
# 从 typing_extensions 导入 Annotated
from typing_extensions import Annotated

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    # 直接对日期时间进行算术运算
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.10+ 非 Annotated 版本

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    # 使用默认值 Body() 标记为请求体字段
    start_datetime: datetime = Body(),
    end_datetime: datetime = Body(),
    process_after: timedelta = Body(),
    repeat_at: time | None = Body(default=None),
):
    # 直接对日期时间进行算术运算
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

### Python 3.8+ 非 Annotated 版本

```python
# 从 datetime 模块导入日期时间相关类
from datetime import datetime, time, timedelta
# 从 typing 模块导入 Union
from typing import Union
# 从 uuid 模块导入 UUID
from uuid import UUID

# 从 fastapi 导入 Body 和 FastAPI
from fastapi import Body, FastAPI

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义 PUT 路由操作
@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,  # UUID 类型的物品 ID
    start_datetime: datetime = Body(),
    end_datetime: datetime = Body(),
    process_after: timedelta = Body(),
    repeat_at: Union[time, None] = Body(default=None),
):
    # 直接对日期时间进行算术运算
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }
```

## 11.4 小结

在本章中, 你了解到:

- FastAPI 支持多种额外数据类型, 不仅限于基本的 int, float, str, bool
- 常用的额外数据类型包括:
  - `UUID`: 通用唯一标识符
  - `datetime.datetime`: 日期和时间
  - `datetime.date`: 日期
  - `datetime.time`: 时间
  - `datetime.timedelta`: 时间间隔
  - `frozenset`: 不可变集合
  - `bytes`: 字节数据
  - `Decimal`: 高精度小数
- 这些类型在请求/响应中会自动转换为相应的 JSON 格式
- 在函数内部, 参数保持其自然数据类型, 可以直接进行操作
- 编辑器会提供完整的类型提示和自动补全支持
