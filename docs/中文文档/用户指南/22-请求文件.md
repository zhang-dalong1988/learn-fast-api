# 请求文件 (Request Files)

你可以使用 `File` 来定义客户端要上传的文件.

## 1. 前置准备

### 1.1 安装依赖

要接收上传的文件, 首先需要安装 `python-multipart`.

请确保创建了虚拟环境, 激活它, 然后安装依赖, 例如:

```bash
# 安装 python-multipart 库, 用于处理 multipart/form-data 类型的请求
$ pip install python-multipart
```

这是因为上传的文件是作为 "表单数据" (form data) 发送的.

## 2. 导入 File

从 `fastapi` 中导入 `File` 和 `UploadFile`:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类和文件处理相关的类
from fastapi import FastAPI, File, UploadFile

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收文件作为 bytes 类型
@app.post("/files/")
# file 参数被注解为 bytes 类型, 并使用 File() 来指定这是文件上传
# Annotated[bytes, File()] 表示这个参数是文件, 内容会被读取为 bytes
async def create_file(file: Annotated[bytes, File()]):
    # 返回文件的大小 (字节数)
    return {"file_size": len(file)}

# 定义另一个路径操作, 接收文件作为 UploadFile 类型
@app.post("/uploadfile/")
# file 参数类型为 UploadFile, 这是一个更高级的文件处理方式
# 不需要使用 File() 作为默认值, 因为 UploadFile 本身就表示文件上传
async def create_upload_file(file: UploadFile):
    # 返回上传文件的原始文件名
    return {"filename": file.filename}
```

## 3. 定义 File 参数

创建文件参数的方式与创建 `Body` 或 `Form` 参数的方式相同:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类和文件处理相关的类
from fastapi import FastAPI, File, UploadFile

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收文件作为 bytes 类型
@app.post("/files/")
# file 参数被注解为 bytes 类型, 并使用 File() 来指定这是文件上传
# Annotated[bytes, File()] 表示这个参数是文件, 内容会被读取为 bytes
async def create_file(file: Annotated[bytes, File()]):
    # 返回文件的大小 (字节数)
    return {"file_size": len(file)}

# 定义另一个路径操作, 接收文件作为 UploadFile 类型
@app.post("/uploadfile/")
# file 参数类型为 UploadFile, 这是一个更高级的文件处理方式
# 不需要使用 File() 作为默认值, 因为 UploadFile 本身就表示文件上传
async def create_upload_file(file: UploadFile):
    # 返回上传文件的原始文件名
    return {"filename": file.filename}
```

### 3.1 技术说明

`File` 是直接继承自 `Form` 的类.

但请记住, 当你从 `fastapi` 导入 `Query`, `Path`, `File` 等时, 这些实际上是返回特殊类的函数.

### 3.2 提示

要声明文件主体, 你需要使用 `File`, 否则参数将被解释为查询参数或请求体 (JSON) 参数.

文件将作为 "表单数据" 上传.

如果你将路径操作函数参数的类型声明为 `bytes`, FastAPI 将为你读取文件, 你将以 `bytes` 形式接收内容.

请注意, 这意味着整个内容将被存储在内存中. 这对于小文件效果很好.

但在某些情况下, 使用 `UploadFile` 会更有优势.

## 4. 使用 UploadFile 的文件参数

定义一个类型为 `UploadFile` 的文件参数:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类和文件处理相关的类
from fastapi import FastAPI, File, UploadFile

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收文件作为 bytes 类型
@app.post("/files/")
# file 参数被注解为 bytes 类型, 并使用 File() 来指定这是文件上传
# Annotated[bytes, File()] 表示这个参数是文件, 内容会被读取为 bytes
async def create_file(file: Annotated[bytes, File()]):
    # 返回文件的大小 (字节数)
    return {"file_size": len(file)}

# 定义另一个路径操作, 接收文件作为 UploadFile 类型
@app.post("/uploadfile/")
# file 参数类型为 UploadFile, 这是一个更高级的文件处理方式
# 不需要使用 File() 作为默认值, 因为 UploadFile 本身就表示文件上传
async def create_upload_file(file: UploadFile):
    # 返回上传文件的原始文件名
    return {"filename": file.filename}
```

与 `bytes` 相比, 使用 `UploadFile` 有以下几个优势:

- 你不需要在参数的默认值中使用 `File()`.
- 它使用 "spooled" (缓存) 文件:
  - 文件在内存中存储, 直到达到最大大小限制, 超过此限制后将存储在磁盘上.
- 这意味着它适用于大文件 (如图片, 视频, 大型二进制文件等), 而不会消耗所有内存.
- 你可以从上传的文件中获取元数据.
- 它具有类似文件的 `async` 接口.
- 它公开了一个实际的 Python `SpooledTemporaryFile` 对象, 你可以直接将其传递给其他需要类文件对象库.

### 4.1 UploadFile 详解

`UploadFile` 具有以下属性:

- `filename`: 一个 `str` 类型, 包含上传的原始文件名 (例如 `myimage.jpg`).
- `content_type`: 一个 `str` 类型, 包含内容类型 (MIME 类型 / 媒体类型) (例如 `image/jpeg`).
- `file`: 一个 `SpooledTemporaryFile` (类文件对象). 这是实际的 Python 文件对象, 你可以直接将其传递给其他需要 "类文件" 对象的函数或库.

`UploadFile` 具有以下 `async` 方法. 它们都调用相应的文件方法 (使用内部的 `SpooledTemporaryFile`):

- `write(data)`: 将 `data` (`str` 或 `bytes`) 写入文件.
- `read(size)`: 读取文件的 `size` (`int`) 字节/字符.
- `seek(offset)`: 移动到文件中的字节位置 `offset` (`int`).
  - 例如, `await myfile.seek(0)` 将移动到文件的开头.
  - 如果你运行了一次 `await myfile.read()` 然后需要再次读取内容, 这特别有用.
- `close()`: 关闭文件.

由于所有这些方法都是 `async` 方法, 你需要使用 "await" 来调用它们.

例如, 在 `async` 路径操作函数中, 你可以这样获取内容:

```python
# 使用 await 调用异步方法 read(), 读取文件的全部内容
contents = await myfile.read()
```

如果你在普通的 `def` 路径操作函数中, 可以直接访问 `UploadFile.file`, 例如:

```python
# 在同步函数中, 直接访问 file 属性并调用 read() 方法
contents = myfile.file.read()
```

### 4.2 async 技术细节

当你使用 `async` 方法时, FastAPI 会在线程池中运行文件方法并等待它们完成.

### 4.3 Starlette 技术细节

FastAPI 的 `UploadFile` 直接继承自 Starlette 的 `UploadFile`, 但添加了一些必要的部分, 使其与 Pydantic 和 FastAPI 的其他部分兼容.

## 5. 什么是 "表单数据"

HTML 表单 (`<form></form>`) 向服务器发送数据的方式通常使用对该数据进行 "特殊" 编码, 这与 JSON 不同.

FastAPI 将确保从正确的位置读取该数据, 而不是 JSON.

### 5.1 技术细节

当表单数据不包含文件时, 通常使用 "媒体类型" `application/x-www-form-urlencoded` 进行编码.

但是当表单包含文件时, 它被编码为 `multipart/form-data`. 如果你使用 `File`, FastAPI 将知道它必须从正文的正确部分获取文件.

如果你想了解更多关于这些编码和表单字段的信息, 请查看 MDN Web 文档中的 `POST`.

### 5.2 警告

你可以在路径操作中声明多个 `File` 和 `Form` 参数, 但你不能同时声明希望作为 JSON 接收的 `Body` 字段, 因为请求将使用 `multipart/form-data` 而不是 `application/json` 来编码正文.

这不是 FastAPI 的限制, 而是 HTTP 协议的一部分.

## 6. 可选文件上传

你可以使用标准类型注解并将默认值设置为 `None` 来使文件变为可选:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类和文件处理相关的类
from fastapi import FastAPI, File, UploadFile

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收可选的文件作为 bytes 类型
@app.post("/files/")
# file 参数可以是 bytes 或 None, 默认值为 None
# Annotated[bytes | None, File()] = None 表示这是一个可选的文件上传参数
async def create_file(file: Annotated[bytes | None, File()] = None):
    # 如果没有上传文件, 返回提示消息
    if not file:
        return {"message": "No file sent"}
    else:
        # 如果上传了文件, 返回文件大小
        return {"file_size": len(file)}

# 定义另一个路径操作, 接收可选的 UploadFile
@app.post("/uploadfile/")
# file 参数可以是 UploadFile 或 None, 默认值为 None
async def create_upload_file(file: UploadFile | None = None):
    # 如果没有上传文件, 返回提示消息
    if not file:
        return {"message": "No upload file sent"}
    else:
        # 如果上传了文件, 返回文件名
        return {"filename": file.filename}
```

## 7. 带有附加元数据的 UploadFile

你也可以将 `File()` 与 `UploadFile` 一起使用, 例如设置附加元数据:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类和文件处理相关的类
from fastapi import FastAPI, File, UploadFile

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收文件作为 bytes 类型, 并添加描述信息
@app.post("/files/")
# file 参数被注解为 bytes 类型, 使用 File() 添加描述元数据
# description 参数用于在 OpenAPI 文档中显示参数说明
async def create_file(file: Annotated[bytes, File(description="A file read as bytes")]):
    # 返回文件的大小 (字节数)
    return {"file_size": len(file)}

# 定义另一个路径操作, 接收 UploadFile, 并添加描述信息
@app.post("/uploadfile/")
# file 参数类型为 UploadFile, 使用 File() 添加描述元数据
async def create_upload_file(
    # Annotated[UploadFile, File(description="...")] 添加了参数描述
    file: Annotated[UploadFile, File(description="A file read as UploadFile")],
):
    # 返回上传文件的原始文件名
    return {"filename": file.filename}
```

## 8. 多文件上传

可以同时上传多个文件.

它们将与使用 "表单数据" 发送的同一个 "表单字段" 相关联.

要使用此功能, 需要声明一个 `bytes` 或 `UploadFile` 的列表:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类、文件处理类和响应类
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收多个文件作为 bytes 类型
@app.post("/files/")
# files 参数是一个 bytes 列表, 使用 File() 指定为文件上传
# list[bytes] 表示接收多个文件, 每个文件的内容会被读取为 bytes
async def create_files(files: Annotated[list[bytes], File()]):
    # 返回所有文件的大小列表, 使用列表推导式计算每个文件的大小
    return {"file_sizes": [len(file) for file in files]}

# 定义另一个路径操作, 接收多个 UploadFile
@app.post("/uploadfiles/")
# files 参数是一个 UploadFile 列表
async def create_upload_files(files: list[UploadFile]):
    # 返回所有文件的文件名列表
    return {"filenames": [file.filename for file in files]}

# 定义一个 GET 路径操作, 返回一个 HTML 页面
@app.get("/")
async def main():
    # 定义 HTML 内容, 包含两个表单用于测试文件上传功能
    content = """
<body>
<!-- 第一个表单: 上传文件到 /files/ 端点 -->
<form action="/files/" enctype="multipart/form-data" method="post">
<!-- input name 属性对应后端参数名 "files", multiple 属性允许多选 -->
<input name="files" type="file" multiple>
<input type="submit">
</form>
<!-- 第二个表单: 上传文件到 /uploadfiles/ 端点 -->
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
    """
    # 返回 HTML 响应, content 参数指定 HTML 内容
    return HTMLResponse(content=content)
```

你将按照声明的方式接收一个 `bytes` 或 `UploadFile` 的 `list`.

### 8.1 技术细节

你也可以使用 `from starlette.responses import HTMLResponse`.

FastAPI 提供与 `starlette.responses` 相同的 `fastapi.responses`, 只是为了方便开发者使用. 但是大多数可用的响应都直接来自 Starlette.

### 8.2 带有附加元数据的多文件上传

与之前的方式相同, 你可以使用 `File()` 来设置附加参数, 即使是对于 `UploadFile`:

```python
# 从 typing 模块导入 Annotated, 用于添加类型注解和元数据
from typing import Annotated

# 从 fastapi 导入核心类、文件处理类和响应类
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse

# 创建 FastAPI 应用实例
app = FastAPI()

# 定义一个路径操作, 接收多个文件作为 bytes 类型, 并添加描述信息
@app.post("/files/")
# files 参数是一个 bytes 列表, 使用 File() 添加描述元数据
async def create_files(
    files: Annotated[list[bytes], File(description="Multiple files as bytes")],
):
    # 返回所有文件的大小列表
    return {"file_sizes": [len(file) for file in files]}

# 定义另一个路径操作, 接收多个 UploadFile, 并添加描述信息
@app.post("/uploadfiles/")
# files 参数是一个 UploadFile 列表, 使用 File() 添加描述元数据
async def create_upload_files(
    files: Annotated[
        list[UploadFile], File(description="Multiple files as UploadFile")
    ],
):
    # 返回所有文件的文件名列表
    return {"filenames": [file.filename for file in files]}

# 定义一个 GET 路径操作, 返回一个 HTML 页面
@app.get("/")
async def main():
    # 定义 HTML 内容, 包含两个表单用于测试文件上传功能
    content = """
<body>
<!-- 第一个表单: 上传文件到 /files/ 端点 -->
<form action="/files/" enctype="multipart/form-data" method="post">
<!-- input name 属性对应后端参数名 "files", multiple 属性允许多选 -->
<input name="files" type="file" multiple>
<input type="submit">
</form>
<!-- 第二个表单: 上传文件到 /uploadfiles/ 端点 -->
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
    """
    # 返回 HTML 响应, content 参数指定 HTML 内容
    return HTMLResponse(content=content)
```

## 9. 总结

使用 `File`, `bytes` 和 `UploadFile` 来声明请求中要上传的文件, 这些文件作为表单数据发送.

### 9.1 关键要点

1. **安装依赖**: 使用 `python-multipart` 处理文件上传
2. **File vs UploadFile**:
   - `bytes`: 小文件, 全部加载到内存
   - `UploadFile`: 大文件, 使用缓存和磁盘存储, 更适合生产环境
3. **可选文件**: 使用 `| None` 和默认值 `None` 使文件参数变为可选
4. **多文件上传**: 使用 `list[bytes]` 或 `list[UploadFile]` 接收多个文件
5. **元数据**: 使用 `File(description="...")` 为参数添加描述信息

### 9.2 UploadFile 的优势

- 不需要消耗所有内存即可处理大文件
- 提供异步接口 (`async` methods)
- 可以获取文件元数据 (filename, content_type)
- 可以直接传递给其他需要类文件对象的库
