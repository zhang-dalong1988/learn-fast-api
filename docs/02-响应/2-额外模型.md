# 额外模型

有几种情况你可能需要不只一个数据模型：

- **输入模型**：用于输入数据的验证
- **输出模型**：用于输出数据的响应
- **内部模型**：在内部使用的模型

## 使用多个模型

以下是一个使用多个模型的例子：

```python
from typing import Annotated

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

class UserCreate(UserBase):
    password: str

class UserInDBBase(UserBase):
    id: int
    is_active: bool

class UserInDB(UserInDBBase):
    hashed_password: str

class User(UserInDBBase):
    pass

class UserIn(UserCreate):
    pass

def fake_password_hasher(raw_password: str):
    return "supersecret" + raw_password

def fake_save_user(user_in: UserIn):
    hashed_password = fake_password_hasher(user_in.password)
    user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password, id=999999)
    return user_in_db

@app.post("/user/", response_model=User)
async def create_user(user_in: UserIn):
    user_saved = fake_save_user(user_in)
    return user_saved
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None

class UserCreate(UserBase):
    password: str

class UserInDBBase(UserBase):
    id: int
    is_active: bool

class UserInDB(UserInDBBase):
    hashed_password: str

class User(UserInDBBase):
    pass

class UserIn(UserCreate):
    pass

def fake_password_hasher(raw_password: str):
    return "supersecret" + raw_password

def fake_save_user(user_in: UserIn):
    hashed_password = fake_password_hasher(user_in.password)
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password, id=999999)
    return user_in_db

@app.post("/user/", response_model=User)
async def create_user(user_in: UserIn):
    user_saved = fake_save_user(user_in)
    return user_saved
```

## 关于 `Union` 或 `anyOf`

你不能直接将 `Union` 用于响应模型，例如：

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class BaseItem(BaseModel):
    description: str
    type: str

class CarItem(BaseItem):
    type: str = "car"
    model: str

class PlaneItem(BaseItem):
    type: str = "plane"
    size: int

items = {
    "item1": {"description": "All my friends drive a low rider", "type": "car", "model": "Ford"},
    "item2": {"description": "Music is my aeroplane, it's my aeroplane", "type": "plane", "size": 5},
}

@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    return items[item_id]
```

## 使用 `Union` 的问题

在路径操作中使用 `Union[PlaneItem, CarItem]` 作为响应模型不会生成 OpenAPI schema，它只是省略了响应模式。

这是因为 OpenAPI 没有指定两个可能返回的 JSON Schema 的方法。

如果你正在构建客户端和服务器，你可能需要在某个地方生成代码，那么你将无法使用 OpenAPI 来生成代码，因为那里没有指定 JSON Schema。

## 模型复制

在许多情况下，你想要从一个模型复制数据到另一个模型，你可以使用 Pydantic 的 `.model_copy()` 方法：

```python
from typing import Annotated

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: str
    full_name: str | None = None

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    hashed_password: str

def fake_save_user(user_in: UserCreate):
    hashed_password = "notreallyhashed"
    user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)
    return user_in_db

@app.post("/user/")
async def create_user(user_in: UserCreate):
    user_saved = fake_save_user(user_in)
    return user_saved
```

### Python 3.8+

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: str
    full_name: Union[str, None] = None

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    hashed_password: str

def fake_save_user(user_in: UserCreate):
    hashed_password = "notreallyhashed"
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    return user_in_db

@app.post("/user/")
async def create_user(user_in: UserCreate):
    user_saved = fake_save_user(user_in)
    return user_saved
```

## 使用 Pydantic 的 `response_model`

你可以直接使用 Pydantic 模型作为 `response_model`：

```python
from typing import Annotated

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str

items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]

@app.get("/items/", response_model=list[Item])
async def read_items():
    return items
```

### Python 3.9+

```python
from typing import List

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str

items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]

@app.get("/items/", response_model=List[Item])
async def read_items():
    return items
```

### Python 3.8+

```python
from typing import List

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str

items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]

@app.get("/items/", response_model=List[Item])
async def read_items():
    return items
```

## 总结

使用多个模型可以：

- 更清晰地分离不同的数据需求
- 提高安全性（例如，不在响应中返回密码）
- 使代码更易于维护和理解
- 允许你为不同的目的使用不同的验证规则
