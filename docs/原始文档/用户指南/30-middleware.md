# Middleware

You can add middleware to __FastAPI__ applications.

A "middleware" is a function that works with every __request__ before it is processed by any specific _path operation_. And also with every __response__ before returning it.

- It takes each __request__ that comes to your application.
- It can then do something to that __request__ or run any needed code.
- Then it passes the __request__ to be processed by the rest of the application (by some _path operation_).
- It then takes the __response__ generated by the application (by some _path operation_).
- It can do something to that __response__ or run any needed code.
- Then it returns the __response__.

**Technical Details**

If you have dependencies with `yield`, the exit code will run _after_ the middleware.

If there were any background tasks (covered in the Background Tasks section, you will see it later), they will run _after_ all the middleware.

## Create a middleware

To create a middleware you use the decorator `@app.middleware("http")` on top of a function.

The middleware function receives:

- The `request`.
- A function `call_next` that will receive the `request` as a parameter.
  - This function will pass the `request` to the corresponding _path operation_.
  - Then it returns the `response` generated by the corresponding _path operation_.
- You can then further modify the `response` before returning it.

**Python 3.8+**

```python
import time

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.perf_counter()
    response = await call_next(request)
    process_time = time.perf_counter() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

**Technical Details**

You could also use `from starlette.requests import Request`.

__FastAPI__ provides it as a convenience for you, the developer. But it comes directly from Starlette.

### Before and after the `response`

You can add code to be run with the `request`, before any _path operation_ receives it.

And also after the `response` is generated, before returning it.

For example, you could add a custom header `X-Process-Time` containing the time in seconds that it took to process the request and generate a response:

**Python 3.8+**

```python
import time

from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.perf_counter()
    response = await call_next(request)
    process_time = time.perf_counter() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

**Tip**

Here we use `time.perf_counter()` instead of `time.time()` because it can be more precise for these use cases. ðŸ¤“

## Multiple middleware execution order

When you add multiple middlewares using either `@app.middleware()` decorator or `app.add_middleware()` method, each new middleware wraps the application, forming a stack. The last middleware added is the _outermost_, and the first is the _innermost_.

On the request path, the _outermost_ middleware runs first.

On the response path, it runs last.

For example:

```python
app.add_middleware(MiddlewareA)
app.add_middleware(MiddlewareB)
```

This results in the following execution order:

- __Request__: MiddlewareB â†’ MiddlewareA â†’ route
- __Response__: route â†’ MiddlewareA â†’ MiddlewareB

This stacking behavior ensures that middlewares are executed in a predictable and controllable order.

## Other middlewares

You can later read more about other middlewares in the Advanced User Guide: Advanced Middleware.

You will read about how to handle CORS with a middleware in the next section.
