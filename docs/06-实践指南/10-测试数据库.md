# 测试数据库¶

## 概述¶

在使用 FastAPI 开发需要数据库的应用时,测试是一个重要环节.本节将介绍如何测试与数据库交互的代码.

## 测试策略¶

### 1. 使用测试数据库¶

最佳实践是使用单独的测试数据库,而不是开发或生产数据库.

```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 使用内存 SQLite 数据库进行测试
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

# 在应用中覆盖依赖项
app.dependency_overrides[get_db] = override_get_db

client = TestClient(app)

@pytest.fixture(scope="function")
def test_db():
    Base.metadata.create_all(bind=engine)
    yield
    Base.metadata.drop_all(bind=engine)
```

### 2. 数据库事务回滚¶

使用事务来确保测试之间的隔离性,每个测试后回滚事务.

```python
import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

@pytest.fixture
def db_session():
    """创建一个在测试结束后回滚的数据库会话"""
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)

    yield session

    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def client(db_session):
    """创建使用测试数据库会话的测试客户端"""
    def override_get_db():
        yield db_session

    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()
```

### 3. 工厂模式测试¶

使用工厂模式创建测试数据:

```python
import factory
from factory.alchemy import SQLAlchemyModelFactory

class UserFactory(SQLAlchemyModelFactory):
    class Meta:
        model = User
        sqlalchemy_session = TestingSessionLocal

    name = factory.Sequence(lambda n: f"user_{n}")
    email = factory.LazyAttribute(lambda obj: f"{obj.name}@example.com")

# 在测试中使用
def test_create_user(client):
    user_data = UserFactory.build()
    response = client.post("/users/", json={
        "name": user_data.name,
        "email": user_data.email
    })
    assert response.status_code == 200
    assert response.json()["name"] == user_data.name
```

## 测试示例¶

### 测试 CRUD 操作¶

```python
def test_create_item(client, db_session):
    """测试创建项目"""
    item_data = {
        "title": "Test Item",
        "description": "Test Description"
    }
    response = client.post("/items/", json=item_data)
    assert response.status_code == 200

    data = response.json()
    assert data["title"] == item_data["title"]
    assert "id" in data

def test_read_item(client, db_session):
    """测试读取项目"""
    # 首先创建一个项目
    item = Item(title="Test Item", description="Test Description")
    db_session.add(item)
    db_session.commit()

    response = client.get(f"/items/{item.id}")
    assert response.status_code == 200

    data = response.json()
    assert data["id"] == item.id
    assert data["title"] == item.title

def test_update_item(client, db_session):
    """测试更新项目"""
    # 创建项目
    item = Item(title="Original Title", description="Original Description")
    db_session.add(item)
    db_session.commit()

    # 更新项目
    update_data = {
        "title": "Updated Title",
        "description": "Updated Description"
    }
    response = client.put(f"/items/{item.id}", json=update_data)
    assert response.status_code == 200

    data = response.json()
    assert data["title"] == update_data["title"]
    assert data["description"] == update_data["description"]

def test_delete_item(client, db_session):
    """测试删除项目"""
    # 创建项目
    item = Item(title="To Delete", description="Will be deleted")
    db_session.add(item)
    db_session.commit()
    item_id = item.id

    # 删除项目
    response = client.delete(f"/items/{item_id}")
    assert response.status_code == 200

    # 确认已删除
    response = client.get(f"/items/{item_id}")
    assert response.status_code == 404
```

### 测试关联关系¶

```python
def test_user_items_relationship(client, db_session):
    """测试用户和项目的关联关系"""
    # 创建用户
    user = User(name="Test User", email="test@example.com")
    db_session.add(user)

    # 为用户创建项目
    item1 = Item(title="Item 1", owner_id=user.id)
    item2 = Item(title="Item 2", owner_id=user.id)
    db_session.add_all([item1, item2])
    db_session.commit()

    # 获取用户的所有项目
    response = client.get(f"/users/{user.id}/items")
    assert response.status_code == 200

    data = response.json()
    assert len(data) == 2
    assert all(item["owner_id"] == user.id for item in data)
```

## 测试异步数据库操作¶

如果使用异步数据库驱动(如 asyncpg、aiosqlite):

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_create_item_async(async_client: AsyncClient):
    """测试异步创建项目"""
    item_data = {
        "title": "Async Item",
        "description": "Created with async"
    }
    response = await async_client.post("/items/", json=item_data)
    assert response.status_code == 200

    data = response.json()
    assert data["title"] == item_data["title"]

@pytest.fixture
async def async_client():
    """创建异步测试客户端"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
```

## 使用 Fixtures 进行数据设置¶

```python
@pytest.fixture
def sample_user(db_session):
    """创建示例用户"""
    user = User(
        name="Sample User",
        email="sample@example.com",
        hashed_password="hashed_password"
    )
    db_session.add(user)
    db_session.commit()
    return user

@pytest.fixture
def sample_items(db_session, sample_user):
    """创建示例项目"""
    items = [
        Item(title="Item 1", description="Description 1", owner_id=sample_user.id),
        Item(title="Item 2", description="Description 2", owner_id=sample_user.id),
    ]
    db_session.add_all(items)
    db_session.commit()
    return items

def test_user_items(client, sample_user, sample_items):
    """测试用户项目关联"""
    response = client.get(f"/users/{sample_user.id}/items")
    assert response.status_code == 200
    data = response.json()
    assert len(data) == len(sample_items)
```

## Mock 数据库进行单元测试¶

对于纯单元测试,可以使用 mock 对象:

```python
from unittest.mock import Mock, patch

@patch("app.crud.get_user")
def test_get_user_mock(mock_get_user):
    """使用 mock 测试获取用户"""
    # 设置 mock 返回值
    mock_user = User(id=1, name="Mock User")
    mock_get_user.return_value = mock_user

    # 测试
    response = client.get("/users/1")
    assert response.status_code == 200
    assert response.json()["name"] == "Mock User"

    # 验证 mock 被正确调用
    mock_get_user.assert_called_once_with(db=ANY, user_id=1)
```

## 测试数据库约束¶

```python
def test_unique_email_constraint(client, db_session):
    """测试唯一邮箱约束"""
    # 创建第一个用户
    UserFactory.create(email="unique@example.com")

    # 尝试创建相同邮箱的用户
    response = client.post("/users/", json={
        "name": "Another User",
        "email": "unique@example.com"
    })
    assert response.status_code == 400
    assert "email already registered" in response.json()["detail"].lower()
```

## 性能测试¶

```python
import time

def test_bulk_insert_performance(client, db_session):
    """测试批量插入性能"""
    start_time = time.time()

    items_data = [
        {"title": f"Item {i}", "description": f"Description {i}"}
        for i in range(1000)
    ]

    for item_data in items_data:
        client.post("/items/", json=item_data)

    end_time = time.time()
    duration = end_time - start_time

    # 断言性能在可接受范围内
    assert duration < 10.0  # 10秒内完成
```

## 最佳实践总结¶

1. **使用独立的测试数据库**:避免污染开发或生产数据
2. **使用事务回滚**:确保测试之间的隔离性
3. **使用工厂模式**:简化测试数据的创建
4. **合理使用 fixtures**:重用测试数据和配置
5. **Mock 适当的部分**:专注于要测试的功能
6. **测试边界情况**:包括错误情况和约束
7. **保持测试简单**:每个测试只验证一个功能点
8. **定期运行测试**:在 CI/CD 流程中集成测试