# 自定义请求和 APIRoute 类¶

## 理解自定义请求和 APIRoute 类¶

FastAPI 提供了强大的自定义功能,允许你扩展和修改请求处理行为.主要通过自定义 `Request` 类和 `APIRoute` 类来实现.

## 自定义 Request 类¶

你可以创建自定义的 `Request` 类来添加额外的功能或方法.

```python
from fastapi import Request, FastAPI
from typing import Dict, Any

class CustomRequest(Request):
    async def json(self) -> Dict[str, Any]:
        # 获取原始 JSON 数据
        data = await super().json()
        # 添加自定义处理逻辑
        if "user_id" not in data:
            data["user_id"] = self.headers.get("X-User-ID")
        return data

app = FastAPI()

@app.middleware("http")
async def add_custom_request_type(request: Request, call_next):
    # 将 Request 类型转换为 CustomRequest
    custom_request = CustomRequest(request.scope, request.receive)
    response = await call_next(custom_request)
    return response

@app.post("/items/")
async def create_item(request: CustomRequest):
    data = await request.json()
    return {"item": data}
```

## 自定义 APIRoute 类¶

通过继承 `APIRoute` 类,你可以完全控制路由的处理方式.

```python
from fastapi import FastAPI, Request, Response
from fastapi.routing import APIRoute
from typing import Callable, List, Dict, Any
import time
import logging

logger = logging.getLogger(__name__)

class TimedRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            # 记录请求开始时间
            start_time = time.time()

            # 调用原始路由处理器
            response = await original_route_handler(request)

            # 计算处理时间
            process_time = time.time() - start_time

            # 添加处理时间到响应头
            response.headers["X-Process-Time"] = str(process_time)

            # 记录日志
            logger.info(
                f"{request.method} {request.url.path} - "
                f"Status: {response.status_code} - "
                f"Time: {process_time:.4f}s"
            )

            return response

        return custom_route_handler

app = FastAPI()
# 使用自定义路由类
app.router.route_class = TimedRoute

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id, "description": f"Item {item_id}"}
```

## 高级用例:验证和转换 APIRoute¶

```python
from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.routing import APIRoute
from typing import Callable, Dict, Any
import json
from pydantic import BaseModel, ValidationError

class Item(BaseModel):
    name: str
    price: float
    description: str = None

class ValidationRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            try:
                # 如果是 POST 或 PUT 请求,验证请求体
                if request.method in ["POST", "PUT"]:
                    body = await request.body()
                    data = json.loads(body)

                    # 尝试验证数据
                    try:
                        Item(**data)
                    except ValidationError as e:
                        raise HTTPException(
                            status_code=422,
                            detail=str(e)
                        )

                # 调用原始路由处理器
                response = await original_route_handler(request)

                # 添加自定义响应头
                response.headers["X-Custom-Header"] = "Validation-Enabled"

                return response

            except json.JSONDecodeError:
                raise HTTPException(
                    status_code=400,
                    detail="Invalid JSON"
                )

        return custom_route_handler

app = FastAPI()
app.router.route_class = ValidationRoute

@app.post("/items/")
async def create_item(item: Item):
    return {"item": item, "status": "created"}
```

## 使用依赖项进行自定义处理¶

另一种自定义方式是通过依赖项:

```python
from fastapi import FastAPI, Request, Depends, Header, HTTPException
from typing import Optional

app = FastAPI()

async def verify_api_key(
    x_api_key: Optional[str] = Header(None)
):
    if x_api_key != "secret-key":
        raise HTTPException(
            status_code=403,
            detail="Invalid API Key"
        )
    return x_api_key

@app.get("/protected-data", dependencies=[Depends(verify_api_key)])
async def get_protected_data():
    return {"data": "This is protected data"}
```

## 总结

自定义请求和路由类提供了强大的能力来扩展 FastAPI 的功能:

1. **自定义 Request 类**:添加额外的请求处理方法
2. **自定义 APIRoute 类**:完全控制请求/响应处理流程
3. **中间件方法**:通过中间件添加自定义处理逻辑
4. **依赖项方式**:使用依赖项进行验证和处理

这些技术允许你根据特定需求定制 FastAPI 应用程序的行为.