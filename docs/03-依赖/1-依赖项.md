# 依赖项

**FastAPI** 有一个强大的**依赖注入**系统.

它允许您:

- 共享逻辑(数据库连接、用户认证、权限检查等)
- 共享数据库连接
- 实现用户认证和授权
- 实现响应头添加
- 等等...

## 第一个依赖项

让我们从一个简单的例子开始.

### 创建依赖函数

```python
from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons
```

### 依赖项是做什么的?

- 它是一个接收参数的函数
- 可以接收其他依赖项
- 返回一个值
- 这个值将作为参数注入到路径操作函数中

### Python 3.9+ 版本

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(
    q: str | None = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

> **提示**
>
> 如果可能,请优先使用 `Annotated` 版本.

## 依赖项的返回值

依赖项的返回值将作为参数注入到路径操作函数中:

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(
    q: str | None = None, skip: int = 0, limit: int = 100
):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    # commons 的值是 common_parameters 的返回值
    # 例如: {"q": "some query", "skip": 0, "limit": 100}
    return commons
```

## 依赖项作为类

依赖项不一定非得是函数,也可以是类.

### 类作为依赖项

```python
from typing import Annotated, Union

from fastapi import Depends, FastAPI

app = FastAPI()

fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

class CommonQueryParams:
    def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    response.update({"items": fake_items_db[commons.skip : commons.skip + commons.limit]})
    return response
```

**FastAPI** 会:

- 创建 `CommonQueryParams` 类的实例
- 将请求参数传递给 `__init__` 方法
- 返回该实例

### 使用 `dependencies` 参数

您也可以使用路径操作装饰器的 `dependencies` 参数:

```python
from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

## 带有 `yield` 的依赖项

使用 `yield` 可以在依赖项完成后执行清理代码.

### 数据库连接示例

```python
from typing import Annotated

from fastapi import Depends

async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/")
async def read_users(db: Annotated[Session, Depends(get_db)]):
    users = db.query(User).all()
    return users
```

### 上下文管理器

```python
from contextlib import asynccontextmanager
from typing import Annotated

from fastapi import Depends

@asynccontextmanager
async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/")
async def read_users(db: Annotated[Session, Depends(get_db)]):
    # 使用 db
    pass
```

### 带异常处理的 `yield`

```python
from typing import Annotated

from fastapi import Depends

async def get_db():
    db = DBSession()
    try:
        yield db
    except Exception as e:
        db.rollback()
        raise
    finally:
        db.close()

@app.get("/users/")
async def read_users(db: Annotated[Session, Depends(get_db)]):
    # 使用 db
    pass
```

## 子依赖项

依赖项可以依赖于其他依赖项.

### 基本示例

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

def query_extractor(q: str | None = None):
    return q

def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: str | None = None,
):
    if not q:
        return last_query
    return q

@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)]
):
    return {"q_or_cookie": query_or_default}
```

## 多个依赖项

一个路径操作可以声明多个依赖项:

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")
    return x_token

@app.get("/items/")
async def read_items(
    commons: Annotated[dict, Depends(common_parameters)],
    token: Annotated[str, Depends(verify_token)],
):
    return {"commons": commons, "token": token}
```

## 列表中的依赖项

您也可以在列表中声明依赖项:

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")

@app.get("/items/")
async def read_items(
    dependencies: Annotated[
        list, Depends([verify_token, verify_key])
    ]
):
    return [{"item": "Foo"}, {"item": "Bar"}]
```

## 全局依赖项

您可以为整个应用添加全局依赖项:

```python
from fastapi import Depends, FastAPI, Header

app = FastAPI()

async def verify_token(x_token: str = Header()):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

app = FastAPI(dependencies=[Depends(verify_token)])

@app.get("/items/")
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

## 总结

**FastAPI** 的依赖注入系统非常强大:

- 可以声明函数、类或生成器作为依赖项
- 依赖项可以嵌套(子依赖项)
- 可以有多个依赖项
- 支持全局依赖项
- 使用 `yield` 进行资源清理
- 自动处理依赖项的缓存