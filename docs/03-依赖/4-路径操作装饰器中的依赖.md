# 路径操作装饰器中的依赖

在某些情况下，你并不真正需要在路径操作函数内部使用依赖的返回值。

或者依赖不返回值。

但你仍然需要执行/解决它。

对于这些情况，你可以在路径操作装饰器中添加一个 `dependencies` 列表，而不是使用 `Depends` 声明路径操作函数参数。

## 将 `dependencies` 添加到路径操作装饰器

路径操作装饰器接收一个可选参数 `dependencies`。

它应该是一个 `Depends()` 的列表：

**Python 3.9+**

```python
from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**Python 3.8+**

```python
from fastapi import Depends, FastAPI, Header, HTTPException
from typing_extensions import Annotated

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

**Python 3.8+ - non-Annotated**

```python
from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: str = Header()):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: str = Header()):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

> 提示：如果可能，优先使用 `Annotated` 版本。

这些依赖将以与普通依赖相同的方式执行/解决。但是它们的值（如果它们返回任何值）不会传递给你的路径操作函数。

> 提示
>
> 一些编辑器会检查未使用的函数参数，并将它们显示为错误。
>
> 在路径操作装饰器中使用这些 `dependencies` 可以确保它们被执行，同时避免编辑器/工具的错误。
>
> 这也可能有助于避免新开发人员的困惑，他们看到代码中未使用的参数，可能会认为它是不必要的。

> 信息
>
> 在这个例子中，我们使用了自定义的头部 `X-Key` 和 `X-Token`。
>
> 但在实际情况下，当实现安全性时，你将获得更多使用集成安全工具的好处（下一章）。

## 依赖错误和返回值

你可以使用与通常相同的依赖函数。

### 依赖需求

它们可以声明请求需求（如头部）或其他子依赖：

**Python 3.9+**

```python
from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### 抛出异常

这些依赖可以 `raise` 异常，与普通依赖相同：

```python
from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

### 返回值

它们可以返回值或不返回值，值不会被使用。

因此，你可以重用你已经在其他地方使用的普通依赖（返回值的依赖），即使值不会被使用，依赖也会被执行：

```python
from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()

async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]
```

## 一组路径操作的依赖

稍后，当阅读关于如何构建更大的应用程序（大型应用 - 多文件）时，可能涉及多个文件，你将学习如何为一组路径操作声明单个 `dependencies` 参数。

## 全局依赖

接下来我们将看到如何向整个 `FastAPI` 应用程序添加依赖，使它们适用于每个路径操作。