# 6-子依赖项

你可以创建具有**子依赖项**的依赖项。

它们可以根据需要实现任意**深度**的嵌套。

**FastAPI** 会负责解析它们。

## 第一个依赖项 ("被依赖者")

你可以创建第一个依赖项（"被依赖者"），如下所示：

### Python 3.10+

```python
from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()

def query_extractor(q: str | None = None):
    return q

def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q

@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}
```

它声明了一个可选的查询参数 `q` 作为 `str` 类型，然后直接返回它。

这非常简单（不是很有用），但将帮助我们专注于子依赖项是如何工作的。

## 第二个依赖项，既是"被依赖者"又是"依赖者"

然后你可以创建另一个依赖函数（"被依赖者"），它同时声明了自己的依赖项（因此它也是一个"依赖者"）：

### Python 3.10+

```python
from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()

def query_extractor(q: str | None = None):
    return q

def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q

@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}
```

让我们关注声明的参数：

- 尽管这个函数本身就是一个依赖项（"被依赖者"），但它也声明了另一个依赖项（它"依赖"于其他东西）。
  - 它依赖于 `query_extractor`，并将其返回的值赋给参数 `q`。
- 它还声明了一个可选的 `last_query` cookie，作为 `str` 类型。
  - 如果用户没有提供任何查询 `q`，我们使用之前使用的最后一个查询，我们之前将它保存到了 cookie 中。

## 使用依赖项

然后我们可以这样使用依赖项：

### Python 3.10+

```python
from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()

def query_extractor(q: str | None = None):
    return q

def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q

@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}
```

> **提示**
>
> 请注意，我们在**路径操作函数**中只声明了一个依赖项，即 `query_or_cookie_extractor`。
>
> 但是 **FastAPI** 会知道它需要先解决 `query_extractor`，以便将其结果传递给 `query_or_cookie_extractor`。

依赖关系图如下：
```
query_extractor -> query_or_cookie_extractor -> read_query(/items/)
```

## 多次使用同一个依赖项

如果你的某个依赖项为同一个**路径操作**声明了多次，例如，多个依赖项有一个公共的子依赖项，**FastAPI** 会知道在每个请求中只调用该子依赖项一次。

它将把返回的值保存在"缓存"中，并将其传递给在该特定请求中需要它的所有"依赖者"，而不是为同一请求多次调用依赖项。

在高级场景中，如果你知道需要在同一请求中的每一步（可能多次）调用依赖项而不是使用"缓存"值，你可以在使用 `Depends` 时设置参数 `use_cache=False`：

### Python 3.8+

```python
async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
    return {"fresh_value": fresh_value}
```

## 总结

除了这里使用的所有花哨的术语外，**依赖注入**系统非常简单。

只是看起来与**路径操作函数**相同的函数。

尽管如此，它非常强大，允许你声明任意深度嵌套的依赖项"图"（树）。

> **提示**
>
> 在这些简单的例子中，这一切可能看起来不那么有用。
>
> 但是在关于**安全性**的章节中，你将看到它有多么有用。
>
> 你还将看到它将为你节省多少代码量。